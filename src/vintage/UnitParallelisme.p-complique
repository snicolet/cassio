UNIT UnitParallelisme;


INTERFACE






{$DEFINEC AVEC_DEBUG_PARALLELISME   FALSE }
{$DEFINEC USE_ASSERTIONS_DE_PARALLELISME   TRUE }
{$DEFINEC AVEC_MESURE_DE_PARALLELISME   TRUE }


USES Multiprocessing,UnitBitboardTypes,UnitOth0,UnitBitboardModifPlat,UnitBitboardHash;


const kMPStackSize                               = 0;         // use default stack size
      kMPTaskOptions                             = 0;         // use no options
       
      
      kValeurSpecialeInterruptionCalculParallele = -763563;   // a negative magic number
      kNroThreadNotFound                         = -33;
      kPasDInterrumptionPourCetteThread          = -1;        // MUST be strictly negative
      
      
      kNombreMaxAlphaBetaTasks                   = 1;
      kNombreDeTableHachageBitboard              = 1;         // mettre 1 si toutes les threads partagent la meme table, sinon le nombre de threads plus un
      kNombreDeProfilersDuParallelisme           = 20;
      
      
      kPleaseGoSleeping                          = 0;
      kPleaseWaitForJobPreparation               = 1;
      kPleaseExploreThisSubtree                  = 2;
      kPleaseDoSpinLock                          = 3;
      kNoOrderReceived                           = 4;
      kAnyState                                  = 2000;
      
      
      kValeurMutexEcritureResultat               = -1;
      kValeurMutexLectureResultat                = -2;
      
      
      
      kVerbosityLevelAlgoParallele               = 0;
      kNombreDeNoeudMinimalPourSuiviDansRapport  = 0;    // par exemple 126287514;

      
      kNombreMutexAccesBitboard                  = 512;      // doit etre une puissance de deux
      kMutexAccesBitboardMask                    = kNombreMutexAccesBitboard - 1;
      
      
      kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE    = 1;
      kTROUVER_D_AUTRES_TACHES_AU_CHOMAGE        = 2;
      kRECEVOIR_UN_NOUVEAU_RESULTAT              = 3;
      kANALYSER_UN_RESULTAT                      = 4;
      kCONTINUER_NORMALEMENT                     = 5;



type NoeudDeParallelisme = record
                             nroThreadDuPere                    : SInt32;
                             nbreVides                          : SInt32;
                             alpha, beta                        : SInt32;
                             diffPions                          : SInt32;
                             filsDebut,filsFin                  : SInt32;
                             nroDuFilsCourant                   : SInt32;
                             maximum                            : SInt32;
                             pos_my_bits_low,pos_my_bits_high   : SInt32;
                             pos_opp_bits_low,pos_opp_bits_high : SInt32;
                             listeBitboard                      : UInt32;
                             vecteurParite                      : SInt32;
                             nbreResultatsEnAttente             : SInt32;
                             threadAffecteeACeFils              : array[0..31] of SInt32;
                             filsEnAttenteDeLancement           : array[0..31] of boolean;
                             listeDesCoupsLegaux                : listeVides;
                             hashStamp                          : SInt32;
                             bestDef                            : UInt32;
                             nroDuDernierFilsEvalue             : SInt32;
                             betaCoupureTrouvee                 : boolean;
                           end;

    ParallelAlphaBetaRec = record
                              positionSubTree        : bitboard;
                              profondeurSubTree      : SInt32;
                              alphaSubTree           : SInt32;
                              betaSubTree            : SInt32;
                              diffPionsSubTree       : SInt32;
                              vecteurPariteSubTree   : SInt32;
                              listeBitboardSubTree   : UInt32;
                              nroThread              : SInt32;
                              threadDuPere           : SInt32;
                              coupSubTree            : SInt32;
                              hashDuPere             : SInt32;
                              message                : SInt32;
                              etat                   : SInt32;
                              semaphoreDeReveil      : MPSemaphoreID;  
                              taskID                 : MPTaskID;
                            end;
                            
     ParallelAlphaBetaPtr = ^ParallelAlphaBetaRec;
     ParallelAlphaBetaRecArray = array[0..0] of ParallelAlphaBetaRec;
     ParallelAlphaBetaRecArrayPtr = ^ParallelAlphaBetaRecArray;


var gTerminaisonDesTaches                       : MPQueueID;
    gListeDesThreadsMortes                      : MPQueueID;
    gAlphaBetaTasksData                         : ParallelAlphaBetaRecArrayPtr;
    
    
    gNbreThreadsDisponibles                     : SInt32;
    numProcessors                               : SInt32;
    gNbreProcesseursCalculant                   : SInt32;
    
    CassioUtiliseLeMultiprocessing              : boolean;
    gUseSpinLocks                               : boolean;
    gSpinLocksYieldTimeToCPU                    : boolean;
    gCheckingResultsHasHighPriority             : boolean;
    gParallelismeRecursif                       : boolean;
    gParallelismeSeulementPourLesFenetresNulles : boolean;
    gParallelismeSeulementPourCoupuresProbables : boolean;
    gAvecAttenteTouchePourDebuguerParallelisme  : boolean;
    
    gRapportCriticalRegionID                    : MPCriticalRegionID;
    gMesureDeParallelsimeMutex                  : SInt32;
    
    gAlphaBetaInterrompu                        : array[0..kNombreMaxAlphaBetaTasks] of SInt32;
    gMutexEcritureInterruptionThread            : array[0..kNombreMaxAlphaBetaTasks] of SInt32;
    
    gFileDesResultats                           : array[0..kNombreMaxAlphaBetaTasks] of
                                                    record
                                                      nombreDeResultats  : SInt32;
                                                      valeurResultat     : SInt32;
                                                      coup               : SInt32;
                                                      hashPere           : SInt32;
                                                      profondeur         : SInt32;
                                                    end;
    
    gNombreDeCoupuresBetaPresquesSures          : SInt32;
    gNombreDeCoupuresBetaReussies               : SInt32;
    
    gNbreAppelsMesureDeParallelisme             : SInt32;
    gDegreDeParallelisme                        : SInt32;
    gNbreDeSplitNodes                           : SInt32;
    gNbreDeCoupuresBetaDansUnSplitNode          : SInt32;
    gFraisDeSynchronisation                     : SInt32;
    
    
    gYoungBrotherWaitElders                     : SInt32;
    gNbreEmptiesMinimalPourParallelisme         : SInt32;
    gExtensionDeParallelisme                    : SInt32;
    gExtensionDeCoupureBetaProbable             : SInt32;
    
    
    
    gBitboardHashTable                          : array[0..kNombreDeTableHachageBitboard-1] of BitboardHashTable;
    gMutexAccesBitboardHash                     : array[0..kNombreMutexAccesBitboard-1] of SInt32;
    
    
    gProfilerParallelisme                       : array[0..kNombreDeProfilersDuParallelisme] of SInt32;
    

    gNoeudsDeParallelisme                       : array[0..kNombreMaxAlphaBetaTasks, 0..64] of NoeudDeParallelisme;



    
    
// Initialisations de l'unite 

procedure InitUnitParallelisme;
procedure LibereMemoireUnitParallelisme;


// Fonctions generales sur le multiprocessing 

function MPLibraryIsLoaded : boolean;
function Reflector(parameter : univ Ptr) : OSStatus;
procedure CalculateIntertaskSignalingTime;
function OrdinateurMultiprocesseurSimuleSurUnMonoprocesseur : boolean;



////////////  PARALELLISATION DE L'ALPHA-BETA   ///////////////




// Fonction d'interface avec l'alpha-beta sequentiel

function CalculerCoupsEnParallele(inNroThreadDuPere                            : SInt32; 
                                  inNroThreadFilsDisponible                    : SInt32; 
                                  inPosition                                   : bitboard; 
                                  inNbreVides                                  : SInt32; 
                                  inAlpha,inBeta                               : SInt32; 
                                  inDiffPions                                  : SInt32; 
                                  inVecteurParite                              : SInt32; 
                                  inListeBitboard                              : UInt32;
                                  var inListeDesCoupsLegaux                    : listeVides; 
                                  indexPremierFils,indexDernierFils            : SInt32; 
                                  var outMeilleureDefense                      : UInt32; 
                                  var outNroDuDernierFilsEvalue                : SInt32)     : SInt32;


// Interruption generale d'une thread à partir d'un certain niveau

procedure InterrompreUneThread(nroThread, nbreCasesVides : SInt32; siElleEstDansCetEtat : SInt32);
procedure EnleverLInterruptionPourCetteThread(nroThread, nbreCasesVides : SInt32);
function ThreadEstInterrompue(nroThread, nbreCasesVides : SInt32) : boolean;


// Reservation des threads

function NbreDeThreadsDisponibles : SInt32;
function PeutTrouverUneThreadDisponible(nroThreadMaitre : SInt32; var nroThreadEsclave : SInt32) : boolean;


// Gestion d'un noeud de parallelisme

procedure GererNoeudDeParallelisme(var node : NoeudDeParallelisme; action : SInt32);


// Preparation et lancement des fils dans un noeud de parallelisme

function PeutTrouverUneThreadEsclave(var node : NoeudDeParallelisme; action : SInt32; var nroThreadFilsAuChomage : SInt32) : boolean;
procedure PreparerUnTravailPourLaThreadAuChomage(var node: NoeudDeParallelisme; nroThreadFilsAuChomage : SInt32);
function MeLancerMoiMemeRecursivementSurUnFils(var node : NoeudDeParallelisme; var coupDuFils : SInt32) : SInt32;
procedure LancerUnFils(nroThreadDuFils : SInt32);


// Gestion de l'interruption d'un noeud de parallelisme

function InterruptionDansCeNoeudDeParallelisme(var node : NoeudDeParallelisme) : boolean;
procedure InterrompreUnFils(var node : NoeudDeParallelisme; nroThreadAInterrompre : SInt32);
procedure EnleverLaReservationDUneThread(var node : NoeudDeParallelisme; nroThreadALiberer : SInt32);


// Attente active des resultats des autres fils dans un noeud de parallelisme

procedure AttendreDesResultatsEnProposantSesServices(var node : NoeudDeParallelisme);


// Calcul d'un sous-arbre par une thread

function MySubTreeValue( plat : bitboard; nbreVides, alpha, beta, diffPions, vecteurParite, nroThread, nroThreadPere : SInt32; listeBitboard : UInt32) : SInt32;

                                  
// Transmission des resultats entre  les threads            
                      
function GetAResultForThisThreadAndLock(nroThread : SInt32; var profondeurNoeudDeParallelisme : SInt32) : boolean;
function GetAResultAtThisDepthAndLock(nroThread, profondeurSouhaitee : SInt32) : boolean;
procedure PosterUnResultatAUneThread(nroThreadDuPere, valeur, whichMove, hashStampDuPere, nbCasesVidesDuPere : SInt32);   
procedure EcouterLesResultatsDansCetteThread(nroThread : SInt32);
                   
                                  
// Les threads elles-meme   
      
procedure CreateAlphaBetaTasks;
procedure StopAlphaBetaTasks;               
function MyAlphaBetaTask( parameter : univ Ptr) : OSStatus;


//  Mesure de parallelisme, par exemple à quatre cases vides

procedure PointDeMesureDeParallelisme;
function TauxDeParallelisme : extended;
function FraisDeSynchro : extended;
function ParallelismeUtile : extended;
procedure EcrireMesureDeParallelismeDansRapport;
procedure EcrireFraisDeSynchronisationDansRapport;
procedure EcrireParallelismeUtileDansRapport;
procedure AfficherLesSpinlocksDuParallelisme;


// un utilitaire de debugage

procedure AttendreFrappeClavierParallelisme(attenteTouche : boolean);
function DoitDebugguerParallelismeDansRapport : boolean;


IMPLEMENTATION


USES CodeFragments,UnitServicesMemoire,UnitRapport,UnitMiniProfiler,UnitMacExtras,SNStrings,UnitScannerOthellistique,
     UnitListeCasesVidesBitboard,UnitBitboardAlphaBeta,UnitConstructionListeBitboard,UnitBitboardMobilite,OSAtomic_glue,
     UnitOth1;


      
{$pragmac  optimization_level 0}   




procedure InitUnitParallelisme;
var i : SInt32;
begin
  CassioUtiliseLeMultiprocessing              := false;
  
  gUseSpinLocks                               := true;
  gSpinLocksYieldTimeToCPU                    := false;
  gCheckingResultsHasHighPriority             := true;
  
  gParallelismeRecursif                       := false;
  gParallelismeSeulementPourLesFenetresNulles := false;
  gParallelismeSeulementPourCoupuresProbables := true;
  
          
  
  gNbreAppelsMesureDeParallelisme             := 0;
  gDegreDeParallelisme                        := 0;
  gNbreDeSplitNodes                           := 0;
  gNbreDeCoupuresBetaDansUnSplitNode          := 0;
  gFraisDeSynchronisation                     := 0;
  
  
  gNombreDeCoupuresBetaPresquesSures          := 0;
  gNombreDeCoupuresBetaReussies               := 0;
  
  gYoungBrotherWaitElders                     := 2;   // (number+1) of sons we want to have evaluated before starting parallelizing a node
  gNbreEmptiesMinimalPourParallelisme         := 15;  // on peut faire du parallelisme a ce nombre de cases vides ou plus
  gExtensionDeParallelisme                    := 2;   // on plonge en bitboard parallele à deux cases vides de plus que l'algo sequentiel
  gExtensionDeCoupureBetaProbable             := 1;   // si c'est une coupure beta probable, on plonge meme une case vide plus tot
  
  
  for i := 0 to kNombreMutexAccesBitboard-1 do
    gMutexAccesBitboardHash[i] := 0;
  
  CreateAlphaBetaTasks;
  
  
  for i := 0 to kNombreDeProfilersDuParallelisme do
    gProfilerParallelisme[i] := 0;
end;


procedure LibereMemoireUnitParallelisme;
begin
  StopAlphaBetaTasks;
end;



function MPLibraryIsLoaded : boolean;
begin
  MPLibraryIsLoaded := ( ( UInt32(_MPIsFullyInitialized) <> UInt32(kUnresolvedCFragSymbolAddress) ) 
                       & ( _MPIsFullyInitialized ) );
end;
    


procedure PosterUnResultatAUneThread(nroThreadDuPere, note, whichMove, hashStampDuPere, nbCasesVidesDuPere : SInt32);      
var err : OSErr;
begin

  with gFileDesResultats[nroThreadDuPere] do
    begin
    
    
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnDansRapport('');
          WritelnDansRapport('La thread '+NumEnString(nroThreadDuPere)+' va rentrer dans la boucle du mutex d''ecriture d''un resultat dans PosterUnResultatAUneThread');
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
    
      OS_MEMORY_BARRIER;
      
      // spin tant que l'on ne peut pas ecrire :-(
      if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(0, kValeurMutexEcritureResultat, gFileDesResultats[nroThreadDuPere].nombreDeResultats) = 0 ) then
           while (ATOMIC_COMPARE_AND_SWAP_32(0, kValeurMutexEcritureResultat, gFileDesResultats[nroThreadDuPere].nombreDeResultats) = 0 ) do;
    
      OS_MEMORY_BARRIER;
    
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnDansRapport('');
          WritelnDansRapport('La thread '+NumEnString(nroThreadDuPere)+' est sortie de sa boucle du mutex d''ecriture d''un resultat dans PosterUnResultatAUneThread');
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
      
      
    
      // on a le mutex d'ecriture dans la file des resultats du pere !
      
      valeurResultat    := note;
      coup              := whichMove;
      hashPere          := hashStampDuPere;
      profondeur        := nbCasesVidesDuPere;
      
      // on indique au pere qu'il a un resultat dans sa file
      if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kValeurMutexEcritureResultat, 1, gFileDesResultats[nroThreadDuPere].nombreDeResultats) <> 0 then;
      
      OS_MEMORY_BARRIER;
    end;
    
end;





function GetAResultForThisThreadAndLock(nroThread : SInt32; var profondeurNoeudDeParallelisme : SInt32) : boolean;
begin

  with gFileDesResultats[nroThread] do
    begin
      if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(1, kValeurMutexLectureResultat, gFileDesResultats[nroThread].nombreDeResultats) <> 0 ) then
        begin
        
          // on a le mutex de lecture dans la file des resultats !
          
          // on indique la profondeur de destination du resultat
          profondeurNoeudDeParallelisme := profondeur;
          
          GetAResultForThisThreadAndLock := true;
          
          OS_MEMORY_BARRIER;
          
          exit(GetAResultForThisThreadAndLock);
        end;
    end;
    
  GetAResultForThisThreadAndLock := false;
end;


function GetAResultAtThisDepthAndLock(nroThread, profondeurSouhaitee : SInt32) : boolean;
var profResult : SInt32;
    err : OSErr;
begin

  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnNumDansRapport('La thread '+NumEnString(nroThread)+' cherche un resultat posté pour la profondeur ',profondeurSouhaitee);
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}


  if GetAResultForThisThreadAndLock(nroThread,profResult) 
    then
      begin
      
        {$IFC AVEC_DEBUG_PARALLELISME}
        if DoitDebugguerParallelismeDansRapport then
          begin
            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
            WritelnNumDansRapport('Il y a resultat posté pour la thread '+NumEnString(nroThread)+' à la profondeur ',profResult);
            WritelnDansRapport('');
            AttendreFrappeClavierParallelisme(true);
            err := MPExitCriticalRegion(gRapportCriticalRegionID);
          end;
        {$ENDC}
      
      
        if profResult = profondeurSouhaitee
          then
            begin
              
              // il y avait bien un resultat dans la queue, et en plus a la bonne profondeur
              // on garde le mutex de lecture
              
              GetAResultAtThisDepthAndLock := true;
              
              exit(GetAResultAtThisDepthAndLock);
              
            end
          else
            begin
              // il y avait bien un resultat dans la queue, mais pas à la bonne profondeur
              // on relache le mutex de lecture tout en indiquant que le resultat reste dans la queue
              
              if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kValeurMutexLectureResultat, 1, gFileDesResultats[nroThread].nombreDeResultats) <> 0 
                then
                  begin
                  
                    GetAResultAtThisDepthAndLock := false;
                    
                    exit(GetAResultAtThisDepthAndLock);
                    
                  end
                else
                  begin
                  
                    // ASSERT : impossible de relacher le mutex dans GetAResultAtThisDepthAndLock !!! 
                    err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                    WritelnDansRapport('ASSERT : impossible de relacher le mutex dans GetAResultAtThisDepthAndLock !!! ');
                    Sysbeep(0);
                    AttendreFrappeClavierParallelisme(true);
                    err := MPExitCriticalRegion(gRapportCriticalRegionID);
                    
                  end;
              
              
            end;
      end
    else
      begin
        {$IFC AVEC_DEBUG_PARALLELISME}
        if DoitDebugguerParallelismeDansRapport then
          begin
            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
            WritelnStringDansRapport('Il n''y avait pas de resultat posté pour la thread '+NumEnString(nroThread)+'...');
            WritelnDansRapport('');
            AttendreFrappeClavierParallelisme(true);
            err := MPExitCriticalRegion(gRapportCriticalRegionID);
          end;
        {$ENDC}

      end;
    
  // il n'y avait pas de resultat dans la queue
  
  GetAResultAtThisDepthAndLock := false;
  
end;


procedure EcouterLesResultatsDansCetteThread(nroThread : SInt32);
var profondeur : SInt32;
begin
  while GetAResultForThisThreadAndLock(nroThread,profondeur) do
    begin
      GererNoeudDeParallelisme(gNoeudsDeParallelisme[nroThread,profondeur],kRECEVOIR_UN_NOUVEAU_RESULTAT);
      OS_MEMORY_BARRIER;
    end;
end;



procedure EnleverLaReservationDUneThread(var node : NoeudDeParallelisme; nroThreadALiberer : SInt32);
var err : OSErr;
begin
  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnStringDansRapport('La thread '+NumEnString(node.nroThreadDuPere)+' libere la thread '+NumEnString(nroThreadALiberer)+' de son spin-lock de reservation ou de son spin-lock d''attente');
      WritelnDansRapport('');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}

    
  gAlphaBetaTasksData^[nroThreadALiberer].message   := kPleaseGoSleeping;
  
  
  
  
  if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseDoSpinLock,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadALiberer].etat) = 0) &
     (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseWaitForJobPreparation, kPleaseGoSleeping, gAlphaBetaTasksData^[nroThreadALiberer].etat) = 0) then
    begin
      {$IFC USE_ASSERTIONS_DE_PARALLELISME}
      // ASSERT : la thread n'a pas reussi à liberer son fils de son spin-lock
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnDansRapport('ASSERT : impossible d''enlever la reservation de la thread '+NumEnString(nroThreadALiberer)+' !!! ');
      WritelnNumDansRapport('         car son état est : ',gAlphaBetaTasksData^[nroThreadALiberer].etat);
      WritelnDansRapport('');
      Sysbeep(0);
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
      {$ENDC}
    end;
  
  OS_MEMORY_BARRIER;

end;


procedure InterrompreUnFils(var node : NoeudDeParallelisme; nroThreadAInterrompre : SInt32);
var microSecondesFin : UnsignedWide;
    microSecondesDepart : UnsignedWide;
    err : OSErr;
begin

  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnNumDansRapport('La thread '+NumEnString(node.nroThreadDuPere)+' va interrompre son fils '+NumEnString(nroThreadAInterrompre)+' à la profondeur ',node.nbreVides - 1);
      WritelnDansRapport('');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}


  MicroSeconds(microSecondesDepart);
    
  gAlphaBetaTasksData^[nroThreadAInterrompre].message   := kPleaseGoSleeping;
  
  OS_MEMORY_BARRIER;
  
  
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseExploreThisSubtree,kPleaseExploreThisSubtree,gAlphaBetaTasksData^[nroThreadAInterrompre].etat) <> 0 then
    begin
      InterrompreUneThread(nroThreadAInterrompre, node.nbreVides - 1,kPleaseExploreThisSubtree);
    end;
  
  OS_MEMORY_BARRIER;
  
  
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseWaitForJobPreparation,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadAInterrompre].etat) = 0 then
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseExploreThisSubtree,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadAInterrompre].etat) = 0 then
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseDoSpinLock,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadAInterrompre].etat) = 0 then
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseExploreThisSubtree,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadAInterrompre].etat) = 0 then;
  
  OS_MEMORY_BARRIER;
  
  
  MicroSeconds(microSecondesFin);
  gProfilerParallelisme[0] := gProfilerParallelisme[0] + (microSecondesFin.lo-microSecondesDepart.lo);
end;
  
  
function ThreadEstInterrompue(nroThread, nbreCasesVides : SInt32) : boolean;
begin
  ThreadEstInterrompue := (gAlphaBetaInterrompu[nroThread] >= nbreCasesVides); 
end;


procedure InterrompreUneThread(nroThread, nbreCasesVides : SInt32; siElleEstDansCetEtat : SInt32);
var err : OSErr;
begin


  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnDansRapport('La thread '+NumEnString(nroThread)+' va rentrer dans la boucle du mutex d''interruption d''une thread dans InterrompreUneThread');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  OS_MEMORY_BARRIER;
  
  // Attendre de pouvoir prendre le mutex d'ecriture d'une interruption pour cette thread
  if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(0,1,gMutexEcritureInterruptionThread[nroThread]) = 0 ) then
       while (ATOMIC_COMPARE_AND_SWAP_32(0,1,gMutexEcritureInterruptionThread[nroThread]) = 0 ) do;
  
  OS_MEMORY_BARRIER;
  
  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnDansRapport('La thread '+NumEnString(nroThread)+' est sortie de sa boucle du mutex d''interruption d''une thread dans InterrompreUneThread');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  
  // On a le mutex  : faire notre magie d'interruption !
  
  if (siElleEstDansCetEtat = kAnyState)
    then
      begin
      
        // on interrompt la thread inconditionnnelement
        if (gAlphaBetaInterrompu[nroThread] < nbreCasesVides) 
          then gAlphaBetaInterrompu[nroThread] := nbreCasesVides; 
      end
    else
      begin
      
        // on n'imterrompt la thread que si elle est exactement dans l'etat "siElleEstDansCetEtat"
        if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(siElleEstDansCetEtat,siElleEstDansCetEtat,gAlphaBetaTasksData^[nroThread].etat) <> 0
          then
            begin
              if (gAlphaBetaInterrompu[nroThread] < nbreCasesVides) 
                then gAlphaBetaInterrompu[nroThread] := nbreCasesVides; 
            end;
      end;
        
  // Relacher le mutex
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(1,0,gMutexEcritureInterruptionThread[nroThread]) = 0 then;
  
  
  OS_MEMORY_BARRIER;
end;


procedure EnleverLInterruptionPourCetteThread(nroThread, nbreCasesVides : SInt32);
var err : OSErr;
begin

  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnDansRapport('La thread '+NumEnString(nroThread)+' va rentrer dans la boucle du mutex d''interruption d''une thread dans EnleverLInterruptionPourCetteThread');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  OS_MEMORY_BARRIER;
    
  // Attendre de pouvoir prendre le mutex d'ecriture d'une interruption pour cette thread
  if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(0,1,gMutexEcritureInterruptionThread[nroThread]) = 0 ) then
       while (ATOMIC_COMPARE_AND_SWAP_32(0,1,gMutexEcritureInterruptionThread[nroThread]) = 0 ) do;
  
  OS_MEMORY_BARRIER;
  
  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnDansRapport('La thread '+NumEnString(nroThread)+' est sortie de sa boucle du mutex d''interruption d''une thread dans EnleverLInterruptionPourCetteThread');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  // On a le mutex  : faire notre magie d'interruption !
  
  if (gAlphaBetaInterrompu[nroThread] <= nbreCasesVides) 
    then gAlphaBetaInterrompu[nroThread] := kPasDInterrumptionPourCetteThread; 
    
  // Relacher le mutex
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(1,0,gMutexEcritureInterruptionThread[nroThread]) = 0 then;
  
  
  OS_MEMORY_BARRIER;
  
end;

  
procedure LancerUnFils(nroThreadDuFils : SInt32);
var err : OSStatus;
    microSecondesFin : UnsignedWide;
    microSecondesDepart : UnsignedWide;
begin

  MicroSeconds(microSecondesDepart);

  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseDoSpinLock,kPleaseExploreThisSubtree,gAlphaBetaTasksData^[nroThreadDuFils].etat) <> 0 then
    begin
    
      MicroSeconds(microSecondesFin);
      gProfilerParallelisme[12] := gProfilerParallelisme[12] + (microSecondesFin.lo-microSecondesDepart.lo);
    
      // c'est bon, on vient de sortir le fils de son spin lock
      exit(LancerUnFils);
    end;
      
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseWaitForJobPreparation,kPleaseExploreThisSubtree,gAlphaBetaTasksData^[nroThreadDuFils].etat) <> 0 then
    begin
      // c'est bon, on peut lever le semaphore du fils
      
      
      MicroSeconds(microSecondesFin);
      gProfilerParallelisme[13] := gProfilerParallelisme[13] + (microSecondesFin.lo-microSecondesDepart.lo);
  
      exit(LancerUnFils);
    end;
  
  
  // ASSERT : état inconnu dans LancerUnFils...
  {$IFC USE_ASSERTIONS_DE_PARALLELISME}
  err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
  WritelnNumDansRapport('ASSERT : état inconnu dans LancerUnFils... !!  gAlphaBetaTasksData^['+NumEnString(nroThreadDuFils)+'].etat = ',gAlphaBetaTasksData^[nroThreadDuFils].etat);
  Sysbeep(0);
  AttendreFrappeClavierParallelisme(true);
  err := MPExitCriticalRegion(gRapportCriticalRegionID);
  {$ENDC}

end;





function CalculerCoupsEnParallele(inNroThreadDuPere                            : SInt32; 
                                  inNroThreadFilsDisponible                    : SInt32; 
                                  inPosition                                   : bitboard; 
                                  inNbreVides                                  : SInt32; 
                                  inAlpha,inBeta                               : SInt32; 
                                  inDiffPions                                  : SInt32; 
                                  inVecteurParite                              : SInt32; 
                                  inListeBitboard                              : UInt32;
                                  var inListeDesCoupsLegaux                    : listeVides; 
                                  indexPremierFils,indexDernierFils            : SInt32; 
                                  var outMeilleureDefense                      : UInt32; 
                                  var outNroDuDernierFilsEvalue                : SInt32)     : SInt32;
var microSecondesDepart : UnsignedWide;
    microSecondesFin : UnsignedWide;
    i : SInt32;
    foo_bar_atomic_register : SInt32;
    err : OSErr;
begin

  EcouterLesResultatsDansCetteThread(inNroThreadDuPere);

  MicroSeconds(microSecondesDepart);
 
  
  with gNoeudsDeParallelisme[inNroThreadDuPere, inNbreVides] do
    begin
    
      ATOMIC_INCREMENT_32(gNbreDeSplitNodes);
   

      // Initialisation des variables
  
      nroThreadDuPere     := inNroThreadDuPere;
      nbreVides           := inNbreVides;
      alpha               := inAlpha;
      beta                := inBeta;
      diffPions           := inDiffPions;
      vecteurParite       := inVecteurParite;
      listeBitboard       := inListeBitboard;
      filsDebut           := indexPremierFils;
      filsFin             := indexDernierFils;
      listeDesCoupsLegaux := inListeDesCoupsLegaux;
      betaCoupureTrouvee  := false;
      
      with inPosition do
        begin
          pos_my_bits_low   := g_my_bits_low;
          pos_my_bits_high  := g_my_bits_high;
          pos_opp_bits_low  := g_opp_bits_low;
          pos_opp_bits_high := g_opp_bits_high;
        end;
  
      maximum := -100000;
      nbreResultatsEnAttente := 0;
  
      
      
      // On calcule une clef hash de la position pour valider les communications inter-process
      hashStamp := (pos_my_bits_low * pos_opp_bits_high) + (pos_my_bits_high + pos_opp_bits_low);
      (* WritelnNumDansRapport('Parallele : ',hashStamp); *)
  
  
     // Pour l'instant aucune thread ne travaille pour nous
     for i := filsDebut to filsFin do
       begin
         threadAffecteeACeFils[i] := -500;
         filsEnAttenteDeLancement[i] := false;
       end;


     MicroSeconds(microSecondesFin);
     gProfilerParallelisme[3] := gProfilerParallelisme[3] + (microSecondesFin.lo-microSecondesDepart.lo);
     
     
     
     
     // Commencer à repartir le travail des fils
        
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnDansRapport('');
          WritelnDansRapport('/////////////////////////////////////////////////////////////////////////////////');
          WritelnDansRapport('');
          EcritBitboardState('Entree dans CalculerCoupsEnParallele (nroThreadDuPere, nroThreadFilsDispo) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(inNroThreadFilsDisponible)+') :',MakeBitboard(pos_my_bits_low,pos_my_bits_high,pos_opp_bits_low,pos_opp_bits_high),nbreVides,alpha,beta,diffPions);
          WritelnNumDansRapport('vecteurParite = ',vecteurParite);
          WriteDansRapport('Liste des fils a étudier : ');
          for i := filsDebut to filsFin do
            WriteStringAndCoupDansRapport(' ',listeDesCoupsLegaux[i]);
          WritelnDansRapport('');
          WritelnNumDansRapport('diffPions recu = ',diffPions);
          WritelnNumDansRapport('diffPions calculé = ',BitboardToDiffPions(pos_my_bits_low,pos_my_bits_high,pos_opp_bits_low,pos_opp_bits_high));
          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
          WritelnDansRapport('Etat des interruptions : ');
          for i := 0 to kNombreMaxAlphaBetaTasks do
             WritelnNumDansRapport('        gAlphaBetaInterrompu['+NumEnString(i)+'] = ',gAlphaBetaInterrompu[i]);
          WritelnDansRapport('');
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
      
    
     // preparer le premier fils
     
     nroDuFilsCourant := filsDebut - 1;
     
     PreparerUnTravailPourLaThreadAuChomage(gNoeudsDeParallelisme[nroThreadDuPere, inNbreVides], inNroThreadFilsDisponible);
     
     
     // c'est parti !!
     
     GererNoeudDeParallelisme(gNoeudsDeParallelisme[nroThreadDuPere, inNbreVides], kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE);
     
     OS_MEMORY_BARRIER;
     
     // renvoyer les resultats
     
     outMeilleureDefense         := bestDef;
     outNroDuDernierFilsEvalue   := nroDuDernierFilsEvalue;
     
     CalculerCoupsEnParallele    := maximum;
     
     
     
     
     // ASSERT : verification de la cohérence des resultats
     
     
     {$IFC USE_ASSERTIONS_DE_PARALLELISME }
     if (maximum < -64) | (maximum > 64) then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('ASSERT : (maximum < -64) | (maximum > 64) à la sortie de CalculerCoupsEnParallele !!   maximum = ',maximum);
          Sysbeep(0);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
     {$ENDC}
     
     {$IFC USE_ASSERTIONS_DE_PARALLELISME }
     if (outNroDuDernierFilsEvalue < indexPremierFils) | (outNroDuDernierFilsEvalue > indexDernierFils) then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('ASSERT : (outNroDuDernierFilsEvalue < indexPremierFils) | (outNroDuDernierFilsEvalue > indexDernierFils) à la sortie de CalculerCoupsEnParallele !!   outNroDuDernierFilsEvalue = ',outNroDuDernierFilsEvalue);
          Sysbeep(0);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
     {$ENDC}
     
     {$IFC USE_ASSERTIONS_DE_PARALLELISME }
     if (bestDef < 11) | (bestDef > 88) then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('ASSERT : (bestDef < 11) | (bestDef > 88) à la sortie de CalculerCoupsEnParallele !!   bestDef = ',bestDef);
          Sysbeep(0);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
     {$ENDC}
     
     
     {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnDansRapport('');
          EcritBitboardState('Sortie de CalculerCoupsEnParallele (nroThreadDuPere, nroThreadFilsDispo) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(inNroThreadFilsDisponible)+') :',MakeBitboard(pos_my_bits_low,pos_my_bits_high,pos_opp_bits_low,pos_opp_bits_high),nbreVides,alpha,beta,diffPions);
          WritelnDansRapport('  -> resultat à la prof '+NumEnString(inNbreVides)+' : (bestDef,dernierFilsEvalue,max) = ('+CoupEnString(bestDef,true)+','+NumEnString(nroDuDernierFilsEvalue)+','+NumEnString(maximum)+')');
          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
          WritelnNumDansRapport('gNbreThreadsDisponibles = ',NbreDeThreadsDisponibles);
          WritelnDansRapport('Etat des interruptions : ');
          for i := 0 to kNombreMaxAlphaBetaTasks do
             WritelnNumDansRapport('        gAlphaBetaInterrompu['+NumEnString(i)+'] = ',gAlphaBetaInterrompu[i]);
          WritelnDansRapport('');
          WritelnDansRapport('----------------------------------------------------------------------------');
          WritelnDansRapport('');
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
     
    end;
end;


function InterruptionDansCeNoeudDeParallelisme(var node : NoeudDeParallelisme) : boolean;
 var k : SInt32;
     foo_bar_atomic_register : SInt32;
     microSecondesFin : UnsignedWide;
     microSecondesDepart : UnsignedWide;
     err : OSErr;
 begin
 
   with node do
     begin
 
       if ThreadEstInterrompue(nroThreadDuPere, nbreVides) then
          begin
            
            MicroSeconds(microSecondesDepart);
            
            // ASSERT : verification que l'on n'a aucun fils réservé mais non lancé
            {$IFC USE_ASSERTIONS_DE_PARALLELISME }
            for k := filsDebut to filsFin do
              if filsEnAttenteDeLancement[k] then 
                begin
                  err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                  WritelnDansRapport('ASSERT : j''ai un fils réservé au moment d''une InterruptionDansCeNoeudDeParallelisme (peut-etre un probleme de coupure beta ?) !! ');
                  Sysbeep(0);
                  AttendreFrappeClavierParallelisme(true);
                  err := MPExitCriticalRegion(gRapportCriticalRegionID);
                end;
            {$ENDC}
          
            // Interrompre tous les fils precedents encore en activite
            
            for k := filsDebut to filsFin do
              if (threadAffecteeACeFils[k] >= 0) &
                 (gAlphaBetaTasksData^[threadAffecteeACeFils[k]].threadDuPere = nroThreadDuPere) then 
                begin
                
                  // on indique que ce ne sera pas la peine d'essayer de lancer ce fils, s'il était en instance de lancement
                  filsEnAttenteDeLancement[k] := false;
                
                  // bye bye, cow-boy
                  InterrompreUnFils(node,threadAffecteeACeFils[k]);
                  
                  // Le fils interrompu va liberer son processeur
                  ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
                  
                  
                  {$IFC AVEC_DEBUG_PARALLELISME}
                  if DoitDebugguerParallelismeDansRapport then
                    begin
                      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                      WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' va etre interrompue et interrompt un fils, je decremente gNbreProcesseursCalculant : ',gNbreProcesseursCalculant);
                      WritelnDansRapport('');
                      AttendreFrappeClavierParallelisme(true);
                      err := MPExitCriticalRegion(gRapportCriticalRegionID);
                    end;
                  {$ENDC}
                  
                  
                  
                  
                  {$IFC AVEC_DEBUG_PARALLELISME}
                  if DoitDebugguerParallelismeDansRapport then
                    begin
                      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                      WritelnDansRapport('La thread '+NumEnString(nroThreadDuPere)+' va etre interrompue et essaye d''interrompre son fils numero '+NumEnString(threadAffecteeACeFils[k])+ ' avant de sortir lui-meme');
                      WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                      WritelnDansRapport('');
                      AttendreFrappeClavierParallelisme(true);
                      err := MPExitCriticalRegion(gRapportCriticalRegionID);
                    end;
                  {$ENDC}
            
            
                end;
            
            // Sortir immediatement de la fonction en renvoyant une valeur speciale
            
            nroDuDernierFilsEvalue := -1;
            maximum := kValeurSpecialeInterruptionCalculParallele;
            
            
            {$IFC AVEC_DEBUG_PARALLELISME}
            if DoitDebugguerParallelismeDansRapport then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' est interrompue et sort de InterruptionDansCeNoeudDeParallelisme en renvoyant kValeurSpecialeInterruptionCalculParallele : ',kValeurSpecialeInterruptionCalculParallele);
                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                WritelnDansRapport('');
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
            
            MicroSeconds(microSecondesFin);
            
            gProfilerParallelisme[1] := gProfilerParallelisme[1] + (microSecondesFin.lo-microSecondesDepart.lo);
            
            
            InterruptionDansCeNoeudDeParallelisme := true;
            
            
            OS_MEMORY_BARRIER;
          end;
         
     end;
   
   InterruptionDansCeNoeudDeParallelisme := false;
 end;



procedure PreparerUnTravailPourLaThreadAuChomage(var node: NoeudDeParallelisme; nroThreadFilsAuChomage : SInt32);
var diffEssai : SInt32;
    iCourant : SInt32;
    nouvelleParite : SInt32;
    positionFils : bitboard;
    microSecondesFin : UnsignedWide;
    microSecondesDepart : UnsignedWide;
    err : OSErr;
begin
 
  with node do
    begin
 
      MicroSeconds(microSecondesDepart);
          
   
      // ASSERT : verification que le numero de la thread qui prétend être disponible n'est pas débile
      {$IFC USE_ASSERTIONS_DE_PARALLELISME}
      if ( nroThreadFilsAuChomage < 0 ) | ( nroThreadFilsAuChomage > kNombreMaxAlphaBetaTasks ) then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('ASSERT : ( nroThreadFilsAuChomage < 0 ) | ( nroThreadFilsAuChomage > kNombreMaxAlphaBetaTasks ) dans PreparerUnTravailPourLaThreadAuChomage !!  nroThreadFilsAuChomage = ',nroThreadFilsAuChomage);
          Sysbeep(0);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
    
   
      
      // ASSERT : verification que la thread disponible est dans l'un des deux etats "kPleaseWaitForJobPreparation" ou "kPleaseDoSpinLock"
      {$IFC USE_ASSERTIONS_DE_PARALLELISME}
      if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseWaitForJobPreparation,kPleaseWaitForJobPreparation,gAlphaBetaTasksData^[nroThreadFilsAuChomage].etat) = 0) &
         (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseDoSpinLock,kPleaseDoSpinLock,gAlphaBetaTasksData^[nroThreadFilsAuChomage].etat) = 0) then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('ASSERT : la thread au chomage n''est pas dans un état valable dans PreparerUnTravailPourLaThreadAuChomage !!  nroThreadFilsAuChomage = ',nroThreadFilsAuChomage);
          WritelnNumDansRapport('        en effet, son état vaut : ',gAlphaBetaTasksData^[nroThreadFilsAuChomage].etat);
          Sysbeep(0);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
      

      inc(nroDuFilsCourant);
      
      // Jouer le coup
      
      iCourant := listeDesCoupsLegaux[nroDuFilsCourant];
      diffEssai := diffPions;
      nouvelleParite := ModifPlatBitboard(iCourant,vecteurParite,pos_my_bits_low,pos_my_bits_high,pos_opp_bits_low,pos_opp_bits_high,positionFils,diffEssai);
      
      
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WriteStringAndCoupDansRapport('La thread '+NumEnString(nroThreadDuPere)+' vient de preparer un coup legal : ',iCourant);
          WritelnNumDansRapport(' qui sera sans doute affecté à la thread ',nroThreadFilsAuChomage);
          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
          WritelnDansRapport('');
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
            
      
      // On garde la trace que l'on va lancer telle thread sur tel fils,
      // pour pouvoir interrompre eventuellement les fils
      
      threadAffecteeACeFils[nroDuFilsCourant]    := nroThreadFilsAuChomage;
      filsEnAttenteDeLancement[nroDuFilsCourant] := true;
      
      // Fabriquer les donnees pour la thread qui accepte de travailler pour nous
      
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].positionSubTree        := positionFils;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].profondeurSubTree      := nbreVides - 1;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].alphaSubTree           := -beta;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].betaSubTree            := -alpha;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].diffPionsSubTree       := -diffEssai;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].vecteurPariteSubTree   := nouvelleParite;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].listeBitboardSubTree   := REMOVE_CASE_VIDE_FROM_LISTE(listeBitboard,iCourant);
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].coupSubTree            := iCourant;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].hashDuPere             := hashStamp;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].message                := kPleaseExploreThisSubtree;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].nroThread              := nroThreadFilsAuChomage;
      gAlphaBetaTasksData^[nroThreadFilsAuChomage].threadDuPere           := nroThreadDuPere;
      
      
      
      MicroSeconds(microSecondesFin);
          
      gProfilerParallelisme[2] := gProfilerParallelisme[2] + (microSecondesFin.lo-microSecondesDepart.lo);

   end;
   
end;


function MeLancerMoiMemeRecursivementSurUnFils(var node : NoeudDeParallelisme; var coupDuFils : SInt32) : SInt32;
var valeur : SInt32;
    diffEssai : SInt32;
    nouvelleParite : SInt32;
    positionFils : bitboard;
    err : OSErr;
begin
  with node do
    begin
      inc(nroDuFilsCourant);
      
      
      // Jouer le coup
      
      coupDuFils := listeDesCoupsLegaux[nroDuFilsCourant];
      diffEssai  := diffPions;
      nouvelleParite := ModifPlatBitboard(coupDuFils,vecteurParite,pos_my_bits_low,pos_my_bits_high,pos_opp_bits_low,pos_opp_bits_high,positionFils,diffEssai);
      
      
      threadAffecteeACeFils[nroDuFilsCourant]    := nroThreadDuPere;  // puisque l'on va prendre soi-meme en charge ce fils
      
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' s''appelle recursivement sur le coup '+CoupEnString(coupDuFils,true)+' pour participer au travail, pouf pouf...  hashStamp = ',hashStamp);
          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
      
      // on enleve les interruptions avant de plonger
      EnleverLInterruptionPourCetteThread(nroThreadDuPere, nbreVides - 1);
      
      valeur := MySubTreeValue( positionFils, nbreVides - 1, -beta, -alpha, -diffEssai, nouvelleParite, nroThreadDuPere, nroThreadDuPere, REMOVE_CASE_VIDE_FROM_LISTE(listeBitboard,coupDuFils));
      
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('Sortie de MeLancerMoiMemeRecursivementSurUnFils pour la thread '+NumEnString(nroThreadDuPere)+' avec la valeur = ',-valeur);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
      
      // Une eventuelle interruption de notre thread ayant fait son office dans le sous arbre, on peut 
      // desormais enlever les interruptions de ce meme sous-arbre
      EnleverLInterruptionPourCetteThread(nroThreadDuPere, nbreVides - 1);
      
      
      MeLancerMoiMemeRecursivementSurUnFils := valeur;
    end;
end;



function FaireQuelqueChoseDIntelligentAvecLaThreadDuFils(var node : NoeudDeParallelisme; nroThreadDuFils : SInt32; var nroThreadFilsDisponible : SInt32) : SInt32;
var foo_bar_atomic_register : SInt32;
    err : OSErr;
    microSecondesFin : UnsignedWide;
    microSecondesDepart : UnsignedWide;
    etatDuFils : SInt32;
begin

  with node do
    begin
    
      MicroSeconds(microSecondesDepart);
      
      if ThreadEstInterrompue(nroThreadDuPere,nbreVides) 
        then
          begin
            InterrompreUnFils(node,nroThreadDuFils);
            
            // le fils dont on vient de recevoir le resultat ne nous servira plus
            ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
            
            
            {$IFC AVEC_DEBUG_PARALLELISME}
            if DoitDebugguerParallelismeDansRapport then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' est inetrrompue et vient d''interrompre sa thread fille = ',nroThreadDuFils);
                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                WritelnDansRapport('');
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
          end
          
          
        else
      if (nroDuFilsCourant >= filsFin) 
        then 
          begin
            EnleverLaReservationDUneThread(node,nroThreadDuFils);
            
            // on a fini de lancer tous les fils, donc le fils dont on vient de recevoir le resultat ne nous servira plus
            ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
            
            
            {$IFC AVEC_DEBUG_PARALLELISME}
            if DoitDebugguerParallelismeDansRapport then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' a lancé tous les fils possibles et vient d''enlever le spin-lock de sa thread fille = ',nroThreadDuFils);
                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                WritelnDansRapport('');
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
          end
          
          
        else 
          begin
            // on va sans doute reutiliser immediatement la thread du fils dont on vient de recevoir le resultat
            
            if (gNbreProcesseursCalculant <= numProcessors)
              then
                begin
                
                
                  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseDoSpinLock,kPleaseDoSpinLock,gAlphaBetaTasksData^[nroThreadDuFils].etat) <> 0
                    then
                      begin
                        
                        {$IFC AVEC_DEBUG_PARALLELISME}
                        if DoitDebugguerParallelismeDansRapport then
                          begin
                            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                            WritelnStringDansRapport('La thread '+NumEnString(nroThreadDuPere)+' a encore des fils à lancer,');
                            WritelnNumDansRapport('mais peut recycler sa thread fille qui attend en spin-lock :-)  nroThreadDuFils = ',nroThreadDuFils);
                            WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                            WritelnDansRapport('');
                            err := MPExitCriticalRegion(gRapportCriticalRegionID);
                          end;
                        {$ENDC}
                  
                        PreparerUnTravailPourLaThreadAuChomage(node,nroThreadDuFils);
                        
                        if gCheckingResultsHasHighPriority then
                          begin
                              
                            // Ecouter eventuellement d'autres resultats
                            if (nbreResultatsEnAttente > 0) then
                              begin
                              
                                if GetAResultAtThisDepthAndLock(nroThreadDuPere,nbreVides) 
                                  then
                                    begin
                                      MicroSeconds(microSecondesFin);
                                      gProfilerParallelisme[7] := gProfilerParallelisme[7] + (microSecondesFin.lo-microSecondesDepart.lo);

                                      FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kRECEVOIR_UN_NOUVEAU_RESULTAT;
                                      exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                                    end; 
                              
                              end;
                          end;
                  
                        MicroSeconds(microSecondesFin);
                        gProfilerParallelisme[8] := gProfilerParallelisme[8] + (microSecondesFin.lo-microSecondesDepart.lo);
                  
                        FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kTROUVER_D_AUTRES_TACHES_AU_CHOMAGE;
                        exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                      end
                    else
                    
                  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseGoSleeping,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadDuFils].etat) = 0
                    then
                      begin
                      
                        etatDuFils := gAlphaBetaTasksData^[nroThreadDuFils].etat;
                      
                        InterrompreUnFils(node,nroThreadDuFils);
                      
                        if PeutTrouverUneThreadDisponible(nroThreadDuPere,nroThreadFilsDisponible) then
                          begin
                            ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
                            
                            
                            {$IFC USE_ASSERTIONS_DE_PARALLELISME}
                            if gUseSpinLocks then
                              begin
                                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                                WritelnStringDansRapport('ASSERT !! La thread '+NumEnString(nroThreadDuPere)+' a encore des fils à lancer,');
                                WriteDansRapport('mais n''a pas pu reutiliser son ancienne thread fille, qui n''était pas en spin-lock !!!!');
                                WritelnDansRapport('(nroThreadDuFils,etat) = ('+NumEnString(nroThreadDuFils)+','+NumEnString(etatDuFils)+')');
                                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                                WritelnDansRapport('');
                                AttendreFrappeClavierParallelisme(true);
                                err := MPExitCriticalRegion(gRapportCriticalRegionID);
                              end;
                            {$ENDC}
                  
                            PreparerUnTravailPourLaThreadAuChomage(node,nroThreadFilsDisponible);
                            
                            if gCheckingResultsHasHighPriority then
                              begin
                                  
                                // Ecouter eventuellement d'autres resultats
                                if (nbreResultatsEnAttente > 0) then
                                  begin
                                    if GetAResultAtThisDepthAndLock(nroThreadDuPere,nbreVides) 
                                      then
                                        begin
                                          MicroSeconds(microSecondesFin);
                                          gProfilerParallelisme[9] := gProfilerParallelisme[9] + (microSecondesFin.lo-microSecondesDepart.lo);

                                          FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kRECEVOIR_UN_NOUVEAU_RESULTAT;
                                          exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                                        end; 
                                  end;
                              end;
                              
                            MicroSeconds(microSecondesFin);
                            gProfilerParallelisme[10] := gProfilerParallelisme[10] + (microSecondesFin.lo-microSecondesDepart.lo);
                  
                            FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kTROUVER_D_AUTRES_TACHES_AU_CHOMAGE;
                            exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                          end;
                      end;
                end
              else
                begin
                  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseGoSleeping,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadDuFils].etat) = 0 then
                    begin
                      InterrompreUnFils(node,nroThreadDuFils);
                      
                      ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
                      
                      
                      {$IFC AVEC_DEBUG_PARALLELISME}
                      if DoitDebugguerParallelismeDansRapport then
                        begin
                          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                          WritelnStringDansRapport('La thread '+NumEnString(nroThreadDuPere)+' a encore des fils à lancer,');
                          WritelnNumDansRapport('mais n''a pas trouvé de processeur disponible et vient d''interrompre brutalement sa thread fille = ',nroThreadDuFils);
                          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                          WritelnDansRapport('');
                          err := MPExitCriticalRegion(gRapportCriticalRegionID);
                        end;
                      {$ENDC}
                
                    end;
                end;
        end;
        
    end;  {with node do}
    
    FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kCONTINUER_NORMALEMENT;
end;





function PeutTrouverUneThreadEsclave(var node : NoeudDeParallelisme; action : SInt32; var nroThreadFilsAuChomage : SInt32) : boolean;
begin
  
  with node do
    begin
    
      OS_MEMORY_BARRIER;
    
      if (action = kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE)
        then
          begin
          
            // Quand la procedure GererNoeudDeParallelisme est appelée avec l'action "kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE",
            // elle peut prendre en charge elle-meme, recursivement, le dernier fils à evaluer, ce qui explique le test
            // (nroDuFilsCourant < filsFin - 1)  ci-dessous : on ne cherche une thread esclave que pour les n-1 premiers fils...
            
            if (nroDuFilsCourant < filsFin - 1) & not(betaCoupureTrouvee) & not(ThreadEstInterrompue(nroThreadDuPere, nbreVides)) &
               (gNbreProcesseursCalculant < numProcessors) & PeutTrouverUneThreadDisponible(nroThreadDuPere,nroThreadFilsAuChomage) then
              begin
                PeutTrouverUneThreadEsclave := true;
                exit(PeutTrouverUneThreadEsclave);
              end;
              
          end
        else
          begin
          
            // Chercher une thread esclave...
          
            if (nroDuFilsCourant < filsFin) & not(betaCoupureTrouvee)  & not(ThreadEstInterrompue(nroThreadDuPere, nbreVides)) &
               (gNbreProcesseursCalculant < numProcessors) & PeutTrouverUneThreadDisponible(nroThreadDuPere,nroThreadFilsAuChomage) then
              begin
                PeutTrouverUneThreadEsclave := true;
                exit(PeutTrouverUneThreadEsclave);
              end;

          end;
       
       
      PeutTrouverUneThreadEsclave := false;
    
    end;
  
end;


procedure AttendreDesResultatsEnProposantSesServices(var node : NoeudDeParallelisme);
var profondeurDuNouveauResultat : SInt32;
begin

  // FIXME : pour l'instant, cette procedure ne fait pas de proposition de service a ses fils
  // FIXME !!
  
  with node do
    if GetAResultForThisThreadAndLock(nroThreadDuPere,profondeurDuNouveauResultat) then
      begin
        GererNoeudDeParallelisme(gNoeudsDeParallelisme[nroThreadDuPere,profondeurDuNouveauResultat],kRECEVOIR_UN_NOUVEAU_RESULTAT);
      end;
end;





procedure GererNoeudDeParallelisme(var node : NoeudDeParallelisme; action : SInt32);
var i : SInt32;
    valeur : SInt32;
    nroThreadDuFils : SInt32;
    nroThreadFilsDisponible : SInt32;
    actionSuivante : SInt32;
    err : OSErr;
    resultatDuFils : SInt32;
    coupDuFils : SInt32;
    resultStamp : SInt32;
    onVientDeRecevoirUnVraiResultat : boolean;
    foo_bar_atomic_register : SInt32;
    microSecondesFin : UnsignedWide;
    microSecondesDepart : UnsignedWide;
    
label ON_VIENT_DE_TROUVER_UNE_TACHE_AU_CHOMAGE;
label ESSAYER_DE_TROUVER_D_AUTRES_TACHES_AU_CHOMAGE;
label LANCER_LES_NOUVEAUX_FILS;
label ATTENDRE_LES_RESULTATS;
label RECEVOIR_UN_NOUVEAU_RESULTAT;
label ON_VIENT_DE_TROUVER_UN_RESULTAT_A_ANALYSER;
label APRES_L_ANALYSE_D_UN_RESULTAT;


begin

  with node do
    begin
    
    
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('Entree dans GererNoeudDeParallelisme pour la thread '+NumEnString(nroThreadDuPere)+' avec l''action : ',action);
          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
    
      case action of
      
        kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE       : goto ESSAYER_DE_TROUVER_D_AUTRES_TACHES_AU_CHOMAGE;
        
        kRECEVOIR_UN_NOUVEAU_RESULTAT                 : goto RECEVOIR_UN_NOUVEAU_RESULTAT;
        
        kANALYSER_UN_RESULTAT                         : goto ON_VIENT_DE_TROUVER_UN_RESULTAT_A_ANALYSER;
        
        otherwise                              
          begin
            // ASSERT : action non geree dans GererNoeudDeParallelisme
            {$IFC USE_ASSERTIONS_DE_PARALLELISME}
            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
            WritelnNumDansRapport('ASSERT : action non geree à l''entree de  GererNoeudDeParallelisme !!  action = ',action);
            Sysbeep(0);
            AttendreFrappeClavierParallelisme(true);
            err := MPExitCriticalRegion(gRapportCriticalRegionID);
            {$ENDC}
          end;  
                               
      end; {case}
  
  
  RECEVOIR_UN_NOUVEAU_RESULTAT :
  
    begin
    
      OS_MEMORY_BARRIER;
    
      with gFileDesResultats[nroThreadDuPere] do
        begin
        
          resultatDuFils         := valeurResultat;
          coupDuFils             := coup;
          resultStamp            := hashPere;
          
          // Vider la file de resultats tout en enlevant le mutex
          // de maniere qu'un autre noeud puisse y ecrire
          
          if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kValeurMutexLectureResultat, 0, gFileDesResultats[nroThreadDuPere].nombreDeResultats) <> 0 
            then
              begin
                // et on va analyser ce resultat
                goto ON_VIENT_DE_TROUVER_UN_RESULTAT_A_ANALYSER;
              end
            else
              begin
              
                // ASSERT : impossible de remettre le mutex dans RECEVOIR_UN_NOUVEAU_RESULTAT
                {$IFC USE_ASSERTIONS_DE_PARALLELISME}
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnStringDansRapport('ASSERT : impossible de remettre le mutex dans RECEVOIR_UN_NOUVEAU_RESULTAT');
                Sysbeep(0);
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
                {$ENDC}
          
              end;
          
        end;
    end;
        
        
  ON_VIENT_DE_TROUVER_UNE_TACHE_AU_CHOMAGE : 
  
      // ASSERT : verification que le numero de la thread qui prétend être disponible en entree n'est pas débile
      {$IFC USE_ASSERTIONS_DE_PARALLELISME}
      if ( nroThreadFilsDisponible < 0 ) | ( nroThreadFilsDisponible > kNombreMaxAlphaBetaTasks ) then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('ASSERT : ( nroThreadFilsDisponible < 0 ) | ( nroThreadFilsDisponible > kNombreMaxAlphaBetaTasks ) à l''entree de  GererNoeudDeParallelisme !!  nroThreadFilsDisponible = ',nroThreadFilsDisponible);
          Sysbeep(0);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}


      PreparerUnTravailPourLaThreadAuChomage(node,nroThreadFilsDisponible);
      
      
  ESSAYER_DE_TROUVER_D_AUTRES_TACHES_AU_CHOMAGE : 
      
      // Tant que l'on a des threads disponibles, on essaye de lancer des autres fils
      
      if PeutTrouverUneThreadEsclave(node, action, nroThreadFilsDisponible) then
        goto ON_VIENT_DE_TROUVER_UNE_TACHE_AU_CHOMAGE;
        

  LANCER_LES_NOUVEAUX_FILS :


      MicroSeconds(microSecondesDepart);
      
      // Lancer les nouveaux fils
      
      
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' va lancer des fils en parallele,   hashStamp = ',hashStamp);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
            
      OS_MEMORY_BARRIER;
      
      for i := filsDebut to filsFin do
        if filsEnAttenteDeLancement[i] then
          begin
          
            
            
            // ASSERT : verification que le numero de la thread affecte à ce fils n'est pas debile
            {$IFC USE_ASSERTIONS_DE_PARALLELISME}
            if ( threadAffecteeACeFils[i] < 0 ) | ( threadAffecteeACeFils[i] > kNombreMaxAlphaBetaTasks ) then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('ASSERT : ( threadAffecteeACeFils[i] < 0 ) | ( threadAffecteeACeFils[i] > kNombreMaxAlphaBetaTasks ) dans GererNoeudDeParallelisme !!  threadAffecteeACeFils[i] = ',threadAffecteeACeFils[i]);
                Sysbeep(0);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
            
            
            // ASSERT : verification que la thread que l'on va lancer n'est pas nous-meme...
            {$IFC USE_ASSERTIONS_DE_PARALLELISME}
            if ( threadAffecteeACeFils[i] = nroThreadDuPere) then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('ASSERT : (threadAffecteeACeFils[i] = nroThreadDuPere) dans GererNoeudDeParallelisme !!  threadAffecteeACeFils[i] = ',threadAffecteeACeFils[i]);
                Sysbeep(0);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
      
            if gAlphaBetaTasksData^[threadAffecteeACeFils[i]].threadDuPere = nroThreadDuPere
              then EnleverLInterruptionPourCetteThread(threadAffecteeACeFils[i], nbreVides - 1);
            
            
            
            // Normalement, le message passé à un fils est "kPleaseExploreThisSubtree", mais si on s'apercoit
            // que l'on a été interrompu pendant la recherche des taches au chomage, on ne va pas lancer le fils,
            // mais au contraire emettre le remettre dans son etat "kPleaseGoSleeping" pour indiquer qu'il est 
            // a nouveau disponible
            
            
            if betaCoupureTrouvee | ThreadEstInterrompue(nroThreadDuPere, nbreVides)
              then
                begin
                
                
                  {$IFC AVEC_DEBUG_PARALLELISME}
                  if DoitDebugguerParallelismeDansRapport then
                    begin
                      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                      WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' est interrompue et libere, avant meme de la lancer, la thread fils ',threadAffecteeACeFils[i]);
                      AttendreFrappeClavierParallelisme(true);
                      err := MPExitCriticalRegion(gRapportCriticalRegionID);
                    end;
                  {$ENDC}
            
                
                  
                  // ASSERT : verification que l'on n'a pas plus de threads disponibles que de threads lancees
                  {$IFC USE_ASSERTIONS_DE_PARALLELISME}
                  if ( gNbreThreadsDisponibles > kNombreMaxAlphaBetaTasks ) then
                    begin
                      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                      WritelnNumDansRapport('ASSERT : (gNbreThreadsDisponibles > kNombreMaxAlphaBetaTasks) dans GererNoeudDeParallelisme !!    gNbreThreadsDisponibles = ',gNbreThreadsDisponibles);
                      Sysbeep(0);
                      AttendreFrappeClavierParallelisme(true);
                      err := MPExitCriticalRegion(gRapportCriticalRegionID);
                    end;
                  {$ENDC}
          
                  
                  // Ce fils que l'on avait reservé est en fait disponible
                  EnleverLaReservationDUneThread(node,threadAffecteeACeFils[i]);
                  
                  
                  // On indique que le processeur que l'on avait reservé pour travailler est en fait libre
                  ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
                  
                  
                  {$IFC AVEC_DEBUG_PARALLELISME}
                  if DoitDebugguerParallelismeDansRapport then
                    begin
                      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                      WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' libère un fils, je décrémente gNbreProcesseursCalculant : ',gNbreProcesseursCalculant);
                      WritelnDansRapport('');
                      AttendreFrappeClavierParallelisme(true);
                      err := MPExitCriticalRegion(gRapportCriticalRegionID);
                    end;
                  {$ENDC}
                  
                  threadAffecteeACeFils[i] := -500;
                  filsEnAttenteDeLancement[i] := false;
                  
                  OS_MEMORY_BARRIER;
                  
                end
              else
                begin
                
                
                  {$IFC AVEC_DEBUG_PARALLELISME}
                  if DoitDebugguerParallelismeDansRapport then
                    begin
                      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                      WritelnDansRapport('La thread '+NumEnString(nroThreadDuPere)+' lance un job : (coupDuFils, stamp, threadFils) = ('+CoupEnStringEnMajuscules(gAlphaBetaTasksData^[threadAffecteeACeFils[i]].coupSubTree)+','+NumEnString(gAlphaBetaTasksData^[threadAffecteeACeFils[i]].hashDuPere)+','+NumEnString(threadAffecteeACeFils[i])+')');
                      AttendreFrappeClavierParallelisme(true);
                      err := MPExitCriticalRegion(gRapportCriticalRegionID);
                    end;
                  {$ENDC}
            
                
                  inc(nbreResultatsEnAttente);
                  
                  if gAlphaBetaTasksData^[threadAffecteeACeFils[i]].threadDuPere = nroThreadDuPere
                    then EnleverLInterruptionPourCetteThread(threadAffecteeACeFils[i], nbreVides - 1);
                  
                  
                  
                  // LANCEMENT DU FILS, EN LEVANT LE SEMAPHORE OU EN ARRETANT LE SPIN-LOCK, SELON LE CAS
                  
                  filsEnAttenteDeLancement[i] := false;
                  
                  OS_MEMORY_BARRIER;
                  
                  LancerUnFils(threadAffecteeACeFils[i]);
                  
                  
                  
                end;
            
            
          end;
      
      
    MicroSeconds(microSecondesFin);
    gProfilerParallelisme[5] := gProfilerParallelisme[5] + (microSecondesFin.lo-microSecondesDepart.lo);
      
   
   
  ATTENDRE_LES_RESULTATS :


      
      
      // Est-on interrompu ?
      if InterruptionDansCeNoeudDeParallelisme(node) then
        begin
          
          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnDansRapport('Sortie par interruption {1} de la thread '+NumEnString(nroThreadDuPere)+' : (nroThreadDuPere,action) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(action)+')');
              WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          
          
          exit(GererNoeudDeParallelisme);
        end;
        
        
        
      if (action <> kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE) 
        then
          begin
          
            {$IFC AVEC_DEBUG_PARALLELISME}
            if DoitDebugguerParallelismeDansRapport then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnDansRapport('Sortie car (action <> kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE) de la thread '+NumEnString(nroThreadDuPere)+' : (nroThreadDuPere,action) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(action)+')');
                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
          
            exit(GererNoeudDeParallelisme);
          end
        else
          begin
            if not(ThreadEstInterrompue(nroThreadDuPere, nbreVides)) & not(betaCoupureTrouvee) then
              begin
                if (nroDuFilsCourant < filsFin) & not(betaCoupureTrouvee) 
                  then
                    begin
                      // PRENDRE MOI-MEME UN FILS A ANALYSER
                      
                      OS_MEMORY_BARRIER;
                      
                      resultatDuFils := MeLancerMoiMemeRecursivementSurUnFils(node, coupDuFils);
                      
                      resultStamp := hashStamp;
                      
                      goto ON_VIENT_DE_TROUVER_UN_RESULTAT_A_ANALYSER;
                      
                    end
                  else
                    begin
                    
                      {$IFC AVEC_DEBUG_PARALLELISME}
                      if DoitDebugguerParallelismeDansRapport then
                        begin
                          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                          WritelnDansRapport('');
                          WritelnDansRapport('ENTREE de la thread '+NumEnString(nroThreadDuPere)+' dans la boucle pour attendre les resultats des fils');
                          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                          WritelnDansRapport('');
                          AttendreFrappeClavierParallelisme(true);
                          err := MPExitCriticalRegion(gRapportCriticalRegionID);
                        end;
                      {$ENDC}
                    
                      OS_MEMORY_BARRIER;
                    
                      // BOUCLER POUR ATTENDRE LES RESULTATS DES FILS
                      
                      while (node.nbreResultatsEnAttente > 0) & not(betaCoupureTrouvee) do
                        begin
                          
                          // notre thread va se mettre en attente passive
                          ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
          
                          // Attendre les resultats des fils que l'on a lancés
                          AttendreDesResultatsEnProposantSesServices(node);
                          
                          // notre thread sort de son attente passive
                          ATOMIC_INCREMENT_32_BARRIER(gNbreProcesseursCalculant);
                          
                          // Est-on interrompu ?
                          if InterruptionDansCeNoeudDeParallelisme(node) then
                            begin
                            
                              {$IFC AVEC_DEBUG_PARALLELISME}
                              if DoitDebugguerParallelismeDansRapport then
                                begin
                                  err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                                  WritelnDansRapport('SORTIE par interruption {2} de la thread '+NumEnString(nroThreadDuPere)+' : (nroThreadDuPere,action) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(action)+')');
                                  WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                                  AttendreFrappeClavierParallelisme(true);
                                  err := MPExitCriticalRegion(gRapportCriticalRegionID);
                                end;
                              {$ENDC}
            
                              exit(GererNoeudDeParallelisme);
                            end;
                          
                        end;
                      
                      OS_MEMORY_BARRIER;
                      
                      
                      {$IFC AVEC_DEBUG_PARALLELISME}
                      if DoitDebugguerParallelismeDansRapport then
                        begin
                          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                          WritelnDansRapport('');
                          WritelnDansRapport('SORTIE de la thread '+NumEnString(nroThreadDuPere)+' dans la boucle pour attendre les resultats des fils');
                          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                          WritelnDansRapport('');
                          AttendreFrappeClavierParallelisme(true);
                          err := MPExitCriticalRegion(gRapportCriticalRegionID);
                        end;
                      {$ENDC}
                        
                      
                      
                      goto APRES_L_ANALYSE_D_UN_RESULTAT;
                      
                    end;
              end;
              
          end;
      
      
      if betaCoupureTrouvee then
        goto APRES_L_ANALYSE_D_UN_RESULTAT;
      
      

      
  ON_VIENT_DE_TROUVER_UN_RESULTAT_A_ANALYSER :
  
      
      OS_MEMORY_BARRIER;

      MicroSeconds(microSecondesDepart);

      
      // Un resultat vient d'apparaitre dans la queue, ou mon appel recursif vient de se terminer
      
      
      onVientDeRecevoirUnVraiResultat := false;
      
        
      // On a le resultat d'un noeud !
      
      
      {$IFC AVEC_DEBUG_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnDansRapport('La thread '+NumEnString(nroThreadDuPere)+' vient de recevoir un résultat : (coupDuFils, result, stamp) = ('+CoupEnStringEnMajuscules(coupDuFils)+','+NumEnString(-resultatDuFils)+','+NumEnString(resultStamp)+')');
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
        
      
      // Chercher quelle thread gerait ce fils
      
      nroThreadDuFils := kNroThreadNotFound;  {not found !}
      
      for i := FilsDebut to FilsFin do
        if (listeDesCoupsLegaux[i] = coupDuFils) &                 // la bonne case ? (pourrait sans doute etre avantageusement remplace par un hash du fils
           (resultStamp = hashStamp) &                             // le bon hash du pere ?
           (threadAffecteeACeFils[i] >= 0) then                    // on attendait un resultat de cette thread ?
          begin
            nroThreadDuFils          := threadAffecteeACeFils[i];
            threadAffecteeACeFils[i] := -243;                      // on vient de recevoir le resultat de cette thread, hein...
            
            {$IFC AVEC_DEBUG_PARALLELISME}
            if DoitDebugguerParallelismeDansRapport then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('La thread fille '+NumEnString(nroThreadDuFils)+' n''est plus affectée à la thread ',nroThreadDuPere);
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
      
          end;
        
        
        
      if (nroThreadDuFils <> kNroThreadNotFound) & 
         (nroThreadDuFils >= 0) & 
         (nroThreadDuFils <= kNombreMaxAlphaBetaTasks) & 
         (resultatDuFils <> kValeurSpecialeInterruptionCalculParallele) & 
         (resultatDuFils <> -kValeurSpecialeInterruptionCalculParallele) &
         not(betaCoupureTrouvee) then
        begin
        
        
          // ASSERT : verification que l'on connait bien la thread qui a geré ce fils
          {$IFC USE_ASSERTIONS_DE_PARALLELISME}
          if ( nroThreadDuFils = kNroThreadNotFound ) then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnDansRapport('ASSERT : Resultat dont on ne connait pas la thread fils dans GererNoeudDeParallelisme !!!!');
              Sysbeep(0);
              SysBeep(0);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}

          
          // ASSERT : verification que le resultat que nous venons de recevoir correspond bien
          //          à un job que nous avons donné (comparaison des hashs)
          {$IFC USE_ASSERTIONS_DE_PARALLELISME}
          if ( resultStamp <> hashStamp ) then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnDansRapport('ASSERT : (resultStamp <> hashStamp) dans GererNoeudDeParallelisme !!');
              Sysbeep(0);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
  
            
        
          // ASSERT : verification que le numero de la thread qui a gere ce fils n'est pas débile
          {$IFC USE_ASSERTIONS_DE_PARALLELISME}
          if ( nroThreadDuFils < 0 ) | ( nroThreadDuFils > kNombreMaxAlphaBetaTasks ) then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('ASSERT : ( nroThreadDuFils < 0 ) | ( nroThreadDuFils > kNombreMaxAlphaBetaTasks ) dans GererNoeudDeParallelisme !!  nroThreadDuFils = ',nroThreadDuFils);
              Sysbeep(0);
              SysBeep(0);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}

      
          onVientDeRecevoirUnVraiResultat := true;
          
          valeur := -resultatDuFils;
          
          if (nroThreadDuFils <> nroThreadDuPere) 
            then dec(nbreResultatsEnAttente);
          
          
          // ASSERT : verification que la valeur retournee n'est pas debile
          {$IFC USE_ASSERTIONS_DE_PARALLELISME}
          if ( valeur < -64 ) | ( valeur > 64 ) then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('ASSERT : ( valeur < -64 ) | ( valeur > 64 ) dans GererNoeudDeParallelisme !!  valeur = ',valeur);
              Sysbeep(0);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}

            
          
          // Mettre a jour le meilleur score connu, eventuellement
        
          if (valeur > maximum) & not(betaCoupureTrouvee) then
            begin
              
              // Ce fils est le meilleur jusqu'a present
              maximum := valeur;
              bestDef := coupDuFils;
              
              if (valeur > alpha) then
                begin
                  alpha := valeur;  // amelioration de la fenetre
                  
                  if (valeur >= beta) then  // Coupure beta !!
                    begin
                    
                      betaCoupureTrouvee := true;
                    
                      // Interrompre le spin-lock du fils qui a provoque la coupure beta
                      if (nroThreadDuFils <> nroThreadDuPere) then
                        EnleverLaReservationDUneThread(node,nroThreadDuFils);
                      
                      
                      // Mettre eventuellement a jour les statistiques d'overhead algorithmique
                      if (coupDuFils = listeDesCoupsLegaux[filsDebut]) then
                        ATOMIC_INCREMENT_32(gNbreDeCoupuresBetaDansUnSplitNode);
                        
                      
                      // On ne va pas relancer immediatement la thread du fils dont on vient de recevoir le resultat
                      // hein, puisque l'on doit quitter
                      if (nroThreadDuFils <> nroThreadDuPere)
                        then
                          begin
                            ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
                          end
                        else
                          begin
                            // ASSERT : threadAffecteeACeFils[i] = nroThreadDuPere dans l'interruption des fils suite a une coupure beta
                            {$IFC USE_ASSERTIONS_DE_PARALLELISME}
                            (*
                            if (threadAffecteeACeFils[i] = nroThreadDuPere) then
                              begin
                                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                                WriteDansRapport('ASSERT : nroThreadDuFils = nroThreadDuPere dans un fils donnant une coupure beta');
                                WritelnDansRapport(' (pere,fils) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(nroThreadDuFils)+')');
                                Sysbeep(0);
                                err := MPExitCriticalRegion(gRapportCriticalRegionID);
                              end;
                            *)
                            {$ENDC}
                          end;
                          
                    
                      nbreResultatsEnAttente := -100;
                       
                      
                      for i := FilsDebut to FilsFin do
                        begin
                        
                          // Interrompre les fils precedents
                          if (threadAffecteeACeFils[i] >= 0) &
                             (gAlphaBetaTasksData^[threadAffecteeACeFils[i]].threadDuPere = nroThreadDuPere) then 
                            begin
                            
                              // On indique, au cas ou, que ce ne sera certes plus la peine de lancer ce fils s'il etait en instance de lancement
                              filsEnAttenteDeLancement[i] := false;
                              
                              // On n'aura plus besoin de toi, mon vieux
                              InterrompreUnFils(node,threadAffecteeACeFils[i]);
                              
                              
                              // Le fils interrompu va liberer son processeur
                              if threadAffecteeACeFils[i] <> nroThreadDuPere
                                then 
                                  begin
                                    ATOMIC_DECREMENT_32_BARRIER(gNbreProcesseursCalculant);
                                  end
                                else
                                  begin
                                    // ASSERT : threadAffecteeACeFils[i] = nroThreadDuPere dans l'interruption des fils suite a une coupure beta
                                    {$IFC USE_ASSERTIONS_DE_PARALLELISME}
                                    (*
                                    if (threadAffecteeACeFils[i] = nroThreadDuPere) then
                                      begin
                                        err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                                        WriteDansRapport('ASSERT : threadAffecteeACeFils[i] = nroThreadDuPere dans l''interruption des fils suite a une coupure beta');
                                        WritelnDansRapport(' (pere,fils) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(threadAffecteeACeFils[i])+')');
                                        Sysbeep(0);
                                        err := MPExitCriticalRegion(gRapportCriticalRegionID);
                                      end;
                                    *)
                                    {$ENDC}
                                  end;
                                  
                          
                              {$IFC AVEC_DEBUG_PARALLELISME}
                              if DoitDebugguerParallelismeDansRapport then
                                begin
                                  err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                                  WritelnNumDansRapport('La thread '+NumEnString(nroThreadDuPere)+' a trouve une coupure beta et vient d''essayer d''interrompre sa thread fils = ',threadAffecteeACeFils[i]);
                                  WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                                  WritelnDansRapport('');
                                  AttendreFrappeClavierParallelisme(true);
                                  err := MPExitCriticalRegion(gRapportCriticalRegionID);
                                end;
                              {$ENDC}
        
        
                            end;
          
                        end;
                        
                      
                      // Sortir immediatement de la fonction en renvoyant la valeur qui a provoque la coupure
                      
                      nroDuDernierFilsEvalue := nroDuFilsCourant;
                      maximum := valeur;
                      
                      
                      MicroSeconds(microSecondesFin);
                      gProfilerParallelisme[6] := gProfilerParallelisme[6] + (microSecondesFin.lo-microSecondesDepart.lo);
                      
                      
                      {$IFC AVEC_DEBUG_PARALLELISME}
                      if DoitDebugguerParallelismeDansRapport then
                        begin
                          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                          WritelnDansRapport('Sortie par beta-coupure de la thread '+NumEnString(nroThreadDuPere)+' : (nroThreadDuPere,action) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(action)+')');
                          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                          AttendreFrappeClavierParallelisme(true);
                          err := MPExitCriticalRegion(gRapportCriticalRegionID);
                        end;
                      {$ENDC}
            
                      OS_MEMORY_BARRIER;
                      
                      exit(GererNoeudDeParallelisme);
                    end;
                end;
            end;
            
          OS_MEMORY_BARRIER;
            
          // si le resultat etait le fruit d'un appel recursif a moi-meme, continuer
          
          if (nroThreadDuFils = nroThreadDuPere) 
            then goto APRES_L_ANALYSE_D_UN_RESULTAT;
            
            
          // sinon, essayer de faire quelque chose d'intelligent avec la thread qui vient de m'envoyer un resultat
          
          actionSuivante := FaireQuelqueChoseDIntelligentAvecLaThreadDuFils(node,nroThreadDuFils,nroThreadFilsDisponible);
          
          case actionSuivante of
            kTROUVER_D_AUTRES_TACHES_AU_CHOMAGE : goto ESSAYER_DE_TROUVER_D_AUTRES_TACHES_AU_CHOMAGE;
            kRECEVOIR_UN_NOUVEAU_RESULTAT       : goto RECEVOIR_UN_NOUVEAU_RESULTAT;
          end; {case}
            
          
        end;
  
  
    MicroSeconds(microSecondesFin);
    gProfilerParallelisme[11] := gProfilerParallelisme[11] + (microSecondesFin.lo-microSecondesDepart.lo);
    
    
    if (action <> kEVALUER_TOUTE_LA_POSITION_EN_PARALLELE) & not(onVientDeRecevoirUnVraiResultat) then
      begin
      
        {$IFC AVEC_DEBUG_PARALLELISME}
        if DoitDebugguerParallelismeDansRapport then
          begin
            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
            WritelnDansRapport('Le resultat ne semble reçu ne semblant pas correspondre à la position, la thread '+NumEnString(nroThreadDuPere)+' ne voudrait pas déranger... -> sortie de GererNoeudDeParallelisme');
            WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
            WritelnDansRapport('');
            AttendreFrappeClavierParallelisme(true);
            err := MPExitCriticalRegion(gRapportCriticalRegionID);
          end;
        {$ENDC}
      
        exit(GererNoeudDeParallelisme);
      end;
          
          
APRES_L_ANALYSE_D_UN_RESULTAT :


    OS_MEMORY_BARRIER;
      
      
    // Est-on interrompu ?
    if InterruptionDansCeNoeudDeParallelisme(node) then
      begin
        
        {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnDansRapport('Sortie par interruption {3} de la thread '+NumEnString(nroThreadDuPere)+' : (nroThreadDuPere,action) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(action)+')');
              WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          
        exit(GererNoeudDeParallelisme);
      end;
      
      
    // Ecouter eventuellement d'autres resultats
    if (nbreResultatsEnAttente > 0) then
      begin
      
        if GetAResultAtThisDepthAndLock(nroThreadDuPere,nbreVides) 
          then
            begin
              goto RECEVOIR_UN_NOUVEAU_RESULTAT;
            end; 
      
      end;
      
     
      
    // On sait que l'on vient d'avoir une thread qui vient de se liberer, 
    // on peut donc lancer un nouveau fils (s'il en reste a lancer) ou
    // continuer d'attendre les resultats des fils dejà lancés (si on a
    // lancé tous les fils)
            
    if PeutTrouverUneThreadEsclave(node, action, nroThreadFilsDisponible)
      then goto ON_VIENT_DE_TROUVER_UNE_TACHE_AU_CHOMAGE;
      
    // lancer eventuellement les nouveaux fils en attente
    
    for i := filsDebut to filsFin do
      if filsEnAttenteDeLancement[i] 
        then goto LANCER_LES_NOUVEAUX_FILS;
      
    
    // aller reecouter les resultats
    
    if (nbreResultatsEnAttente > 0) 
      then goto ATTENDRE_LES_RESULTATS;
           
            
    
    // Sortie normale de GererNoeudDeParallelisme : on renvoie la meilleure note des 
    // fils evalués en parallele dans la variable "maximum", et l'index du dernier 
    // fils evalué dans "nroDuDernierFilsEvalue".
    
    nroDuDernierFilsEvalue := nroDuFilsCourant;
    
    
    {$IFC AVEC_DEBUG_PARALLELISME}
    if DoitDebugguerParallelismeDansRapport then
      begin
        err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
        WritelnDansRapport('La thread '+NumEnString(nroThreadDuPere)+' sort normalement de GererNoeudDeParallelisme : (nroThreadDuPere,action) = ('+NumEnString(nroThreadDuPere)+','+NumEnString(action)+')');
        WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
        WritelnDansRapport('');
        AttendreFrappeClavierParallelisme(true);
        err := MPExitCriticalRegion(gRapportCriticalRegionID);
      end;
    {$ENDC}
  
  end;
  
  OS_MEMORY_BARRIER;
  
end;




function MySubTreeValue( plat : bitboard; nbreVides, alpha, beta, diffPions, vecteurParite, nroThread, nroThreadPere : SInt32; listeBitboard : UInt32) : SInt32;
var valeur : SInt32;
    ticks : SInt32;
    delai : SInt32;
    err : OSStatus;
    microSecondesFin : UnsignedWide;
    microSecondesDepart : UnsignedWide;
    hash_table : BitboardHashTable;
begin {$unused delai, ticks, err, nroThreadPere }



  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WriteDansRapport('Entree dans MySubTreeValue (nroThread, nroThreadPere) = ('+NumEnString(nroThread)+','+NumEnString(nroThreadPere)+') : ');
      
      {
      EcritBitboardState('',plat,nbreVides,alpha,beta,diffPions);
      WritelnNumDansRapport('vecteurParite = ',vecteurParite);
      WritelnListeBitboardDansRapport('listeBitboard = ',listeBitboard, nbreVides);
      WritelnNumDansRapport('diffPions recu = ',diffPions);
      with plat do
        WritelnNumDansRapport('diffPions calculé = ',BitboardToDiffPions(g_my_bits_low,g_my_bits_high,g_opp_bits_low,g_opp_bits_high));
      }
        
      WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
      WritelnDansRapport('');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  
  
  if ThreadEstInterrompue(nroThread, nbreVides) then
    begin
    
    
      {$IFC USE_ASSERTIONS_DE_PARALLELISME}
      if DoitDebugguerParallelismeDansRapport then 
        begin
          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
          WritelnNumDansRapport('ASSERT : Bizarre ! La thread '+NumEnString(nroThread)+' est interrompue dans MySubTreeValue avant meme d''avoir commencé son calcul...  gAlphaBetaInterrompu[nroThread] = ',gAlphaBetaInterrompu[nroThread]);
          WritelnNumDansRapport('      et son état, pour info, vaut :    etat = ',gAlphaBetaTasksData^[nroThread].etat);
          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
          WritelnDansRapport('');
          Sysbeep(0);
          AttendreFrappeClavierParallelisme(true);
          err := MPExitCriticalRegion(gRapportCriticalRegionID);
        end;
      {$ENDC}
  
      
      MySubTreeValue := kValeurSpecialeInterruptionCalculParallele;
      exit(MySubTreeValue);
    end;
  
  
  // Debut de la recherche du sous-arbre...
  
  Microseconds(microSecondesDepart);
  
  hash_table := gBitboardHashTable[0];  // toutes les threads partagent la meme table de hachage (necessite les mutex d'acces aux cellules )
  
  
  if gParallelismeRecursif
    then valeur := ABFinBitboardParallele(nroThread,plat,nbreVides,alpha,beta,diffPions,vecteurParite,gYoungBrotherWaitElders,listeBitboard,hash_table)
    else valeur := ABFinBitboardFastestFirstAvecETC(nroThread,plat,nbreVides,alpha,beta,diffPions,vecteurParite,listeBitboard,hash_table);
  
  
  // ASSERT : verification que la valeur du calcule n'est pas débile
  {$IFC USE_ASSERTIONS_DE_PARALLELISME}
  if (( valeur < -64 ) | ( valeur > 64 )) & (valeur <> kValeurSpecialeInterruptionCalculParallele) & (valeur <> -kValeurSpecialeInterruptionCalculParallele) then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnNumDansRapport('ASSERT : ( valeur < -64 ) | ( valeur > 64 ) dans MySubTreeValue !!  valeur = ',valeur);
      Sysbeep(0);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
              
  
  Microseconds(microSecondesFin);
  
  
  
  // Fin de la recherche du sous-arbre...
  
  if ThreadEstInterrompue(nroThread, nbreVides)
    then MySubTreeValue := kValeurSpecialeInterruptionCalculParallele
    else MySubTreeValue := valeur;

  
  
  {$IFC AVEC_DEBUG_PARALLELISME}
  if DoitDebugguerParallelismeDansRapport then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      if ThreadEstInterrompue(nroThread, nbreVides)
        then WritelnDansRapport('INTERRUPTION, dans MySubTreeValue, de la thread '+NumEnString(nroThread)+' après '+NumEnString(microSecondesFin.lo-microSecondesDepart.lo)+' µsec')
        else WritelnDansRapport('MySubTreeValue : la thread '+NumEnString(nroThread)+' va bientôt renvoyer à la thread '+NumEnString(nroThreadPere)+' la valeur '+NumEnString(-valeur)+', après '+NumEnString(microSecondesFin.lo-microSecondesDepart.lo)+' µsec');
      WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
      WritelnDansRapport('');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  
end;



function NbreDeThreadsDisponibles : SInt32;
begin
  NbreDeThreadsDisponibles := gNbreThreadsDisponibles;
end;


function PeutTrouverUneThreadDisponible(nroThreadMaitre : SInt32; var nroThreadEsclave : SInt32) : boolean;
var k : SInt32;
    err : OSErr;
    ecoute : OSErr;
    numeroThreadMorte : longintP;
    foo_bar_atomic_register : SInt32;
    microSecondesDepart : UnsignedWide;
    microSecondesFin : UnsignedWide;
    
begin

  MicroSeconds(microSecondesDepart);


  if (NbreDeThreadsDisponibles <= 0)
    then
      begin
        PeutTrouverUneThreadDisponible := false;
        nroThreadEsclave := -1001;
      end
    else
      begin
      
        // D'ABORD CHERCHER SI ON A UNE THREAD DEJA VIVANTE
      
        for k := 1 to kNombreMaxAlphaBetaTasks do
          begin
            if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseGoSleeping, kPleaseWaitForJobPreparation, gAlphaBetaTasksData^[k].etat) <> 0 then
              begin
                // on indique que l'on vient de reserver une thread : elle va tourner sur un processeur
                ATOMIC_INCREMENT_32_BARRIER(gNbreProcesseursCalculant);
                
                
                PeutTrouverUneThreadDisponible := true;
                nroThreadEsclave := k;
                
                
                {$IFC AVEC_DEBUG_PARALLELISME}
                if DoitDebugguerParallelismeDansRapport then
                  begin
                    err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                    WritelnNumDansRapport('La thread '+NumEnString(nroThreadEsclave)+' vient de se faire reserver par la thread '+NumEnString(nroThreadMaitre)+', j''incremente gNbreProcesseursCalculant : ',gNbreProcesseursCalculant);
                    WritelnNumDansRapport('       l''etat de la thread '+NumEnString(nroThreadEsclave)+' est : ',gAlphaBetaTasksData^[nroThreadEsclave].etat);
                    WritelnDansRapport('');
                    AttendreFrappeClavierParallelisme(true);
                    err := MPExitCriticalRegion(gRapportCriticalRegionID);
                  end;
                {$ENDC}
                
                
                
                MicroSeconds(microSecondesFin);
                gProfilerParallelisme[4] := gProfilerParallelisme[4] + (microSecondesFin.lo-microSecondesDepart.lo);
                
                exit(PeutTrouverUneThreadDisponible);
              end;
          end;
      
      
        // SINON CHERCHER SI IL Y A UNE THREAD MORTE A REVEILLER
        
        
        
        ecoute := kMPTimeoutErr;
        
        ecoute := MPWaitOnQueue(gListeDesThreadsMortes,@numeroThreadMorte,NIL,NIL,kDurationImmediate);
        
        
        
        
        if (ecoute = NoErr)  then
          begin
          
          
            
            if (numeroThreadMorte^ < 0) | (numeroThreadMorte^ > kNombreMaxAlphaBetaTasks) then
              begin
              
                // ASSERT : verification que le numero de la thread morte trouvee n'est pas debile !!!
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('ASSERT : (numeroThreadMorte < 0) | (numeroThreadMorte > kNombreMaxAlphaBetaTasks) PeutTrouverUneThreadDisponible !!!   numeroThreadMorte = ',numeroThreadMorte^);
                Sysbeep(0);
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
                
                
                PeutTrouverUneThreadDisponible := false;
                nroThreadEsclave := -1000;
                
                exit(PeutTrouverUneThreadDisponible);
        
              end;
            
            
              
          
            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
            WritelnDansRapport('');
            WritelnDansRapport('La thread '+NumEnString(nroThreadMaitre)+' va essayer de réveiller la thread numéro '+NumEnString(numeroThreadMorte^)+', qui semble etre en sommeil...');
            WritelnNumDansRapport('       l''etat de la thread '+NumEnString(numeroThreadMorte^)+' est : ',gAlphaBetaTasksData^[numeroThreadMorte^].etat);
            WritelnDansRapport('');
            AttendreFrappeClavierParallelisme(true);
            err := MPExitCriticalRegion(gRapportCriticalRegionID);
            
            
            if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kNoOrderReceived, kPleaseWaitForJobPreparation, gAlphaBetaTasksData^[numeroThreadMorte^].etat) <> 0 then
              begin
                // on indique que l'on vient de reserver une thread : elle va tourner sur un processeur
                ATOMIC_INCREMENT_32_BARRIER(gNbreProcesseursCalculant);
              
                
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnDansRapport('Cool, la thread '+NumEnString(nroThreadMaitre)+' a réussi à reserver la thread numéro '+NumEnString(numeroThreadMorte^)+' et incremente donc gNbreProcesseursCalculant');
                WritelnNumDansRapport('       l''etat de la thread '+NumEnString(numeroThreadMorte^)+' est : ',gAlphaBetaTasksData^[numeroThreadMorte^].etat);
                WritelnDansRapport('');
                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                WritelnDansRapport('');
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
                
                
                
                // on reveille effectivement la thread
                ecoute := MPSignalSemaphore(gAlphaBetaTasksData^[numeroThreadMorte^].semaphoreDeReveil); 
                
                if (ecoute = NoErr) 
                  then
                    begin
                    
                      PeutTrouverUneThreadDisponible := true;
                      nroThreadEsclave := numeroThreadMorte^;
                      
                      MicroSeconds(microSecondesFin);
                      gProfilerParallelisme[14] := gProfilerParallelisme[14] + (microSecondesFin.lo-microSecondesDepart.lo);
                      
                      exit(PeutTrouverUneThreadDisponible);
                    end;
                
              end;
              
              
            // ASSERT : impossible de changer l'etat de la thread morte dans PeutTrouverUneThreadDisponible !!! 
            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
            WritelnNumDansRapport('ASSERT : impossible de changer l''etat de la thread morte dans PeutTrouverUneThreadDisponible !!!   etat = ',gAlphaBetaTasksData^[numeroThreadMorte^].etat);
            Sysbeep(0);
            AttendreFrappeClavierParallelisme(true);
            err := MPExitCriticalRegion(gRapportCriticalRegionID);
              
          end;
          
        
        // Il n'y vraiment rien, hein
        
       
        PeutTrouverUneThreadDisponible := false;
        nroThreadEsclave := -1000;
      end;
    
    
  MicroSeconds(microSecondesFin);
  gProfilerParallelisme[4] := gProfilerParallelisme[4] + (microSecondesFin.lo-microSecondesDepart.lo);
  
  
end;








function MyAlphaBetaTask( parameter : univ Ptr) : OSStatus;
var err : OSErr;
    taskKilled : boolean;
    p : ParallelAlphaBetaPtr;
    valeur : SInt32;
    foo_bar_atomic_register : SInt32;
    compteur : SInt32;

label LANCER_UNE_PROPOSITION_DE_TRAVAIL;
label ATTENDRE_SUR_LE_SEMAPHORE;
label EXPLORER_UN_SOUS_ARBRE;
label PUBLIER_LE_RESULTAT;
label ATTENTE_ACTIVE_SUR_LE_SPIN_LOCK;
label ATTENDRE_LA_PREPARATION_D_UN_JOB;
label ENDORMIR_LA_THREAD;


  
begin

  // Obtenir un pointeur sur les données de la tache
  p := ParallelAlphaBetaPtr(parameter);
  
  with p^ do
    begin
    
      taskKilled := false;
      
      
ENDORMIR_LA_THREAD :      

      OS_MEMORY_BARRIER;
      
      
      // Indiquer que l'on est une thread morte en attente d'un reveil (en donnant son numero pour pouvoir etre reveillée)
      err := MPNotifyQueue(gListeDesThreadsMortes,Ptr(@nroThread),NIL,NIL);
      
      
      ATOMIC_INCREMENT_32_BARRIER(gNbreThreadsDisponibles);
      
      
      // Attendre sur le semaphore de reveil
      err := MPWaitOnSemaphore(semaphoreDeReveil, kDurationForever); 
      
      
      
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnDansRapport('');
      WritelnDansRapport('La thread '+NumEnString(nroThread)+' dit : « Coucou, je me reveille, what''s up ? »');
      WritelnDansRapport('');
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
      
      
      ATOMIC_DECREMENT_32_BARRIER(gNbreThreadsDisponibles);
      
      
      goto ATTENDRE_LA_PREPARATION_D_UN_JOB;
      
      
      
      // Tant que Cassio ne quitte pas...
      while not(taskKilled) do
        begin
        
        

LANCER_UNE_PROPOSITION_DE_TRAVAIL :

          OS_MEMORY_BARRIER;
          
        
          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('Je suis prete a travailler, je suis la thread numero : ',nroThread);
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          
          ATOMIC_INCREMENT_32_BARRIER(gNbreThreadsDisponibles);
        
          
          // ASSERT : verification que l'on n'a pas plus de threads disponibles que de threads lancees
          {$IFC USE_ASSERTIONS_DE_PARALLELISME}
          if ( gNbreThreadsDisponibles > kNombreMaxAlphaBetaTasks ) then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('ASSERT : (gNbreThreadsDisponibles > kNombreMaxAlphaBetaTasks) dans MyAlphaBetaTask !!    gNbreThreadsDisponibles = ',gNbreThreadsDisponibles);
              Sysbeep(0);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          

ATTENDRE_SUR_LE_SEMAPHORE :

          
          

          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnStringDansRapport('La thread '+NumEnString(nroThread)+' se met en attente sur son semaphore de sommeil');
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          
          
          
          
          OS_MEMORY_BARRIER;
          
          compteur := 0;
          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) then
               while (ATOMIC_COMPARE_AND_SWAP_32(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) do 
                  begin
                    (* inc(compteur);
                    if compteur >= 1000 then
                      begin
                        compteur := RandomEntreBornes(0,1000) - 2000;
                        {if gSpinLocksYieldTimeToCPU then MPYield;}
                      end;
                    *)
                  end;
          
          OS_MEMORY_BARRIER;
          
          
          ATOMIC_DECREMENT_32_BARRIER(gNbreThreadsDisponibles);
          
          
          
          // ASSERT : verification que l'on le nombre de threads disponibles n'est pas debile
          {$IFC USE_ASSERTIONS_DE_PARALLELISME}
          if ( gNbreThreadsDisponibles < 0 ) then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('ASSERT : (gNbreThreadsDisponibles < 0) dans MyAlphaBetaTask !!    gNbreThreadsDisponibles = ',gNbreThreadsDisponibles);
              Sysbeep(0);
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          
          
          
          
ATTENDRE_LA_PREPARATION_D_UN_JOB :


          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnStringDansRapport('La thread '+NumEnString(nroThread)+' se met en attente pendant la preparation d''un job');
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          
          
          OS_MEMORY_BARRIER;
          
          compteur := 0;
          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseWaitForJobPreparation,kPleaseWaitForJobPreparation,etat) <> 0 ) then 
               while (ATOMIC_COMPARE_AND_SWAP_32(kPleaseWaitForJobPreparation,kPleaseWaitForJobPreparation,etat) <> 0 ) do 
                 begin
                   (*
                   inc(compteur);
                   if compteur >= 1000 then
                     begin
                       compteur := RandomEntreBornes(0,1000) - 2000;
                       {if gSpinLocksYieldTimeToCPU then MPYield;}
                     end;
                   *)
                 end;

          OS_MEMORY_BARRIER;
          
          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) then
            begin
              message := kPleaseGoSleeping;
              goto LANCER_UNE_PROPOSITION_DE_TRAVAIL;
            end;
            
          
EXPLORER_UN_SOUS_ARBRE :          

          OS_MEMORY_BARRIER;
          
          if (message = kPleaseExploreThisSubtree) & (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseExploreThisSubtree,kPleaseExploreThisSubtree,etat) <> 0)
            then
              begin
              
                // Chouette, on a du boulot !
                
                EnleverLInterruptionPourCetteThread(nroThread, profondeurSubTree);
                
                
                {$IFC AVEC_DEBUG_PARALLELISME}
                if DoitDebugguerParallelismeDansRapport then
                  begin
                    err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                    WritelnStringDansRapport('La thread '+NumEnString(nroThread)+' a du boulot et va appeler MySubTreeValue');
                    WritelnDansRapport('');
                    AttendreFrappeClavierParallelisme(true);
                    err := MPExitCriticalRegion(gRapportCriticalRegionID);
                  end;
                {$ENDC}
                
                
                // Lancer le calcul du sous-arbre
                valeur := MySubTreeValue( positionSubTree, profondeurSubTree, alphaSubTree, betaSubTree, diffPionsSubTree, vecteurPariteSubTree, nroThread, threadDuPere, listeBitboardSubTree);
                
                
                
                {$IFC AVEC_DEBUG_PARALLELISME}
                if DoitDebugguerParallelismeDansRapport then
                  begin
                    err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                    WritelnNumDansRapport('La thread '+NumEnString(nroThread)+' vient de sortir de MySubTreeValue, valeur = ',-valeur);
                    WritelnDansRapport('');
                    AttendreFrappeClavierParallelisme(true);
                    err := MPExitCriticalRegion(gRapportCriticalRegionID);
                  end;
                {$ENDC}
    

PUBLIER_LE_RESULTAT :                 
                
                
                OS_MEMORY_BARRIER;
                
                // Si on n'a pas ete interrompu, donner le resultat du calcul au lanceur
                
                
                (*
                if not(ThreadEstInterrompue(nroThread, profondeurSubTree)) & 
                   (valeur <> kValeurSpecialeInterruptionCalculParallele) &
                   (valeur <> -kValeurSpecialeInterruptionCalculParallele)
                   then
                  begin
                
                *)
                  
                    if gUseSpinLocks
                      then
                        begin
                          // indiquer a la thread qu'elle devra rentrer dans le futur spinlock quand elle aura fini
                          
                          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseExploreThisSubtree,kPleaseDoSpinLock,etat) <> 0) then
                              
                             begin
                             
                               PosterUnResultatAUneThread(threadDuPere, valeur, coupSubTree, hashDuPere, profondeurSubTree + 1);
                               
                             end;
                        end
                      else
                        begin
                          // indiquer a la thread qu'elle devra lancer une proposition de travail puis se bloquer quand elle aura fini
                          
                          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseExploreThisSubtree,kPleaseGoSleeping,etat) <> 0) then
                             
                             begin
                               
                               PosterUnResultatAUneThread(threadDuPere, valeur, coupSubTree, hashDuPere, profondeurSubTree + 1);
                               
                             end;
                        end;
                        
                 (*
                    
                  end;
                  
                  *)
                
                // Si la thread a été interrompue, elle vient de sortir de sa recherche et donc
                // l'interruption a fait son office : on peut l'enlever
                EnleverLInterruptionPourCetteThread(nroThread, profondeurSubTree);
                
              end;
          
          
ATTENTE_ACTIVE_SUR_LE_SPIN_LOCK :
            
            
          OS_MEMORY_BARRIER;

          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('La thread '+NumEnString(nroThread)+' a réussi à poster son résultat (si elle en avait) et va rentrer dans le spin-lock, son etat est : ',etat);
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}
          
          
          // Il se peut que la thread ait ete interrompue
          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) then
            begin
              message := kPleaseGoSleeping;
              
              OS_MEMORY_BARRIER;
              
              goto LANCER_UNE_PROPOSITION_DE_TRAVAIL;
            end;
          
          
          OS_MEMORY_BARRIER;
          
          // LE SPIN LOCK D'ATTENTE ACTIVE !!
          
          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseDoSpinLock,kPleaseDoSpinLock,etat) <> 0 ) then 
               while (ATOMIC_COMPARE_AND_SWAP_32(kPleaseDoSpinLock,kPleaseDoSpinLock,etat) <> 0 ) do 
                 begin
                    {if gSpinLocksYieldTimeToCPU then MPYield;}
                 end;
          
          
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('La thread '+NumEnString(nroThread)+' vient de sortir de son spin-lock, etat = ',etat);
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
            
          
          OS_MEMORY_BARRIER;
          
          if (ATOMIC_COMPARE_AND_SWAP_32_BARRIER(kPleaseExploreThisSubtree,kPleaseExploreThisSubtree,etat) <> 0) & (message = kPleaseExploreThisSubtree) then 
            begin
             
              if DoitDebugguerParallelismeDansRapport then
                begin
                  err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                  WritelnStringDansRapport('La thread '+NumEnString(nroThread)+' retrouve immediatement du travail');
                  WritelnDansRapport('');
                  AttendreFrappeClavierParallelisme(true);
                  err := MPExitCriticalRegion(gRapportCriticalRegionID);
                end;
            
              
              goto EXPLORER_UN_SOUS_ARBRE;
            
            end;
          
          
          
        end;
    end;
  
  MyAlphaBetaTask := err;
end;



procedure CreateAlphaBetaTasks;
var err : OSStatus;
    i : SInt32;
begin

  // Assume single processor computer
  numProcessors := 1;

  // Initialise globals
  gAlphaBetaTasksData         := NIL;
  gNbreThreadsDisponibles     := 0;
  
  gAvecAttenteTouchePourDebuguerParallelisme := false;

  // If the multiprocessing librairy is present then create the tasks
  if CanInitializeOSAtomicUnit & 
     MPLibraryIsLoaded & 
     (kNombreMaxAlphaBetaTasks > 0) then
    begin
    
      CassioUtiliseLeMultiprocessing := true;
      
      numProcessors := MPProcessorsScheduled;
      
      // FIXME : on simule un ordinateur avec deux processeurs
      
      numProcessors := 2;
      
      
      // FIXME : il doit y avoir un nombre de taches optimal pour N processeurs (peut-etre (N+1) ?)
      
      
      // creer l'emplacement memoire reservé aux tâches
      gAlphaBetaTasksData := ParallelAlphaBetaRecArrayPtr(AllocateMemoryPtrClear((kNombreMaxAlphaBetaTasks + 2) * SizeOf(ParallelAlphaBetaRec)));
      err := MemError;
      
      
      // initialisation des pointeurs
      if err = NoErr then
        begin
          for i := 0 to kNombreMaxAlphaBetaTasks do
            begin
              gAlphaBetaInterrompu[i]                   := kPasDInterrumptionPourCetteThread;
              gMutexEcritureInterruptionThread[i]       := 0;
              gAlphaBetaTasksData^[i].semaphoreDeReveil := NIL; 
              gAlphaBetaTasksData^[i].taskID            := NIL;
              gAlphaBetaTasksData^[i].etat              := kNoOrderReceived;
              
              with gFileDesResultats[i] do
                begin                         
                  nombreDeResultats  := 0;
                  valeurResultat     := kValeurSpecialeInterruptionCalculParallele;
                  coup               := 0;
                  hashPere           := 0;
                  profondeur         := 0;
                end;
            end;
        end;
          
      OS_MEMORY_BARRIER;
      
      
      // creer la file de validation de destruction des taches
      if (err = noErr) then
         err := MPCreateQueue(gTerminaisonDesTaches);
         
         
      // creer la file des threads initialement mortes  
      if (err = noErr) then
         err := MPCreateQueue(gListeDesThreadsMortes);
         
      
      // creer la region critique d'ecriture dans le rapport pour le debugage
      if (err = noErr) then
         err := MPCreateCriticalRegion(gRapportCriticalRegionID);
      
      
      // creer le mutex d'affichage des valeurs de debugage du parallelisme
      gMesureDeParallelsimeMutex := 0;
      
      
      // lancement des taches esclaves, pour les processeurs 1 .. (nombreProcesseurs - 1)
      for i := 1 to kNombreMaxAlphaBetaTasks do
        if (err = noErr) then
            begin
              
            
              gAlphaBetaTasksData^[i].nroThread := i;
            
              if (err = noErr) then err := MPCreateSemaphore(1,0,gAlphaBetaTasksData^[i].semaphoreDeReveil); 
              
              OS_MEMORY_BARRIER;
              
              if (err = noErr) then err := MPCreateTask(@MyAlphaBetaTask, 
                                                        @gAlphaBetaTasksData^[i], 
                                                        kMPStackSize,
                                                        gTerminaisonDesTaches, NIL, NIL, 
                                                        kMPTaskOptions,
                                                        @gAlphaBetaTasksData^[i].taskID);
            end;
      
      
      // if something went wrong, just go back to single processor mode
      
      if (err <> noErr) then
        begin
          StopAlphaBetaTasks;
          numProcessors := 1;
        end;
    end;
  
  // only one processor is active at the moment, on which the normal, monothreaded Cassio is running
  gNbreProcesseursCalculant    := 1;
  
end;


procedure StopAlphaBetaTasks;
var i : UInt32;
    err : OSStatus;
begin
  if gAlphaBetaTasksData <> NIL then
    begin
    
    
      for i := 1 to kNombreMaxAlphaBetaTasks do
        with gAlphaBetaTasksData^[i] do
          begin
            
            if taskID <> NIL then
              begin
                err := MPTerminateTask(taskID, noErr);
                err := MPWaitOnQueue(gTerminaisonDesTaches, NIL, NIL, NIL, kDurationForever);
              end;
            
            if (semaphoreDeReveil <> NIL)
              then err := MPDeleteSemaphore(semaphoreDeReveil); 
          
          end;
      
      
      if (gListeDesThreadsMortes <> NIL) then
        begin
          err := MPDeleteQueue(gListeDesThreadsMortes);
          gListeDesThreadsMortes := NIL;
        end;
      
      if (gTerminaisonDesTaches <> NIL) then
        begin
          err := MPDeleteQueue(gTerminaisonDesTaches);
          gTerminaisonDesTaches := NIL;
        end;
      
      if (gRapportCriticalRegionID <> NIL) then
        begin
          err := MPDeleteCriticalRegion(gRapportCriticalRegionID);
          gRapportCriticalRegionID := NIL;
        end;
      
      DisposeMemoryPtr(Ptr(gAlphaBetaTasksData));
            
    end;
end;


procedure PointDeMesureDeParallelisme;
var err : OSStatus;
    foo_bar_atomic_register : SInt32;
begin  {$unused err}

  // On incrémente les compteurs

  ATOMIC_INCREMENT_32(gNbreAppelsMesureDeParallelisme);
  ATOMIC_ADD_32(gNbreProcesseursCalculant,gDegreDeParallelisme);
  
  if (gNbreProcesseursCalculant > numProcessors) then
    ATOMIC_INCREMENT_32(gFraisDeSynchronisation);
  
  
  // pas de blague d'overflow, hein...
  if (gDegreDeParallelisme < 0) | (gNbreAppelsMesureDeParallelisme < 0) | (gFraisDeSynchronisation < 0) then
    begin
      gNbreAppelsMesureDeParallelisme := 0;
      gDegreDeParallelisme := 0;
      gFraisDeSynchronisation := 0;
    end;
  
  
  
  // ASSERT : verification que Cassio a au moins un processeur actif... pouf pouf
  {$IFC USE_ASSERTIONS_DE_PARALLELISME}
  if (gNbreProcesseursCalculant < 0) then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnNumDansRapport('ASSERT : (gNbreProcesseursCalculant < 0) dans PointDeMesureDeParallelisme !!  gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
      Sysbeep(0);
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  
  // ASSERT : verification que Cassio n'a pas lancé plus de taches que de processeurs physiques...
  {$IFC USE_ASSERTIONS_DE_PARALLELISME}
  if (gNbreProcesseursCalculant > numProcessors) then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnNumDansRapport('ASSERT : (gNbreProcesseursCalculant > numProcessors) dans PointDeMesureDeParallelisme !!  gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
      Sysbeep(0);
      AttendreFrappeClavierParallelisme(true);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  
    
  {
  if (gNbreAppelsMesureDeParallelisme mod 1024) = 0 
    then EcrireMesureDeParallelismeDansRapport;
  }
  
end;


function TauxDeParallelisme : extended;
begin
  if (gNbreAppelsMesureDeParallelisme <> 0)
    then TauxDeParallelisme := 100.0*(1.0*gDegreDeParallelisme/(1.0*gNbreAppelsMesureDeParallelisme))
    else TauxDeParallelisme := 0.0;
end;


function FraisDeSynchro : extended;
begin
  if (gNbreAppelsMesureDeParallelisme <> 0)
    then FraisDeSynchro := 100.0*(1.0*gFraisDeSynchronisation/(1.0*gNbreAppelsMesureDeParallelisme))
    else FraisDeSynchro := 0.0;
end;


function ParallelismeUtile : extended;
begin
  ParallelismeUtile := TauxDeParallelisme - FraisDeSynchro;
end;


procedure EcrireMesureDeParallelismeDansRapport;
begin
  if (gNbreAppelsMesureDeParallelisme <> 0) 
    then WritelnStringAndReelDansRapport('// = ',TauxDeParallelisme, 8)
    else WritelnDansRapport(' non disponible');
end;


procedure EcrireFraisDeSynchronisationDansRapport;
begin
  if (gNbreAppelsMesureDeParallelisme <> 0) 
    then WritelnStringAndReelDansRapport('∑ = ',FraisDeSynchro, 8)
    else WritelnDansRapport(' non disponible');
end;


procedure EcrireParallelismeUtileDansRapport;
begin
  if (gNbreAppelsMesureDeParallelisme <> 0) 
    then WritelnStringAndReelDansRapport('',ParallelismeUtile, 8)
    else WritelnDansRapport(' non disponible');
end;


procedure AfficherLesSpinlocksDuParallelisme;
var i : SInt32;
    s : str255;
begin

  (*
  
  if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(0, 1, gMesureDeParallelsimeMutex) <> 0 then
    begin
  
      if windowPlateauOpen then
        begin

          for i := 0 to kNombreMaxAlphaBetaTasks do
            begin
              s := 'etat de la thread '+NumEnString(i)+' = ';
              
              WriteNumAt('                                                                                                                          ',0,365,300+i*10);
              WriteNumAt(s,gAlphaBetaTasksData^[i].etat,365,300+i*10);
            end;
          
          s := 'nombre de mutex utilisés sur la table de hachage = ';
          WriteNumAt(s,NumberOfBitHashMutexLocksInUse,365,300+(kNombreMaxAlphaBetaTasks+2)*10);
          
          s := 'nombre de processeurs calculants = ';
          WriteNumAt(s,gNbreProcesseursCalculant,365,300+(kNombreMaxAlphaBetaTasks+3)*10);
          
          s := 'nombre de threads disponibles = ';
          WriteNumAt(s,NbreDeThreadsDisponibles,365,300+(kNombreMaxAlphaBetaTasks+4)*10);
          
          for i := 0 to kNombreDeProfilersDuParallelisme do
            begin
              s := 'gProfilerParallelisme['+NumEnString(i)+'] = ';
              
              WriteNumAt(s,gProfilerParallelisme[i],15,300+i*10);
            end;
          
          
          for i := 0 to kNombreMaxAlphaBetaTasks do
            begin
              s := 'gFileDesResultats['+NumEnString(i)+'] = ';
              
              WriteNumAt(s,gFileDesResultats[i].nombreDeResultats,225,300+i*10);
            end;
          
        end;
        
        
    
      if ATOMIC_COMPARE_AND_SWAP_32_BARRIER(1, 0, gMesureDeParallelsimeMutex) <> 0 then;
    end;
    
  *)
  
end;


procedure AttendreFrappeClavierParallelisme(attenteTouche : boolean);
var err : OSErr;  
begin   {$unused attenteTouche}


  AfficherLesSpinlocksDuParallelisme;
  {if WaitNextEvent(0,fooEventParallelisme,2,NIL) then;}
  
  
  if (QDIsPortBuffered(GetWindowPort(wPlateauPtr))) then
    QDFlushPortBuffer(GetWindowPort(wPlateauPtr), NIL); 
  
  // ASSERT : verification que Cassio a au moins un processeur actif... pouf pouf
  {$IFC USE_ASSERTIONS_DE_PARALLELISME}
  if (gNbreProcesseursCalculant < 0) then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnNumDansRapport('ASSERT : (gNbreProcesseursCalculant < 0) dans AttendreFrappeClavierParallelisme !!  gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
      Sysbeep(0);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  
  // ASSERT : verification que Cassio n'a pas lancé plus de taches que de processeurs physiques...
  {$IFC USE_ASSERTIONS_DE_PARALLELISME}
  if (gNbreProcesseursCalculant > numProcessors) then
    begin
      err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
      WritelnNumDansRapport('ASSERT : (gNbreProcesseursCalculant > numProcessors) dans AttendreFrappeClavierParallelisme !!  gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
      Sysbeep(0);
      err := MPExitCriticalRegion(gRapportCriticalRegionID);
    end;
  {$ENDC}
  
  (*
  if attenteTouche & gAvecAttenteTouchePourDebuguerParallelisme
    then 
      begin
        AttendFrappeClavier;
      end;
  *)
end;


function DoitDebugguerParallelismeDansRapport : boolean;
begin
  if (kVerbosityLevelAlgoParallele >= 3) & (nbreNoeudsGeneresFinale >= kNombreDeNoeudMinimalPourSuiviDansRapport)
    then
      begin
        DoitDebugguerParallelismeDansRapport := true;
      end
    else
      begin
        DoitDebugguerParallelismeDansRapport := false;
        
        // mais on affiche quand meme les spin-locks du parallelisme dans la fenetre de l'othellier
        AttendreFrappeClavierParallelisme(false);
      end;
end;


function OrdinateurMultiprocesseurSimuleSurUnMonoprocesseur : boolean;
begin
  OrdinateurMultiprocesseurSimuleSurUnMonoprocesseur := (numProcessors > MPProcessorsScheduled);
end;


////////// EXEMPLE DE CODE D'APPLE : CALCULATING INTERTASK SIGNALING TIME ////////////



type reflectOPType = (aQueue, aSemaphore, anEvent);

var reflectOP : reflectOPType;
    waiterID, postID : MPOpaqueID;


function Reflector(parameter : univ Ptr) : OSStatus;
var p1, p2, p3 : Ptr;
    events : MPEventFlags;
    err : OSStatus;
begin {$UNUSED parameter}
  while (true) do
    begin
    
      case reflectOP of 
        aQueue :     err := MPWaitOnQueue(MPQueueID(waiterID),@p1,@p2,@p3,kDurationForever);
        aSemaphore : err := MPWaitOnSemaphore(MPSemaphoreID(waiterID),kDurationForever);
        anEvent :    err := MPWaitForEvent(MPEventID(waiterID), @events,kDurationForever);
        otherwise    return (-123);
      end; {case}
      
      case reflectOP of 
        aQueue :     err := MPNotifyQueue(MPQueueID(postID),p1,p2,p3);
        aSemaphore : err := MPSignalSemaphore(MPSemaphoreID(postID));
        anEvent :    err := MPSetEvent(MPEventID(postID), $01010101);
        otherwise    return (-123);
      end; {case}
      
    end;
  
  return (-123);
end;







procedure CalculateIntertaskSignalingTime;
var err : OSStatus;
    task : MPTaskID;
    count,i : SInt32;
    p1,p2,p3 : Ptr;
    events : MPEventFlags;
begin

  WritelnDansRapport('entrée dans CalculateIntertaskSignalingTime…');
  WritelnDansRapport('');
  
  if not(MPLibraryIsLoaded) then
    begin
      WritelnDansRapport('The MP library did not load.');
      exit(CalculateIntertaskSignalingTime);
    end;
    
    WritelnDansRapport('Librairie multiprocessing chargée...   OK');
    
    
    // QUEUES
    
    WritelnDansRapport('');
    WritelnDansRapport('Essai de synchronisation par des QUEUES : ');
    WritelnDansRapport('');
    
    reflectOP := aQueue;
    err := MPCreateQueue(MPQueueID(waiterID));
    err := MPCreateQueue(MPQueueID(postID));
    
    
    WritelnDansRapport('temps de création du process (peut varier significativement) : ');
    WritelnDansRapport('');
    BeginChronometreRelatif(1);
    
    err := MPCreateTask(@Reflector,NIL,0,NIL,NIL,NIL,kNilOptions,@task);
    
    StopChronometreRelatif(1);
    
    if (err <> noErr) then
      begin
        WritelnDansRapport('Task not created.');
        exit(CalculateIntertaskSignalingTime);
      end;
    
    WritelnDansRapport('temps de 100000 synchronisation (queues) : ');
    WritelnDansRapport('');
    BeginChronometreRelatif(2);
    
    count := 100000;
    for i := 1 to count do
      begin
        err := MPNotifyQueue(MPQueueID(waiterID),NIL,NIL,NIL);
        repeat
          err := MPWaitOnQueue(MPQueueID(postID),@p1,@p2,@p3,kDurationImmediate);
        until (err <> kMPTimeoutErr);
      end;
    
    StopChronometreRelatif(2);
    
    err := MPTerminateTask(task, 123);
    
  
    // SEMAPHORE
    
    WritelnDansRapport('');
    WritelnDansRapport('Essai de synchronisation par des SEMAPHORES : ');
    WritelnDansRapport('');
    
    reflectOP := aSemaphore;
    err := MPCreateSemaphore(1,0,MPSemaphoreID(waiterID));
    err := MPCreateSemaphore(1,0,MPSemaphoreID(postID));
    
    WritelnDansRapport('temps de création du process (peut varier significativement) : ');
    WritelnDansRapport('');
    BeginChronometreRelatif(3);
    
    err := MPCreateTask(@Reflector,NIL,0,NIL,NIL,NIL,kNilOptions,@task);
    
    StopChronometreRelatif(3);
    
    if (err <> noErr) then
      begin
        WritelnDansRapport('Task not created.');
        exit(CalculateIntertaskSignalingTime);
      end;
    
    WritelnDansRapport('temps de 100000 synchronisation (sémaphores) : ');
    WritelnDansRapport('');
    BeginChronometreRelatif(4);
    
    count := 100000;
    for i := 1 to count do
      begin
        err := MPSignalSemaphore(MPSemaphoreID(waiterID));
        repeat
          err := MPWaitOnSemaphore(MPSemaphoreID(postID),kDurationImmediate);
        until (err <> kMPTimeoutErr);
      end;
    
    StopChronometreRelatif(4);
    
    err := MPTerminateTask(task, 123);
    
    
    // EVENT GROUP
    
    WritelnDansRapport('');
    WritelnDansRapport('Essai de synchronisation par des EVENT GROUPS : ');
    WritelnDansRapport('');
    
    reflectOP := anEvent;
    err := MPCreateEvent(MPEventID(waiterID));
    err := MPCreateEvent(MPEventID(postID));
    
    WritelnDansRapport('temps de création du process (peut varier significativement) : ');
    WritelnDansRapport('');
    BeginChronometreRelatif(5);
    
    err := MPCreateTask(@Reflector,NIL,0,NIL,NIL,NIL,kNilOptions,@task);
    
    StopChronometreRelatif(5);
    
    if (err <> noErr) then
      begin
        WritelnDansRapport('Task not created.');
        exit(CalculateIntertaskSignalingTime);
      end;
    
    WritelnDansRapport('temps de 100000 synchronisation (event groups) : ');
    WritelnDansRapport('');
    BeginChronometreRelatif(6);
    
    count := 100000;
    for i := 1 to count do
      begin
        err := MPSetEvent(MPEventID(waiterID),$01);
        repeat
          err := MPWaitForEvent(MPEventID(postID),@events,kDurationImmediate);
        until (err <> kMPTimeoutErr);
      end;
    
    StopChronometreRelatif(6);
    
    err := MPTerminateTask(task, 123);
    
    WritelnDansRapport('');
    WritelnDansRapport('Sortie de CalculateIntertaskSignalingTime');
end;
 


{$pragmac  optimization_level reset }  



END.






















































