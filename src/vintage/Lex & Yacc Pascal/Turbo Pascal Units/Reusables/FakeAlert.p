{	In-memory item list for dialog with four items:}{	1	"^0^1^2^3" (static text)}{	2	Button 1}{	3	Button 2}{	4	Button 3}{	The caller of FakeAlert passes the four strings that are to be}{	substituted into the first item, the number of buttons that}{	should be used, and the titles to put into each button.}{	A copy of the item list is hacked to use the right number of}{	buttons.}{	Thanks to Erik Kilk and Jason Haines.  Some of the stuff to do}{	this is modified from code they wrote.}{	Ported to LightSpeed Pascal 8 January 1987 Owen Hartnett	}{	Some modifications by Ingemar Ragnemalm 1993:}{	¥ Filter function for default button framing and cmd-period support.}{	¥ Adding parameters for the new functions}{	¥ Simpler calls for common usages.}{Change sept -95: Centers the dialog.}unit FakeAlert;interface{$IFC UNDEFINED THINK_PASCAL}	uses		Types, QuickDraw, Windows, Dialogs, ToolUtils, Events, Controls, {}		Memory, Sound, OSUtils, MixedMode;{$ELSEC}{$SETC GENERATINGPOWERPC:=false }{$ENDC}	function FakeAlert (s1, s2, s3, s4: Str255; nButtons, defButton, cancelButton: Integer; t1, t2, t3: Str255): Integer;	procedure ReportStr (str: str255);	function QuestionStr (str: str255): Boolean;implementation{$IFC UNDEFINED THINK_PASCAL}{$ELSEC}	procedure GetDialogItem (theDialog: DialogPtr; itemNo: INTEGER; var itemType: INTEGER; var item: Handle; var box: Rect);	inline		$A98D;	procedure SetControlTitle (theControl: ControlHandle; title: Str255);	inline		$A95F;{$ENDC}	var		itemList: array[0..32] of integer;		savePort: GrafPtr;		theDialog: DialogPtr;		iListHandle: Handle;		bounds: Rect;		itemHit: integer;		gDefButton, gCancelButton: integer;{process return and command-period}	function Filter (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			theChar: Char;			kind: integer;			item: Handle;			box: Rect;	begin		if theEvent.what = keyDown then			begin				theChar := Char(BitAnd(theEvent.message, charCodeMask));				if BitAnd(theEvent.modifiers, cmdkey) <> 0 then					if theChar = '.' then						begin							itemHit := gCancelButton + 1;							GetDialogItem(theDialog, gCancelButton + 1, kind, item, box);							HiliteControl(ControlHandle(item), 1);							Filter := true;							exit;						end;				if (theChar = char(13)) or (theChar = char(3)) then					begin						itemHit := gDefButton + 1;						GetDialogItem(theDialog, gDefButton + 1, kind, item, box);						HiliteControl(ControlHandle(item), 1);						Filter := true;						exit;					end;			end;		Filter := false;	end;	procedure InitItemList;{This proc performs static initializations on ItemList	}	begin		itemList[0] := 3;					{ max number of items - 1 }		itemList[1] := 0;					{	statText item}										{ reserve a long for item handle }		itemList[2] := 0;					{ display rectangle }{(bounds, 115, 80, 355, 220)}		itemList[3] := 10; {top = 10}		itemList[4] := 27; {left = 27}{if nButtons > 2 then itemList[5] := 61 else}		itemList[5] := 90; {bot = 61}		itemList[6] := 225; {right = 225}		itemList[7] := $8808;	{ 8 + 128 = statText (disabled), title 8 bytes long }		itemList[8] := $5e30;	{ ^0^1^2^3 }		itemList[9] := $5e31;		itemList[10] := $5e32;		itemList[11] := $5e33;{	first button}		itemList[12] := 0;				{ reserve a long for item handle }		itemList[13] := 0;		itemList[14] := 104;				{ display rectangle }		itemList[15] := 140;		itemList[16] := 124;		itemList[17] := 210;		itemList[18] := $400;		{ 4 = pushButton, title is 0 bytes long}{	second button}		itemList[19] := 0;				{ reserve a long for item handle }		itemList[20] := 0;		itemList[21] := 104;				{ display rectangle }		itemList[22] := 30;		itemList[23] := 124;		itemList[24] := 100;		itemList[25] := $400;		{ 4 = pushButton, title is 0 bytes long}{	third button}		itemList[26] := 0;				{ reserve a long for item handle }		itemList[27] := 0;		itemList[28] := 72;				{ display rectangle }		itemList[29] := 30;		itemList[30] := 92;		itemList[31] := 100;		itemList[32] := $400;		{ 4 = pushButton, title is 0 bytes long}	end;{	Set dialog button title and draw bold outline if makeBold true.}{	This must be done after the window is shown or else the bold}{	outline won't show up (which is probably the wrong way to do it).}	procedure SetDControl (theDialog: DialogPtr; itemNo: integer; title: Str255; makeBold: Boolean);		var			itemHandle: Handle;			itemType: integer;			itemRect: Rect;			pState: PenState;	begin		GetDialogItem(theDialog, itemNo, itemType, itemHandle, itemRect);		SetControlTitle(ControlHandle(itemHandle), title);		if makeBold then			begin				GetPenState(pState);				PenNormal;				PenSize(3, 3);				InsetRect(itemRect, -4, -4);				FrameRoundRect(itemRect, 16, 16);				SetPenState(pState);			end;	end;{	Fake an alert, using an in-memory window and item list.}{	The message to be presented is constructed from the first}{	four arguments.  nButtons is the number of buttons to use,}{	defButton is the default button, the next three args are}{	the titles to put into the buttons.  The return value is}{	the button number (1..nButtons).  This must be interpreted}{	by the caller, since the buttons may be given arbitrary}{	titles.}{	nButtons should be between 1 and 3, inclusive.}{	defButton should be between 1 and nButtons, inclusive.}	function FakeAlert (s1, s2, s3, s4: Str255; nButtons, defButton, cancelButton: integer; t1, t2, t3: Str255): integer;		var			savePort: GrafPtr;			theDialog: DialogPtr;			iListHandle: Handle;			bounds: Rect;			itemHit: integer;{$IFC GENERATINGPOWERPC }			filterProc: ProcPtr;{$ENDC}		procedure ExitOnError;		begin			SysBeep(1);			exit;		end;	begin		gDefButton := defbutton;		gCancelButton := cancelbutton;		InitItemList;		if nButtons > 2 then			itemList[5] := itemList[28] - 3;	{Bottom edge of text must not overlap button}		InitCursor;		GetPort(savePort);		iListHandle := NewHandle(longint(512));		if iListHandle = nil then			ExitOnError;		HLock(iListHandle);		itemList[0] := nButtons;								{ = number items - 1 }		BlockMove(@itemList[0], iListHandle^, longint(512));		SetRect(bounds, 115, 80, 355, 220);{Center!}		OffsetRect(bounds, -bounds.left, -bounds.top);{$IFC UNDEFINED THINK_PASCAL}		OffsetRect(bounds, -(bounds.right - bounds.left) div 2 + (qd.screenBits.Bounds.right - qd.screenBits.bounds.left) div 2, 0);		OffsetRect(bounds, 0, -(bounds.bottom - bounds.top) div 2 + (qd.screenBits.Bounds.bottom - qd.screenBits.bounds.top - 20) div 2 + 20);{$ELSEC}		OffsetRect(bounds, -(bounds.right - bounds.left) div 2 + (screenBits.Bounds.right - screenBits.bounds.left) div 2, 0);		OffsetRect(bounds, 0, -(bounds.bottom - bounds.top) div 2 + (screenBits.Bounds.bottom - screenBits.bounds.top - 20) div 2 + 20);{$ENDC}		theDialog := NewDialog(nil, bounds, '', false, dBoxProc, WindowPtr(-1), false, longint(0), iListHandle);		if theDialog = nil then			ExitOnError;		ParamText(s1, s2, s3, s4);							{ construct message }		SetPort(theDialog);		ShowWindow(theDialog);		case nButtons of				{ set button titles }			3:				begin					SetDControl(theDialog, 4, t3, defButton = 3);					SetDControl(theDialog, 3, t2, defButton = 2);					SetDControl(theDialog, 2, t1, defButton = 1);				end;			2:				begin					SetDControl(theDialog, 3, t2, defButton = 2);					SetDControl(theDialog, 2, t1, defButton = 1);				end;			1:				SetDControl(theDialog, 2, t1, defButton = 1);		end;{	ModalDialog returns 1 if return/enter hit, which, since}{	the statText item is first, can be unambiguously}{	interpreted as "choose default".}{$IFC GENERATINGPOWERPC }		filterProc := NewRoutineDescriptor(@Filter, uppModalFilterProcInfo, GetCurrentISA);		ModalDialog(filterProc, itemHit);{$ELSEC}		ModalDialog(@Filter, itemHit);{$ENDC}		if itemHit = 1 then			itemHit := defButton		else			itemHit := itemHit - 1;		HUnlock(iListHandle);		DisposeDialog(theDialog);		SetPort(savePort);		FakeAlert := itemHit;	end;{Single text message:}	procedure ReportStr (str: str255);		var			itemHit: integer;	begin		itemHit := FakeAlert(str, '', '', '', 1, 1, 0, 'OK', '', '');{itemHit := SATFakeAlert(str, '', '', '', 1, 1, 0, SATokStr, '', '');}	end;{A yes/no question:}	function QuestionStr (str: str255): boolean;	begin		QuestionStr := 1 = FakeAlert(str, '', '', '', 2, 1, 2, 'Yes', 'No', '');{QuestionStr := 1 = SATFakeAlert(str, '', '', '', 2, 1, 2, SATyesStr, SATnoStr, '');}	end;end.