UNIT UnitCFMLateImportFromMachO;INTERFACE{     File:       CFMLateImportFromMachOBundle.p                                                        }{                                                                                                       }{     Contains:   Some CodeWarrior Pascal translated code extracted from CallMachOFramework.c included  }{                 in Apple's CallMachOFramework sample code package CallMachOFramework.                 }{                                                                                                       }{     Version:    1.0b1                                                                                 }{                                                                                                       }{     Pascal Translation:  Gale Paeper, <gpaeper@empirenet.com>, 2004                                   }{                                                                                                       }{     Copyright:  Subject to the constraints of Apple's original rights, you're free to use this        }{                 translation as you deem fit.                                                          }{                                                                                                       }{     Bugs?:      This is an AS IS translation with no express guarentees of any kind.                  }{                 If you do find a bug, please help out the Macintosh Pascal programming community by   }{                 reporting your bug finding and possible fix to either personal e-mail to Gale Paeper  }{                 or a posting to the MacPascal mailing list.                                           }{ Translation assisted by: }{This file was processed by Dan's Source Converter}{version 1.3 (this version modified by Ingemar Ragnemalm)}{ The original source on which this interface unit is based: }{	File:		CallMachOFramework.c	Contains:	Sample showing how to call Mach-O frameworks from CFM.	Written by:	Quinn	Copyright:	Copyright © 2000 by Apple Computer, Inc., All Rights Reserved.	Disclaimer:	IMPORTANT:  This Apple software is supplied to you by Apple Computer, Inc.				("Apple") in consideration of your agreement to the following terms, and your				use, installation, modification or redistribution of this Apple software				constitutes acceptance of these terms.  If you do not agree with these terms,				please do not use, install, modify or redistribute this Apple software.				In consideration of your agreement to abide by the following terms, and subject				to these terms, Apple grants you a personal, non-exclusive license, under Apple’s				copyrights in this original Apple software (the "Apple Software"), to use,				reproduce, modify and redistribute the Apple Software, with or without				modifications, in source and/or binary forms; provided that if you redistribute				the Apple Software in its entirety and without modifications, you must retain				this notice and the following text and disclaimers in all such redistributions of				the Apple Software.  Neither the name, trademarks, service marks or logos of				Apple Computer, Inc. may be used to endorse or promote products derived from the				Apple Software without specific prior written permission from Apple.  Except as				expressly stated in this notice, no other rights or licenses, express or implied,				are granted by Apple herein, including but not limited to any patent rights that				may be infringed by your derivative works or by other works in which the Apple				Software may be incorporated.				The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NO				WARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIED				WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULAR				PURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN				COMBINATION WITH YOUR PRODUCTS.				IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL OR				CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE				GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)				ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION				OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OF CONTRACT, TORT				(INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IF APPLE HAS BEEN				ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.	Change History (most recent first):         <1>     21/9/01    Quinn   First checked in.  }USES CFMLateImport, MacTypes, CodeFragments, CFBundle, CFString;FUNCTION FragmentInit( {CONST}VAR initBlock: CFragInitBlock): OSErr;{ The CFMLateImport approach requires that you define a fragment  initialisation routine that latches the fragment's connection  ID and locator.  If your code already has a fragment initialiser  you will have to integrate the implementation function block's contents into it.}{GRP note: The CFMLateImport approach also uses a reference to the fragment initialisation routine to get critical fragment relocation information.  The CFMLateImport routines require passing a pointer/reference to the fragment initialisation routine as a parameter and the actual parameter must be a reference to the initialization routine set (and used) for the fragment being fixed by the CFMLateImport routines.}FUNCTION CFMLateImportMachOBundle(MachOFrameworkName: ConstStr255Param;                                  WeakLinkedLibraryName: ConstStr255Param;                                  fragToFixInitRoutine: CFragInitFunction): OSErr;{Pascal string based wrapper function which consolidates the necessary pieces from the CallMachOFramework.c sample code into one easier to use function. WARNING: Due the methods employed by the CFMLateImport routines, a fragment can only be fixed once per WeakLinkedLibraryName.  At present, this function has no error checking which guards against this condition. The fixup only once per WeakLinkedLibraryName restriction also implies the CFMLateImport routines can only fixup all imported symbols from the weak linked library only if all the symbols are found in one Mach-O framework bundle.  Because of this limitation, a weak import stub library used for late CFM symbol importing should contain only symbols found in one framework bundle.  If a program needs to late import symbols from several framework bundles, just use a seperate import stub library for each of framework bundle.}IMPLEMENTATIONUSES CFBase, CFURL, GestaltEqu, Files, Folders, MacErrors;VAR  gFragToFixConnID : CFragConnectionID;  gFragToFixFile   : fileInfo;  gFragToFixLocator: CFragSystem7DiskFlatLocator;	{$IFC NOT DEFINED DEBUG_CFMLATEIMPORT}  {$SETC DEBUG_CFMLATEIMPORT := FALSE}{$ENDC}FUNCTION FragmentInit( {CONST}VAR initBlock: CFragInitBlock): OSErr;{ The CFMLateImport approach requires that you define a fragment  initialisation routine that latches the fragment's connection  ID and locator.  If your code already has a fragment initialiser  you will have to integrate the following into it.}BEGIN  {$IFC DEBUG_CFMLATEIMPORT}  IF initBlock.fragLocator.where <> kDataForkCFragLocator THEN DebugStr('FragmentInit assertion failure');  {$ENDC}  gFragToFixConnID := CFragConnectionID(initBlock.closureID);  gFragToFixFile := initBlock.fragLocator.onDisk.fileSpec^;  gFragToFixLocator := initBlock.fragLocator.onDisk;  gFragToFixLocator.fileSpec := @gFragToFixFile;  FragmentInit := noErr;END;FUNCTION LoadFrameworkBundle(framework: CFStringRef;                             VAR bundlePtr: CFBundleRef): OSStatus;{ This routine finds a the named framework and creates a CFBundle  object for it.  It looks for the framework in the frameworks folder,  as defined by the Folder Manager.  Currently this is  "/System/Library/Frameworks", but we recommend that you avoid hard coded  paths to ensure future compatibility.  You might think that you could use CFBundleGetBundleWithIdentifier but  that only finds bundles that are already loaded into your context.  That would work in the case of the System framework but it wouldn't  work if you're using some other, less-obvious, framework.}VAR  err                : OSStatus;  frameworksFolderRef: FSRef;  baseURL            : CFURLRef;  bundleURL          : CFURLRef;BEGIN  bundlePtr := NIL;  baseURL := NIL;  bundleURL := NIL;  { Find the frameworks folder and create a URL for it.}  err := FSFindFolder(kOnAppropriateDisk, kFrameworksFolderType, TRUE,                      frameworksFolderRef);  IF (err = noErr) THEN    BEGIN    baseURL := CFURLCreateFromFSRef(NIL, frameworksFolderRef);    IF (baseURL = NIL) THEN err := coreFoundationUnknownErr;    END;  { Append the name of the framework to the URL.}  IF err = noErr THEN    BEGIN    bundleURL := CFURLCreateCopyAppendingPathComponent(NIL, baseURL,                                                       framework, false);    IF bundleURL = NIL THEN err := coreFoundationUnknownErr;    END;  { Create a bundle based on that URL and load the bundle into memory.    We never unload the bundle, which is reasonable in this case because    the sample assumes that you'll be calling functions from this    framework throughout the life of your application.	}  IF err = noErr THEN    BEGIN    bundlePtr := CFBundleCreate(NIL, bundleURL);    IF bundlePtr = NIL THEN err := coreFoundationUnknownErr;    END;  IF err = noErr THEN    IF NOT CFBundleLoadExecutable(bundlePtr) THEN err := coreFoundationUnknownErr;  { Clean up.}  IF (err <> noErr) AND (bundlePtr <> NIL) THEN    BEGIN    CFRelease(CFTypeRef(bundlePtr));    bundlePtr := NIL;    END;  IF bundleURL <> NIL THEN CFRelease(CFTypeRef(bundleURL));  IF baseURL <> NIL THEN CFRelease(CFTypeRef(baseURL));  LoadFrameworkBundle := err;END;FUNCTION CFMLateImportMachOBundle(MachOFrameworkName: ConstStr255Param;                                  WeakLinkedLibraryName: ConstStr255Param;                                  fragToFixInitRoutine: CFragInitFunction): OSErr;{Pascal string based wrapper function which consolidates the necessary pieces from the CallMachOFramework.c sample code into one easier to use function. WARNING: Due the methods employed by the CFMLateImport routines, a fragment can only be fixed once per WeakLinkedLibraryName.  At present, this function has no error checking which guards against this condition. The fixup only once per WeakLinkedLibraryName restriction also implies the CFMLateImport routines can only fixup all imported symbols from the weak linked library  only if all the symbols are found in one Mach-O framework bundle.  Because of this limitation, a import stub library used for late CFM symbol importing should contain only symbols found in one framework bundle.  If a program needs to late import symbols from several framework bundles, just use a seperate import stub library for each of framework bundle.}VAR  MachOFrameworkNameCFRef : CFStringRef;  MachOFrameworkBundleRef : CFBundleRef;  err                     : OSStatus;BEGIN  { Start by creating a CFBundle for the framework of interest.         }  {                                                                     }  { IMPORTANT:                                                          }  { You should name the correct framework!                              }  {                                                                     }  { It's easy to work out the correct framework:                        }  {                                                                     }  { 1. Use the name of the umbrella framework (ie the highest level     }  {    framework) that contains the header file which declares the      }  {    functions you need.                                              }  {                                                                     }  { 2. If the header file is outside of a framework (for example,       }  {    in /usr/include), the function probably resides in the           }  {    System framework. Use the "nm" command line tool to confirm this.}  err := noErr;  MachOFrameworkNameCFRef := CFStringCreateWithPascalString(NIL, MachOFrameworkName,                                                            CFStringGetSystemEncoding);  IF MachOFrameworkNameCFRef = NIL THEN err := coreFoundationUnknownErr;  IF err = noErr THEN    err := LoadFrameworkBundle(MachOFrameworkNameCFRef, MachOFrameworkBundleRef);  {Then fixup the late import symbols.}  IF err = noErr THEN    err := CFMLateImportBundle(gFragToFixLocator, gFragToFixConnID, fragToFixInitRoutine,                               WeakLinkedLibraryName, MachOFrameworkBundleRef);  { Clean up.}  IF MachOFrameworkNameCFRef <> NIL THEN CFRelease(CFTypeRef(MachOFrameworkNameCFRef));		CFMLateImportMachOBundle := err;END;END.