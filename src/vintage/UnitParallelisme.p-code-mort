
function FaireQuelqueChoseDIntelligentAvecLaThreadDuFils(var node : NoeudDeParallelisme; nroThreadDuFils : SInt32; var nroThreadFilsDisponible : SInt32) : SInt32;
var foo_bar_atomic_register : SInt32;
    err : OSErr;
    microSecondesFin : UnsignedWide;
    microSecondesDepart : UnsignedWide;
    etatDuFils : SInt32;
begin

  with node do
    begin

      MicroSeconds(microSecondesDepart);

      if ThreadEstInterrompue(nroThreadDuPere,nbreVides)
        then
          begin
            InterrompreUnFils(node,nroThreadDuFils);

            // le fils dont on vient de recevoir le resultat ne nous servira plus
            ATOMIC_DECREMENT_32(gNbreProcesseursCalculant);


            {$IFC AVEC_DEBUG_PARALLELISME}
            if DoitDebugguerParallelismeDansRapport then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('La thread '+IntToStr(nroThreadDuPere)+' est inetrrompue et vient d''interrompre sa thread fille = ',nroThreadDuFils);
                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                WritelnDansRapport('');
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
          end


        else
      if (nroDuFilsCourant >= filsFin)
        then
          begin
            EnleverLaReservationDUneThread(node,nroThreadDuFils);

            // on a fini de lancer tous les fils, donc le fils dont on vient de recevoir le resultat ne nous servira plus
            ATOMIC_DECREMENT_32(gNbreProcesseursCalculant);


            {$IFC AVEC_DEBUG_PARALLELISME}
            if DoitDebugguerParallelismeDansRapport then
              begin
                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                WritelnNumDansRapport('La thread '+IntToStr(nroThreadDuPere)+' a lancé tous les fils possibles et vient d''enlever le spin-lock de sa thread fille = ',nroThreadDuFils);
                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                WritelnDansRapport('');
                AttendreFrappeClavierParallelisme(true);
                err := MPExitCriticalRegion(gRapportCriticalRegionID);
              end;
            {$ENDC}
          end


        else
          begin
            // on va sans doute reutiliser immediatement la thread du fils dont on vient de recevoir le resultat

            if (gNbreProcesseursCalculant <= numProcessors)
              then
                begin


                  if ATOMIC_COMPARE_AND_SWAP_32(kPleaseDoSpinLock,kPleaseDoSpinLock,gAlphaBetaTasksData^[nroThreadDuFils].etat) <> 0
                    then
                      begin

                        {$IFC AVEC_DEBUG_PARALLELISME}
                        if DoitDebugguerParallelismeDansRapport then
                          begin
                            err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                            WritelnStringDansRapport('La thread '+IntToStr(nroThreadDuPere)+' a encore des fils à lancer,');
                            WritelnNumDansRapport('mais peut recycler sa thread fille qui attend en spin-lock :-)  nroThreadDuFils = ',nroThreadDuFils);
                            WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                            WritelnDansRapport('');
                            err := MPExitCriticalRegion(gRapportCriticalRegionID);
                          end;
                        {$ENDC}

                        PreparerUnTravailPourLaThreadAuChomage(node,nroThreadDuFils);

                        if gCheckingResultsHasHighPriority then
                          begin

                            // Ecouter eventuellement d'autres resultats
                            if (nbreResultatsEnAttente > 0) then
                              begin

                                if GetAResultAtThisDepthAndLock(nroThreadDuPere,nbreVides)
                                  then
                                    begin
                                      MicroSeconds(microSecondesFin);
                                      gProfilerParallelisme[7] := gProfilerParallelisme[7] + (microSecondesFin.lo-microSecondesDepart.lo);

                                      FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kRECEVOIR_UN_NOUVEAU_RESULTAT;
                                      exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                                    end;

                              end;
                          end;

                        MicroSeconds(microSecondesFin);
                        gProfilerParallelisme[8] := gProfilerParallelisme[8] + (microSecondesFin.lo-microSecondesDepart.lo);

                        FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kTROUVER_D_AUTRES_TACHES_AU_CHOMAGE;
                        exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                      end
                    else

                  if ATOMIC_COMPARE_AND_SWAP_32(kPleaseGoSleeping,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadDuFils].etat) = 0
                    then
                      begin

                        etatDuFils := gAlphaBetaTasksData^[nroThreadDuFils].etat;

                        InterrompreUnFils(node,nroThreadDuFils);

                        if PeutTrouverUneThreadDisponible(nroThreadDuPere,nroThreadFilsDisponible) then
                          begin
                            ATOMIC_DECREMENT_32(gNbreProcesseursCalculant);


                            {$IFC USE_ASSERTIONS_DE_PARALLELISME}
                            if gUseSpinLocks then
                              begin
                                err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                                WritelnStringDansRapport('ASSERT !! La thread '+IntToStr(nroThreadDuPere)+' a encore des fils à lancer,');
                                WriteDansRapport('mais n''a pas pu reutiliser son ancienne thread fille, qui n''était pas en spin-lock !!!!');
                                WritelnDansRapport('(nroThreadDuFils,etat) = ('+IntToStr(nroThreadDuFils)+','+IntToStr(etatDuFils)+')');
                                WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                                WritelnDansRapport('');
                                AttendreFrappeClavierParallelisme(true);
                                err := MPExitCriticalRegion(gRapportCriticalRegionID);
                              end;
                            {$ENDC}

                            PreparerUnTravailPourLaThreadAuChomage(node,nroThreadFilsDisponible);

                            if gCheckingResultsHasHighPriority then
                              begin

                                // Ecouter eventuellement d'autres resultats
                                if (nbreResultatsEnAttente > 0) then
                                  begin
                                    if GetAResultAtThisDepthAndLock(nroThreadDuPere,nbreVides)
                                      then
                                        begin
                                          MicroSeconds(microSecondesFin);
                                          gProfilerParallelisme[9] := gProfilerParallelisme[9] + (microSecondesFin.lo-microSecondesDepart.lo);

                                          FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kRECEVOIR_UN_NOUVEAU_RESULTAT;
                                          exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                                        end;
                                  end;
                              end;

                            MicroSeconds(microSecondesFin);
                            gProfilerParallelisme[10] := gProfilerParallelisme[10] + (microSecondesFin.lo-microSecondesDepart.lo);

                            FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kTROUVER_D_AUTRES_TACHES_AU_CHOMAGE;
                            exit(FaireQuelqueChoseDIntelligentAvecLaThreadDuFils);
                          end;
                      end;
                end
              else
                begin
                  if ATOMIC_COMPARE_AND_SWAP_32(kPleaseGoSleeping,kPleaseGoSleeping,gAlphaBetaTasksData^[nroThreadDuFils].etat) = 0 then
                    begin
                      InterrompreUnFils(node,nroThreadDuFils);

                      ATOMIC_DECREMENT_32(gNbreProcesseursCalculant);


                      {$IFC AVEC_DEBUG_PARALLELISME}
                      if DoitDebugguerParallelismeDansRapport then
                        begin
                          err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                          WritelnStringDansRapport('La thread '+IntToStr(nroThreadDuPere)+' a encore des fils à lancer,');
                          WritelnNumDansRapport('mais n''a pas trouvé de processeur disponible et vient d''interrompre brutalement sa thread fille = ',nroThreadDuFils);
                          WritelnNumDansRapport('gNbreProcesseursCalculant = ',gNbreProcesseursCalculant);
                          WritelnDansRapport('');
                          err := MPExitCriticalRegion(gRapportCriticalRegionID);
                        end;
                      {$ENDC}

                    end;
                end;
        end;

    end;  {with node do}

    FaireQuelqueChoseDIntelligentAvecLaThreadDuFils := kCONTINUER_NORMALEMENT;
end;







LANCER_UNE_PROPOSITION_DE_TRAVAIL :




          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('Je suis prete a travailler, je suis la thread numero : ',nroThread);
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}




ATTENDRE_SUR_LE_SEMAPHORE :




          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnStringDansRapport('La thread '+IntToStr(nroThread)+' se met en attente sur son semaphore de sommeil');
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}






          compteur := 0;
          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) then
               while (ATOMIC_COMPARE_AND_SWAP_32(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) do
                  begin
                  end;







ATTENDRE_LA_PREPARATION_D_UN_JOB :


          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnStringDansRapport('La thread '+IntToStr(nroThread)+' se met en attente pendant la preparation d''un job');
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}




          compteur := 0;
          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseWaitForJobPreparation,kPleaseWaitForJobPreparation,etat) <> 0 ) then
               while (ATOMIC_COMPARE_AND_SWAP_32(kPleaseWaitForJobPreparation,kPleaseWaitForJobPreparation,etat) <> 0 ) do
                 begin
                 end;



          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) then
            begin
              message := kPleaseGoSleeping;
              goto LANCER_UNE_PROPOSITION_DE_TRAVAIL;
            end;


EXPLORER_UN_SOUS_ARBRE :



          if (message = kPleaseExploreThisSubtree) & (ATOMIC_COMPARE_AND_SWAP_32(kPleaseExploreThisSubtree,kPleaseExploreThisSubtree,etat) <> 0)
            then
              begin

                // Chouette, on a du boulot !

                EnleverLInterruptionPourCetteThread(nroThread, profondeurSubTree);


                {$IFC AVEC_DEBUG_PARALLELISME}
                if DoitDebugguerParallelismeDansRapport then
                  begin
                    err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                    WritelnStringDansRapport('La thread '+IntToStr(nroThread)+' a du boulot et va appeler MySubTreeValue');
                    WritelnDansRapport('');
                    AttendreFrappeClavierParallelisme(true);
                    err := MPExitCriticalRegion(gRapportCriticalRegionID);
                  end;
                {$ENDC}


                // Lancer le calcul du sous-arbre
                valeur := MySubTreeValue( positionSubTree, profondeurSubTree, alphaSubTree, betaSubTree, diffPionsSubTree, vecteurPariteSubTree, nroThread, threadDuPere, listeBitboardSubTree);



                {$IFC AVEC_DEBUG_PARALLELISME}
                if DoitDebugguerParallelismeDansRapport then
                  begin
                    err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                    WritelnNumDansRapport('La thread '+IntToStr(nroThread)+' vient de sortir de MySubTreeValue, valeur = ',-valeur);
                    WritelnDansRapport('');
                    AttendreFrappeClavierParallelisme(true);
                    err := MPExitCriticalRegion(gRapportCriticalRegionID);
                  end;
                {$ENDC}


PUBLIER_LE_RESULTAT :




                // Si on n'a pas ete interrompu, donner le resultat du calcul au lanceur



                if not(ThreadEstInterrompue(nroThread, profondeurSubTree)) &
                   (valeur <> kValeurSpecialeInterruptionCalculParallele) &
                   (valeur <> -kValeurSpecialeInterruptionCalculParallele)
                   then
                  begin



                    if gUseSpinLocks
                      then
                        begin
                          // indiquer a la thread qu'elle devra rentrer dans le futur spinlock quand elle aura fini

                          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseExploreThisSubtree,kPleaseDoSpinLock,etat) <> 0) then

                             begin

                               PosterUnResultatAUneThread(threadDuPere, valeur, coupSubTree, hashDuPere, profondeurSubTree + 1);

                             end;
                        end
                      else
                        begin
                          // indiquer a la thread qu'elle devra lancer une proposition de travail puis se bloquer quand elle aura fini

                          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseExploreThisSubtree,kPleaseGoSleeping,etat) <> 0) then

                             begin

                               PosterUnResultatAUneThread(threadDuPere, valeur, coupSubTree, hashDuPere, profondeurSubTree + 1);

                             end;
                        end;



                  end;



                // Si la thread a été interrompue, elle vient de sortir de sa recherche et donc
                // l'interruption a fait son office : on peut l'enlever
                EnleverLInterruptionPourCetteThread(nroThread, profondeurSubTree);

              end;


ATTENTE_ACTIVE_SUR_LE_SPIN_LOCK :




          {$IFC AVEC_DEBUG_PARALLELISME}
          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('La thread '+IntToStr(nroThread)+' a réussi à poster son résultat (si elle en avait) et va rentrer dans le spin-lock, son etat est : ',etat);
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;
          {$ENDC}


          // Il se peut que la thread ait ete interrompue
          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseGoSleeping,kPleaseGoSleeping,etat) <> 0 ) then
            begin
              message := kPleaseGoSleeping;



              goto LANCER_UNE_PROPOSITION_DE_TRAVAIL;
            end;




          // LE SPIN LOCK D'ATTENTE ACTIVE !!

          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseDoSpinLock,kPleaseDoSpinLock,etat) <> 0 ) then
               while (ATOMIC_COMPARE_AND_SWAP_32(kPleaseDoSpinLock,kPleaseDoSpinLock,etat) <> 0 ) do
                 begin
                    {if gSpinLocksYieldTimeToCPU then MPYield;}
                 end;


          if DoitDebugguerParallelismeDansRapport then
            begin
              err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
              WritelnNumDansRapport('La thread '+IntToStr(nroThread)+' vient de sortir de son spin-lock, etat = ',etat);
              WritelnDansRapport('');
              AttendreFrappeClavierParallelisme(true);
              err := MPExitCriticalRegion(gRapportCriticalRegionID);
            end;




          if (ATOMIC_COMPARE_AND_SWAP_32(kPleaseExploreThisSubtree,kPleaseExploreThisSubtree,etat) <> 0) & (message = kPleaseExploreThisSubtree) then
            begin

              if DoitDebugguerParallelismeDansRapport then
                begin
                  err := MPEnterCriticalRegion(gRapportCriticalRegionID,kDurationForever);
                  WritelnStringDansRapport('La thread '+IntToStr(nroThread)+' retrouve immediatement du travail');
                  WritelnDansRapport('');
                  AttendreFrappeClavierParallelisme(true);
                  err := MPExitCriticalRegion(gRapportCriticalRegionID);
                end;


              goto EXPLORER_UN_SOUS_ARBRE;

            end;


          goto LANCER_UNE_PROPOSITION_DE_TRAVAIL;


