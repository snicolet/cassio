unit OOTextEdit;interface	uses		OOStaticEdit;	type		TEEditObject = object(TEStaticObject)				undotext: Handle;				undostart, undoend, undoselstart, undoselend: integer;				undoopen: boolean;				modified: boolean;				procedure Create (dlg: DialogPtr; item, width: integer; vscroll, hscroll, hasgrowb, drawgrowb: boolean);				override;				procedure Destroy;				override;				function EditMenuEnabled: boolean;				override;				procedure SetEditMenuItem (item: integer);				override;				procedure DoItemWhere (er: EventRecord; item: integer);				override;				procedure DoEditMenu (item: integer);				override;				procedure DoKey (modifiers: integer; ch: char);				override;			end;implementation	uses		BaseGlobals, MyTypes, MyUtils;	function DirtyKey (ch: char): boolean;	begin		case ord(ch) of			homeChar, endChar, helpChar, pageUpChar, pageDownChar, leftArrowChar, rightArrowChar, upArrowChar, downArrowChar: 				DirtyKey := false;			otherwise				DirtyKey := true;		end;	end;	procedure TEEditObject.Create (dlg: DialogPtr; item, width: integer; vscroll, hscroll, hasgrowb, drawgrowb: boolean);	begin		inherited Create(dlg, item, width, vscroll, hscroll, hasgrowb, drawgrowb);		undotext := NewHandle(0);		undostart := -1;		undoopen := false;		modified := false;	end;	procedure TEEditObject.Destroy;	begin		DisposHandle(undotext);		inherited Destroy;	end;	function TEEditObject.EditMenuEnabled: boolean;		var			offset: longint;	begin		EditMenuEnabled := (undostart >= 0) or (te^^.selStart < te^^.selEnd) or (GetScrap(nil, 'TEXT', offset) > 0) or (te^^.teLength > 0);	end;	procedure TEEditObject.SetEditMenuItem (item: integer);		var			offset: longint;	begin		case item of			EMundo: 				SetIDItemEnable(M_Edit, item, undostart >= 0);			EMcut, EMclear, EMcopy: 				SetIDItemEnable(M_Edit, item, te^^.selStart < te^^.selEnd);  { Can cut,copy,clear iff there is a selection }			EMpaste: 				SetIDItemEnable(M_Edit, item, GetScrap(nil, 'TEXT', offset) > 0);		{Paste is enabled for app. windows}			EMselectall: 				SetIDItemEnable(M_Edit, item, te^^.teLength > 0);  { Can select all iff there is something to select }			otherwise		end;	end;	procedure CopyUndoSelection (h: Handle; te: TEHandle);	begin		SetHandleSize(h, te^^.selEnd - te^^.selStart);		BlockMove(Ptr(longint(te^^.hText^) + te^^.selStart), h^, te^^.selEnd - te^^.selStart);	end;	procedure TEEditObject.DoEditMenu (item: integer);		var			oe: OSErr;			loe: longint;			th: Handle;			uss, use: integer;	begin		undoopen := false;		case item of			EMcopy, EMselectall: 				inherited DoEditMenu(item);			EMcut:  begin				CopyUndoSelection(undotext, te);				undoselstart := te^^.selStart;				undoselend := te^^.selEnd;				undostart := te^^.selStart;				undoend := undostart;				TECut(te);				loe := ZeroScrap;				oe := TEToScrap;				modified := true;			end;			EMclear:  begin				CopyUndoSelection(undotext, te);				undoselstart := te^^.selStart;				undoselend := te^^.selEnd;				undostart := te^^.selStart;				undoend := undostart;				TEDelete(te);				modified := true;			end;			EMpaste:  begin				oe := TEFromScrap;				if TEGetScrapLen + (te^^.teLength - (te^^.selEnd - te^^.selStart)) > 32000 then					AlertUser(paste_to_big)				else begin					CopyUndoSelection(undotext, te);					undoselstart := te^^.selStart;					undoselend := te^^.selEnd;					undostart := te^^.selStart;					TEPaste(te);					undoend := te^^.selEnd;					modified := true;				end;			end;			EMundo:  begin				uss := undoselstart;				use := undoselend;				undoselstart := te^^.selStart;				undoselend := te^^.selEnd;				th := NewHandle(undoend - undostart);				BlockMove(Ptr(longint(te^^.hText^) + undostart), th^, undoend - undostart); { save undo for redo }				TESetSelect(undostart, undoend, te);				TEDelete(te);				HLock(undotext);				TEInsert(undotext^, GetHandleSize(undotext), te);				DisposHandle(undotext);				undotext := th;				undoend := te^^.selEnd;				TESetSelect(uss, use, te);			end;			otherwise		end;	end;	procedure TEEditObject.DoKey (modifiers: integer; ch: char);		var			dk: boolean;	begin		dk := DirtyKey(ch);		if dk then begin			modified := true;			if not undoopen then begin				CopyUndoSelection(undotext, te);				undoselstart := te^^.selStart;				undoselend := te^^.selEnd;				undostart := te^^.selStart;			end;			inherited DoKey(modifiers, ch);			undoend := te^^.selEnd;		end		else			inherited DoKey(modifiers, ch);		undoopen := dk;	end;	procedure TEEditObject.DoItemWhere (er: EventRecord; item: integer);		var			uss, use: integer;	begin		uss := te^^.selStart;		use := te^^.selEnd;		inherited DoItemWhere(er, item);		if (uss <> te^^.selStart) or (use <> te^^.selEnd) then			undoopen := false;	end;end.