unit MyCollections;interface	uses		Types;	const		no_tag = 0;	type		PermuteArray = array[1..8000] of integer;		PermuteArrayPtr = ^PermuteArray;	type		tagType = OSType;		indexType = longint;		Collection = object				error: OSErr; { PUBLIC }				safeget: boolean; { PUBLIC }				testheap: boolean; { PUBLIC }				data: Handle; { PRIVATE }				size: longint; { PRIVATE }				cnt: indexType; { PRIVATE }				fixed, tagged: boolean; { PRIVATE }				lensize, tagsize: longint; { PRIVATE }				searchindex: indexType; { PRIVATE }				searchtag: tagType; { PRIVATE }				cacheoffset: longint; { PRIVATE }				cachelen: longint; { PRIVATE }				cacheindex: indexType; { PRIVATE }				procedure Create (siz: longint; fix, tag: boolean);				procedure CreateFromHandle (d: Handle);				procedure Destroy;				procedure SetDataHandle (d: Handle);				function GetDataHandle: Handle;				procedure Reset;				function Count: indexType;				function GetTag (index: indexType): tagType;				function GetIndex (tag: tagType): indexType;				procedure SetTag (index: indexType; tag: tagType);				function Exists (index: indexType): boolean;				function ExistsTag (tag: {univ }tagType): boolean;				function Info (index: indexType; var len: longint): boolean;				function InfoTag (tag: {univ } tagType; var len: longint): boolean;				procedure Delete (index: indexType);				procedure DeleteTag (tag: {univ } tagType);				procedure InsertBefore (index: indexType);				procedure Permute (map: PermuteArrayPtr);				procedure AddBoolean (b: boolean);				procedure AddTagBoolean (tag: {univ } tagType; b: boolean);				procedure AddLong (n: univ longint);				procedure AddTagLong (tag: {univ } tagType; n: univ longint);				procedure AddString (const s: Str255);				procedure AddTagString (tag: {univ } tagType; const s: Str255);				procedure AddData (p: Ptr; len: longint);				procedure AddTagData (tag: {univ } tagType; p: Ptr; len: longint);				procedure AddItem (p: Ptr);				procedure AddTagItem (tag: {univ } tagType; p: Ptr);				procedure SetBoolean (index: indexType; b: boolean);				procedure SetTagBoolean (tag: {univ } tagType; b: boolean);				procedure SetLong (index: indexType; n: univ longint);				procedure SetTagLong (tag: {univ } tagType; n: univ longint);				procedure SetString (index: indexType; const s: Str255);				procedure SetTagString (tag: {univ } tagType; const s: Str255);				procedure SetData (index: indexType; p: Ptr; len: longint);				procedure SetTagData (tag: {univ } tagType; p: Ptr; len: longint);				procedure SetItem (index: indexType; p: Ptr);				procedure SetTagItem (tag: {univ } tagType; p: Ptr);				function GetBoolean (index: indexType): boolean;				function GetTagBoolean (tag: {univ } tagType): boolean;				procedure GetLong (index: indexType; var l: univ longint);				procedure GetTagLong (tag: {univ } tagType; var l: univ longint);				function GetString (index: indexType): Str255;				function GetTagString (tag: {univ } tagType): Str255;				procedure GetData (index: indexType; p: Ptr; len: longint);				procedure GetTagData (tag: {univ } tagType; p: Ptr; len: longint);				procedure GetItem (index: indexType; p: Ptr);				procedure GetTagItem (tag: {univ } tagType; p: Ptr);				procedure InvalidateCache;				function GetOffset (index: indexType; var offset: longint; var len: longint): boolean; { PRIVATE }				function GetTagOffset (tag: {univ } tagType; var offset: longint; var len: longint; var index: indexType; test: boolean): boolean; { PRIVATE }				procedure AddChunk (tag: tagType; p: Ptr; len: longint); { PRIVATE }				procedure SetChunk (offset, l: longint; tag: tagType; p: Ptr; len: longint); { PRIVATE }				procedure SetChunkIndex (index: indexType; p: Ptr; len: longint); { PRIVATE }				procedure SetChunkTag (tag: tagType; p: Ptr; len: longint); { PRIVATE }				procedure GetChunkIndex (index: indexType; len: longint; p: Ptr); { PRIVATE }				procedure GetChunkTag (tag: tagType; len: longint; p: Ptr); { PRIVATE }			end;	procedure HackUpdateHandleToCollection (data: Handle);implementation	uses		MyAssertions, MyUtils, MyTypes, MyMemory;{ Format is saved in prefs files, so it must not change! }	const		lsize = 4;		magic_version = $12345678;		fixed_bit = 16;		tagged_bit = 0;		safeget_bit = 1;{$PUSH}{$ALIGN MAC68K}	type		header = record				version: longint;				size: longint;				cnt: indexType;				flags: longint;				space: longint;			end;		headerPtr = ^header;		headerHandle = ^headerPtr;{$ALIGN RESET}{$POP}{ Data format: }{ header}{ [tag (lsize)] [length (lsize)] data }	function LongAtPtr (p: univ LongIntPtr): longint;{$IFC not GENERATINGPOWERPC}	inline		$205F, $224F, $12D8, $12D8, $12D8, $12D8;{ move.l (sp)+,a0 move.l sp,a1, 4*move.b (a0)+,(a1)+ }{$ELSEC}	begin		LongAtPtr:=p^;	end;{$ENDC}	function TagAtPtr (p: univ LongIntPtr): tagType;{$IFC not GENERATINGPOWERPC}	inline		$205F, $224F, $12D8, $12D8, $12D8, $12D8;{ move.l (sp)+,a0 move.l sp,a1, 4*move.b (a0)+,(a1)+ }{$ELSEC}	begin		TagAtPtr:=tagType(p^);	end;{$ENDC}	function EqualTag(t1, t2: OSType): Boolean;	begin		EqualTag := longint(t1) = longint(t2);	end;	procedure HackUpdateHandleToCollection (data: Handle);		var			h: header;			pos: longint;			size: longint;			junk: OSErr;	begin		if (GetHandleSize(data) < SizeOf(header)) or (headerHandle(data)^^.version <> magic_version) then begin			h.version := magic_version;			h.size := -1;			h.flags := 0;			BSET(h.flags, tagged_bit);			BSET(h.flags, safeget_bit);			h.space := 0;			h.cnt := 0;			pos := 0;			while (pos >= 0) and (pos <= GetHandleSize(data) - 8) do begin				h.cnt := h.cnt + 1;				size := LongAtPtr(Ptr(ord(data^) + lsize));				if (size < 0) or (size > 1000) then begin					pos := -1;				end else begin					pos := pos + 8 + size;				end;			end;			if pos <> GetHandleSize(data) then begin				SetHandleSize(data, 0);				h.cnt := 0;			end;			junk := MMungerInsert(data, 0, @h, SizeOf(h));		end;	end;	procedure Collection.Create (siz: longint; fix, tag: boolean);		var			junk: OSErr;	begin		HLock(Handle(self));		junk := MNewHandle( data, SizeOf(header) );		size := siz;		fixed := fix;		tagged := tag;		safeget := false;		testheap := false;		lensize := lsize * ord(not fixed);		tagsize := lsize * ord(tagged);		Reset;	end;	procedure Collection.Destroy;	begin		MDisposeHandle(data);		dispose(self);	end;	function Collection.GetDataHandle: Handle;		var			flags: longint;	begin		headerHandle(data)^^.version := magic_version;		headerHandle(data)^^.size := size;		headerHandle(data)^^.cnt := cnt;		flags := 0;		if fixed then begin			BSET(flags, fixed_bit);		end;		if tagged then begin			BSET(flags, tagged_bit);		end;		if safeget then begin			BSET(flags, safeget_bit);		end;		headerHandle(data)^^.flags := flags;		headerHandle(data)^^.space := 0;		GetDataHandle := data;	end;	procedure Collection.SetDataHandle (d: Handle);		var			flags: longint;	begin		if headerHandle(d)^^.version = magic_version then begin			MDisposeHandle(data);			data := d;			error := noErr;			size := headerHandle(data)^^.size;			cnt := headerHandle(data)^^.cnt;			flags := headerHandle(data)^^.flags;			fixed := BTST(flags, fixed_bit);			tagged := BTST(flags, tagged_bit);			safeget := BTST(flags, safeget_bit);			testheap := false;			lensize := lsize * ord(not fixed);			tagsize := lsize * ord(tagged);			InvalidateCache;		end else begin			Reset;			error := -1;		end;	end;	procedure Collection.CreateFromHandle (d: Handle);		var			junk: OSErr;	begin		junk := MNewHandle( data, SizeOf(header) );		SetDataHandle(d);	end;		procedure Collection.Reset;	begin		error := noErr;		cnt := 0;		SetHandleSize(data, SizeOf(header));		InvalidateCache;	end;	procedure Collection.InvalidateCache;	begin		cacheoffset := -1;	end;	procedure Collection.Permute (map: PermuteArrayPtr);		type			LongArray = array[1..8000] of longint;			LongArrayPtr = ^LongArray;		var			i, j, k: integer;			offset, src, len, handlesize: longint;			dummy: boolean;			newdata: Handle;			offsetptr: LongArrayPtr;			tmpmap: PermuteArrayPtr;			err, junk: OSErr;	begin		handlesize := GetHandleSize(data);		newdata := TempNewHandle(handlesize, err);		if newdata = nil then begin			junk := MNewHandle( newdata, handlesize );		end;		offsetptr := nil;		if newdata <> nil then begin			err := MNewPtr(offsetptr, longint(cnt) * 4);		end;		if offsetptr <> nil then begin			offset := SizeOf(header) + tagsize;			for i := 1 to cnt do begin				offsetptr^[i] := offset - tagsize;				if fixed then begin					offset := offset + size + tagsize;				end else begin					offset := offset + lsize + LongAtPtr(Ptr(ord(data^) + offset)) + tagsize; { Point to next length }				end;			end;			offset := SizeOf(header);			len := size + tagsize + lensize;			for i := 1 to cnt do begin				src := offsetptr^[map^[i]];				if not fixed then begin					len := tagsize + LongAtPtr(Ptr(ord(data^) + src + tagsize)) + lensize;				end;				BlockMoveData(Ptr(ord(data^) + src), Ptr(ord(newdata^) + offset), len);				offset := offset + len;			end;			Assert(offset = handlesize);			BlockMoveData(newdata^, data^, handlesize);			MDisposePtr(offsetptr);			MDisposeHandle(newdata);		end else begin			MDisposeHandle(newdata); { nil safe }			err := MNewPtr( tmpmap, longint(cnt) * SizeOf(map^[1]) );			if err = noErr then begin				BlockMoveData( map, tmpmap, GetPtrSize( Ptr(tmpmap) ) );				for i := 1 to cnt do begin					k := tmpmap^[i];					cacheoffset := -1;					dummy := GetOffset(k, offset, len);					Assert(dummy);					offset := offset - tagsize - lensize;					len := len + tagsize + lensize;					SetHandleSize(data, handlesize + len);					Assert(MemError = noErr);					HLock(data);					BlockMoveData(Ptr(ord(data^) + offset), Ptr(ord(data^) + handlesize), len);					HUnlock(data);					MMungerDelete(data, offset, len);					cacheoffset := -1;					for j := 1 to cnt do begin						if tmpmap^[j] > k then begin							tmpmap^[j] := tmpmap^[j] - 1;						end;					end;				end;				MDisposePtr( tmpmap );			end;		end;		InvalidateCache;	end;	function Collection.GetOffset (index: indexType; var offset: longint; var len: longint): boolean; { PRIVATE }		var			valid: boolean;			i: indexType;	begin		if testheap then begin			DebugStr('GetOffset;hc;g');		end;		valid := (0 < index) and (index <= cnt);		if valid then begin			if fixed then begin				len := size;				offset := SizeOf(header) + (index - 1) * (size + tagsize) + tagsize;			end else begin				if (cacheoffset > 0) and (searchindex > 0) and (searchindex <= index) then begin					offset := cacheoffset - lsize;					i := searchindex;				end else begin					offset := SizeOf(header) + tagsize; { Point to first length }					i := 1;				end;				while (i < index) do begin					offset := offset + lsize + LongAtPtr(Ptr(ord(data^) + offset)) + tagsize; { Point to next length }					i := i + 1;				end;				len := LongAtPtr(Ptr(ord(data^) + offset));				offset := offset + lsize; { Point to data }			end;			cacheoffset := offset;			cachelen := len;			searchindex := index;		end else begin			Assert(false);			InvalidateCache;		end;		GetOffset := valid;	end;	function Collection.GetTagOffset (tag: {univ } tagType; var offset: longint; var len: longint; var index: indexType; test: boolean): boolean; { PRIVATE }		var			valid: boolean;			t: tagType;			handlesize: longint;	begin		if testheap then begin			DebugStr('GetTagOffset;hc;g');		end;		valid := false;		if tagged then begin			if (cacheoffset > 0) and (searchindex < 0) and EqualTag(searchtag, tag) then begin				offset := cacheoffset;				len := cachelen;				index := cacheindex;				valid := true;			end else begin				len := size;				index := 0;				offset := SizeOf(header); { Point to first tag }				handlesize := GetHandleSize(data);				while (not valid) and (index < cnt) do begin					Assert((0 < offset) and (offset < handlesize));					t := TagAtPtr(Ptr(ord(data^) + offset));					if not fixed then begin						len := LongAtPtr(Ptr(ord(data^) + offset + tagsize));					end;					offset := offset + tagsize + lensize + len; { Point to next tag }					index := index + 1;					valid := EqualTag(t, tag);				end;				offset := offset - len; { Point to data }			end;		end;		if not test then begin			Assert(valid);		end;		if valid then begin			cacheoffset := offset;			cachelen := len;			cacheindex := index;			searchindex := -1;			searchtag := tag;		end else begin			InvalidateCache;		end;		GetTagOffset := valid;	end;	function Collection.Count: indexType;	begin		Count := cnt;	end;	function Collection.GetTag (index: indexType): tagType;		var			offset, len: longint;	begin		GetTag := tagType(no_tag);		Assert(tagged);		if GetOffset(index, offset, len) then begin			GetTag := TagAtPtr(Ptr(ord(data^) + offset - lensize - tagsize));		end;	end;	procedure Collection.SetTag (index: indexType; tag: tagType);		var			offset, len: longint;	begin		Assert(tagged);		if GetOffset(index, offset, len) then begin			BlockMoveData(@tag, Ptr(ord(data^) + offset - lensize - tagsize), tagsize);		end;	end;	function Collection.GetIndex (tag: tagType): indexType;		var			offset, len: longint;			index: indexType;	begin		GetIndex := 0;		if GetTagOffset(tag, offset, len, index, true) then begin			GetIndex := index;		end;	end;	function Collection.Info (index: indexType; var len: longint): boolean;		var			offset: longint;	begin		Info := (1 <= index) and (index <= cnt) and GetOffset(index, offset, len);	end;	function Collection.InfoTag (tag: {univ } tagType; var len: longint): boolean;		var			offset: longint;			index: indexType;	begin		InfoTag := GetTagOffset(tag, offset, len, index, true);	end;	function Collection.Exists (index: indexType): boolean;		var			len: longint;	begin		Exists := Info(index, len);	end;	function Collection.ExistsTag (tag: {univ } tagType): boolean;		var			len: longint;	begin		ExistsTag := InfoTag(tag, len);	end;	procedure Collection.Delete (index: indexType);		var			offset, len: longint;	begin		if GetOffset(index, offset, len) then begin			MMungerDelete(data, offset - tagsize - lensize, tagsize + lensize + len);			cnt := cnt - 1;			InvalidateCache;		end;	end;	procedure Collection.DeleteTag (tag: {univ } tagType);		var			offset, len: longint;			index: indexType;	begin		if GetTagOffset(tag, offset, len, index, true) then begin			MMungerDelete(data, offset - tagsize - lensize, tagsize + lensize + len);			cnt := cnt - 1;			InvalidateCache;		end;	end;	procedure Collection.AddChunk (tag: tagType; p: Ptr; len: longint);		var			orgsize: longint;	begin		if testheap then begin			DebugStr('AddChunk Enter;hc;g');		end;		if error = noErr then begin			orgsize := GetHandleSize(data);			SetHandleSize(data, orgsize + tagsize + lensize + len);			if MemError = noErr then begin				if tagged then begin					BlockMoveData(@tag, Ptr(ord(data^) + orgsize), lsize);					orgsize := orgsize + lsize;				end else begin					Assert( EqualTag(tag, tagType(no_tag)) );				end;				if not fixed then begin					BlockMoveData(@len, Ptr(ord(data^) + orgsize), lsize);					orgsize := orgsize + lsize;				end else begin					Assert(len = size);				end;				BlockMoveData(p, Ptr(ord(data^) + orgsize), len);				cnt := cnt + 1;			end;		end;		if testheap then begin			DebugStr('AddChunk Exit;hc;g');		end;	end;	procedure Collection.InsertBefore (index: indexType);		var			offset, len, oe: longint;			t: tagType;	begin		t := tagType(no_tag);		if index = Count + 1 then begin			if fixed then begin				AddChunk(t, @index, size);			end else begin				AddChunk(t, @index, 0);			end;		end else begin			if GetOffset(index, offset, len) then begin				offset := offset - lensize - tagsize;				if tagged then begin					oe := MMungerInsert(data, offset, @t, tagsize);					offset := offset + tagsize;				end;				if fixed then begin					oe := MMungerInsert(data, offset, @index, size);				end else begin					len := 0;					oe := MMungerInsert(data, offset, @len, lensize);				end;				if error = noErr then begin					error := MemError;				end;				cnt := cnt + 1;				InvalidateCache;			end;		end;	end;	procedure Collection.SetChunk (offset, l: longint; tag: tagType; p: Ptr; len: longint);	begin		if tagged then begin			BlockMoveData(@tag, Ptr(ord(data^) + offset - lensize - tagsize), tagsize);		end else begin			Assert( EqualTag(tag, tagType(no_tag)) );		end;		if fixed then begin			Assert(len = size);		end;		if l = len then begin			BlockMoveData(p, Ptr(ord(data^) + offset), len);		end else begin			BlockMoveData(@len, Ptr(ord(data^) + offset - lensize), lensize);			offset := Munger(data, offset, nil, l, p, len);			if error = noErr then begin				error := MemError;			end;		end;		InvalidateCache;	end;	procedure Collection.SetChunkIndex (index: indexType; p: Ptr; len: longint);		var			offset, l: longint;	begin		if GetOffset(index, offset, l) then begin			SetChunk(offset, l, tagType(no_tag), p, len);		end;	end;	procedure Collection.SetChunkTag (tag: tagType; p: Ptr; len: longint);		var			offset, l: longint;			index: indexType;	begin		if GetTagOffset(tag, offset, l, index, true) then begin			SetChunk(offset, l, tag, p, len);		end else begin			AddChunk(tag, p, len);		end;	end;	procedure Collection.GetChunkIndex (index: indexType; len: longint; p: Ptr);		var			offset, l: longint;	begin		if GetOffset(index, offset, l) then begin			Assert(l = len);			BlockMoveData(Ptr(ord(data^) + offset), p, len);		end;	end;	procedure Collection.GetChunkTag (tag: tagType; len: longint; p: Ptr);		var			offset, l: longint;			index: indexType;	begin		if GetTagOffset(tag, offset, l, index, safeget) then begin			Assert(l = len);			BlockMoveData(Ptr(ord(data^) + offset), p, len);		end else begin			MZero(p, len);		end;	end;	procedure Collection.AddBoolean (b: boolean);		var			n: integer;	begin		n := -ord(b);		AddChunk(tagType(no_tag), @n, 1);	end;	procedure Collection.AddTagBoolean (tag: {univ } tagType; b: boolean);		var			n: integer;	begin		n := -ord(b);		AddChunk(tag, @n, 1);	end;	procedure Collection.AddLong (n: univ longint);	begin		AddChunk(tagType(no_tag), @n, lsize);	end;	procedure Collection.AddTagLong (tag: {univ } tagType; n: univ longint);	begin		AddChunk(tag, @n, lsize);	end;	procedure Collection.AddString (const s: Str255);	begin		AddChunk(tagType(no_tag), @s[1], length(s));	end;	procedure Collection.AddTagString (tag: {univ } tagType; const s: Str255);	begin		AddChunk(tag, @s[1], length(s));	end;	procedure Collection.AddData (p: Ptr; len: longint);	begin		AddChunk(tagType(no_tag), p, len);	end;	procedure Collection.AddTagData (tag: {univ } tagType; p: Ptr; len: longint);	begin		AddChunk(tag, p, len);	end;	procedure Collection.AddItem (p: Ptr);	begin		AddChunk(tagType(no_tag), p, size);	end;	procedure Collection.AddTagItem (tag: {univ } tagType; p: Ptr);	begin		AddChunk(tag, p, size);	end;	procedure Collection.SetBoolean (index: indexType; b: boolean);		var			n: integer;	begin		n := -ord(b);		SetChunkIndex(index, @n, 1);	end;	procedure Collection.SetTagBoolean (tag: {univ } tagType; b: boolean);		var			n: integer;	begin		n := -ord(b);		SetChunkTag(tag, @n, 1);	end;	procedure Collection.SetLong (index: indexType; n: univ longint);	begin		SetChunkIndex(index, @n, lsize);	end;	procedure Collection.SetTagLong (tag: {univ } tagType; n: univ longint);	begin		SetChunkTag(tag, @n, lsize);	end;	procedure Collection.SetString (index: indexType; const s: Str255);	begin		SetChunkIndex(index, @s[1], length(s));	end;	procedure Collection.SetTagString (tag: {univ } tagType; const s: Str255);	begin		SetChunkTag(tag, @s[1], length(s));	end;	procedure Collection.SetData (index: indexType; p: Ptr; len: longint);	begin		SetChunkIndex(index, p, len);	end;	procedure Collection.SetTagData (tag: {univ } tagType; p: Ptr; len: longint);	begin		SetChunkTag(tag, p, len);	end;	procedure Collection.SetItem (index: indexType; p: Ptr);	begin		SetChunkIndex(index, p, size);	end;	procedure Collection.SetTagItem (tag: {univ } tagType; p: Ptr);	begin		SetChunkTag(tag, p, size);	end;	function Collection.GetBoolean (index: indexType): boolean;		var			n: integer;	begin		n := 0;		GetChunkIndex(index, 1, @n);		GetBoolean := n <> 0;	end;	function Collection.GetTagBoolean (tag: {univ } tagType): boolean;		var			n: integer;	begin		n := 0;		GetChunkTag(tag, 1, @n);		GetTagBoolean := n <> 0;	end;	procedure Collection.GetLong (index: indexType; var l: univ longint);	begin		GetChunkIndex(index, 4, @l);	end;	procedure Collection.GetTagLong (tag: {univ } tagType; var l: univ longint);	begin		GetChunkTag(tag, 4, @l);	end;	function Collection.GetString (index: indexType): Str255;		var			offset, l: longint;			s: Str255;	begin		s := '';		if GetOffset(index, offset, l) then begin			Assert(l <= 255);			BlockMoveData(Ptr(ord(data^) + offset), @s[1], l);			s[0] := chr(l);		end;		GetString := s;	end;	function Collection.GetTagString (tag: {univ } tagType): Str255;		var			offset, l: longint;			index: indexType;			s: Str255;	begin		s := '';		if GetTagOffset(tag, offset, l, index, safeget) then begin			Assert(l <= 255);			BlockMoveData(Ptr(ord(data^) + offset), @s[1], l);			s[0] := chr(l);		end;		GetTagString := s;	end;	procedure Collection.GetData (index: indexType; p: Ptr; len: longint);	begin		GetChunkIndex(index, len, p);	end;	procedure Collection.GetTagData (tag: {univ } tagType; p: Ptr; len: longint);	begin		GetChunkTag(tag, len, p);	end;	procedure Collection.GetItem (index: indexType; p: Ptr);	begin		GetChunkIndex(index, size, p);	end;	procedure Collection.GetTagItem (tag: {univ } tagType; p: Ptr);	begin		GetChunkTag(tag, size, p);	end;end.