unit MyHandleFile;interface	uses		Types, MyTypes;	type		HandleFile = record				data: Handle; { The data }				pos: longint; { current position in Handle }				crlf: CRLFTypes; { Only used for output, reading will Handle either case }				error: OSErr; { Cumulative error }			end;{ You are free to modify any and all fields, keep 0<=pos<GetHandleSize(data) }	procedure CreateHandleFile (var hf: HandleFile; le: CRLFTypes);	procedure CreateHandleFileFromHandle (var hf: HandleFile; data: Handle; le: CRLFTypes);	procedure DestroyHandleFile (var hf: HandleFile);	procedure WriteToHandleFile (var hf: HandleFile; s: Str255); { Write string at pos into data }	function ReadLongLineFromHandle (var hf: HandleFile; var off, len: longint): boolean;	function ReadFromHandleFile (var hf: HandleFile; var s: Str255): boolean;{ Read string from pos in data, update pos, return true unless eohandle }implementation	uses		Memory, ToolUtils, TextUtils,		MyMemory;	procedure CreateHandleFileFromHandle (var hf: HandleFile; data: Handle; le: CRLFTypes);	begin		hf.data := data;		hf.pos := 0;		hf.crlf := le;		hf.error :=noErr;	end;		procedure CreateHandleFile (var hf: HandleFile; le: CRLFTypes);	begin		hf.error := MNewHandle(hf.data, 0);		hf.pos := 0;		hf.crlf := le;	end;	procedure DestroyHandleFile (var hf: HandleFile);	begin		MDisposeHandle(hf.data);	end;	procedure WriteToHandleFile (var hf: HandleFile; s: Str255);		var			ret: longint;	begin		with hf do begin			case crlf of				CL_CR:					s := concat(s, cr);				CL_LF:					s := concat(s, lf);				CL_CRLF:					s := concat(s, cr, lf);			end;			ret := Munger(data, pos, nil, 0, @s[1], length(s));			if ret >= 0 then begin				pos := ret;			end;			if error = noErr then begin				error := MemError;			end;		end;	end;	function ReadLongLineFromHandle (var hf: HandleFile; var off, len: longint): boolean;		var			size: longint;			p: Ptr;	begin		with hf do begin			size := GetHandleSize(data);			ReadLongLineFromHandle := pos < size;			off := pos;			p := Ptr(ord(data^) + pos);			while (pos < size) and (p^ <> 13) and (p^ <> 10) do begin				pos := pos + 1;				longint(p) := longint(p) + 1;			end;			len := pos - off;			if (pos < size) and (p^ = 13) then begin				pos := pos + 1;				longint(p) := longint(p) + 1;			end;			if (pos < size) and (p^ = 10) then begin				pos := pos + 1;				longint(p) := longint(p) + 1;			end;		end;	end;	function ReadFromHandleFile (var hf: HandleFile; var s: Str255): boolean;		var			off, len: longint;			p: Ptr;			gotline: boolean;	begin		s := '';		gotline := ReadLongLineFromHandle(hf, off, len);		if gotline then begin			p := Ptr(ord(hf.data^) + off);			if len > 255 then begin				len := 255;			end;{$PUSH}{$R-}			s[0] := chr(len);			BlockMoveData(p, @s[1], len);{$POP}		end;		ReadFromHandleFile := gotline;	end;end.