unit MyFastFind;interface	uses		Types;	function SetFastFindSize (p: Ptr; siz: longint): OSErr;	function SetFastFindWord (p: Ptr; theWord: Str63): OSErr;	function SetFastFindFile (p: Ptr; refnum: integer): OSErr;	function StartFastFind (p: Ptr): OSErr;	function FastFind (p: Ptr): longint;	function OldFastFind (p: Ptr): longint;implementation	uses		Errors, Files;	type		dataArray = packed array[1..1000000] of char;		wordType = Str63;		findRecord = record				size: longint;				datap: ^dataArray;				word: wordType;				rn: integer;				filelen, pos, count, data_index: longint;				skip: packed array[char] of Byte;				data: integer;			end;		findPtr = ^findRecord;	function UpperCase (ch: char): char;	inline		$301F, $0C00, $0061, $6500, $000E, $0C00, $007B, $6400, $0006, $0400, $0020, $3E80;	function SetFastFindSize (p: Ptr; siz: longint): OSErr;	begin		with findPtr(p)^ do begin			size := siz - SizeOf(findRecord);			datap := @data;			if size > 256 then				SetFastFindSize := noErr			else				SetFastFindSize := paramErr;		end;	end;	function SetFastFindWord (p: Ptr; theWord: Str63): OSErr;		var			i: integer;	begin		with findPtr(p)^ do begin			word := theWord;			for i := 0 to 255 do				skip[chr(i)] := length(word);			for i := 1 to length(word) do begin				word[i] := UpperCase(word[i]);				skip[word[i]] := length(word) - i;			end;		end;		SetFastFindWord := noErr;	end;	function SetFastFindFile (p: Ptr; refnum: integer): OSErr;		var			oe: OSErr;	begin		with findPtr(p)^ do begin			rn := refnum;			oe := GetEOF(rn, filelen);			if oe = noErr then				oe := GetFPos(rn, pos);			if oe = noErr then begin				count := size;				oe := FSRead(rn, count, Ptr(datap));				if (oe = eofErr) and (count > 0) then					oe := noErr;			end;		end;		SetFastFindFile := oe;	end;	function StartFastFind (p: Ptr): OSErr;	begin		with findPtr(p)^ do begin			data_index := length(word);			if data_index > count then				StartFastFind := -1			else				StartFastFind := noErr;		end;	end;	function OldFastFind (p: Ptr): longint;		var			oe: OSErr;			ch: char;			amount: 0..63;			wi: integer;	begin		with findPtr(p)^ do begin			oe := noErr;			wi := length(word);			while (oe = noErr) and (wi <> 0) and (pos + data_index < filelen) do begin{ data_index is the last character in data that we are checking now }				if data_index > count then begin					amount := count - (data_index - length(word));					pos := pos + count - amount;					BlockMove(@datap^[data_index - length(word) + 1], Ptr(datap), amount);					data_index := length(word);					count := size - amount;					oe := FSRead(rn, count, @datap^[amount + 1]);					if oe = eofErr then						oe := noErr;					count := count + amount;				end;				if (data_index > count) and (oe = noErr) then					oe := -1;				if oe = noErr then begin					repeat						ch := UpperCase(datap^[data_index]);						if ch = word[wi] then begin							data_index := data_index - 1;							wi := wi - 1;							if wi = 0 then								leave;						end						else begin{    data_index := data_index + Max(length(word) - wi + 1, skip[ch]);}							if length(word) - wi + 1 > skip[ch] then								data_index := data_index + length(word) - wi + 1							else								data_index := data_index + skip[ch];							wi := length(word);							if data_index > count then								leave;						end;					until false;				end;			end;			if wi <> 0 then begin				if oe >= 0 then					oe := -1;				OldFastFind := oe;			end			else begin				OldFastFind := pos + data_index;				data_index := data_index + length(word) + 1;			end;		end;	end;end.