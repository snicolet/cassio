unit MySounds;interface	uses		Types;			procedure InitSounds;{ Call at start of app }	procedure IdleSounds;{ Call regularly to release channels after sounds have finished }{ Usually called from the event loop }	procedure FinishSounds;{ Call at termination of app }	procedure PlaySounds (theSound: Handle);{ Play a sound from a Handle }	procedure PlaySoundsID (id: integer);{ Play a sounds from a "snd " resource }implementation	uses		Sound,Memory,Resources;	const		max_sounds = 10; { Excessive? }	type		soundRecordState = (SR_Unused, SR_Inuse, SR_Finished);		mySoundRecord = record				state: soundRecordState;				sound_chan: SndChannelPtr;			end;	var		sounds: array[1..max_sounds] of mySoundRecord;	procedure InitSounds;		var			i: integer;	begin		for i := 1 to max_sounds do begin			sounds[i].state := SR_Unused;			sounds[i].sound_chan := SndChannelPtr(Newptr(SizeOf(SndChannel)));		end;	end;	procedure IdleSounds;		var			oe: OSErr;			i: integer;	begin		for i := 1 to max_sounds do begin			if sounds[i].state = SR_Finished then begin				oe := SndDisposeChannel(sounds[i].sound_chan, false);				sounds[i].state := SR_Unused;			end;		end;	end;	procedure FinishSounds;		var			i: integer;			finished: boolean;	begin		finished := false;		while not finished do begin			IdleSounds;			finished := true;			for i := 1 to max_sounds do begin				if sounds[i].state <> SR_Unused then					finished := false;			end;		end;	end;{$PUSH}{$D-}{ Called at interupt level! }	procedure ChanCallBack (chan: SndChannelPtr; cmd: SndCommand);		var			p: ^soundRecordState;	begin		p := POINTER(cmd.param2);		p^ := SR_Finished;	end;{$POP}	procedure PlaySounds (theSound: Handle);		var			oe: OSErr;			myWish: SndCommand;			i: integer;	begin		if (theSound <> nil) & (theSound^ <> nil) then begin			IdleSounds;			i := 1;			while (i <= max_sounds) & (sounds[i].state <> SR_Unused) do begin				i := i + 1;			end;			if i <= max_sounds then begin				sounds[i].sound_chan^.qLength := stdQLength;				oe := SndNewChannel(sounds[i].sound_chan, 0, 0, @ChanCallBack);				if oe = noErr then begin					MoveHHi(theSound);					HLock(theSound);					oe := SndPlay(sounds[i].sound_chan, SndListHandle(theSound), true);					if oe = noErr then begin						with myWish do begin { set up a sound mgr command block }							cmd := callBackCmd;  { set playing to false }							param1 := 0;							param2 := ord(@sounds[i].state);						end; {with}						oe := SndDoCommand(sounds[i].sound_chan, myWish, false);					end;					if oe = noErr then begin						sounds[i].state := SR_Inuse;					end					else begin						oe := SndDisposeChannel(sounds[i].sound_chan, false);					end;				end;			end;		end;	end;	procedure PlaySoundsID (id: integer);		var			theSound: Handle;	begin		theSound := GetResource('snd ', id);		PlaySounds(theSound);	end;end.