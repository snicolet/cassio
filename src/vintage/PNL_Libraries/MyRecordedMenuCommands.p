unit MyRecordedMenuCommands;interface	uses		Types, AppleEvents;		type		RecordedEnabledProc = function:boolean;		RecordedActionProc = procedure;			procedure StartupRecordedMenuCommands;	procedure SetRecordedMenuCommand( class_id, event_id: AEEventID; command: OSType; enabled: RecordedEnabledProc; action: RecordedActionProc );	implementation	uses		Memory, Events,		MyMemory, MyStartup, MyAssertions, MyFMenus, MyAEUtils, MyMenus, MySystemGlobals;		type		EntryRecord = record			class_id, event_id: AEEventID;			command: OSType;			enabled: RecordedEnabledProc;			action: RecordedActionProc;		end;		EntryArray = array[1..10000] of EntryRecord;		EntryPtr = ^EntryArray;		EntryHandle = ^EntryPtr;	var		entries: EntryHandle;		entries_count: longint;		handler: AEEventHandlerUPP;		procedure FindCommand( command: OSType; var index: longint );		var			i: integer;	begin		index := -1;		for i := 1 to entries_count do begin			if entries^^[i].command = command then begin				index := i;				leave;			end;		end;		Assert( index > 0 );	end;		function HandleShowTranscript (var event, reply: AppleEvent; index: longint): OSErr;	begin{$unused(event, reply)}		if entries^^[index].enabled() then begin			entries^^[index].action();			HandleShowTranscript := noErr;		end else begin			HandleShowTranscript := -1;		end;	end;	procedure DoAction;		var			index: longint;			command: OSType;	begin		GetCommand( thefmenu, thefitem, command );		FindCommand( command, index );		if has_AppleEvents then begin			SendSelfSimpleEvent( entries^^[index].class_id, entries^^[index].event_id );		end else if entries^^[index].enabled() then begin			entries^^[index].action();		end;	end;		procedure SetAction (themenu, theitem: integer);		var			index: longint;			command: OSType;	begin		GetCommand( themenu, theitem, command );		FindCommand( command, index );		SetIDItemEnable(themenu, theitem, entries^^[index].enabled() );	end;	procedure SetRecordedMenuCommand( class_id, event_id: AEEventID; command: OSType; enabled: RecordedEnabledProc; action: RecordedActionProc );		var			err: OSErr;			entry: EntryRecord;	begin		entry.class_id := class_id;		entry.event_id := event_id;		entry.command := command;		entry.enabled := enabled;		entry.action := action;		err := PtrAndHand(@entry, Handle(entries), SizeOf(entry));		if err = noErr then begin			Inc(entries_count);			if has_AppleEvents then begin				err := AEInstallEventHandler( class_id, event_id, handler, entries_count, false );			end;			SetFBoth( command, DoAction, SetAction );		end;	end;		function InitRecordedMenuCommands( var msg: integer ): OSStatus;		var			err: OSStatus;	begin{$unused(msg)}		err := MNewHandle( entries, 0 );		handler := NewAEEventHandlerProc(HandleShowTranscript);		InitRecordedMenuCommands := noErr;	end;	procedure StartupRecordedMenuCommands;	begin		SetStartup( InitRecordedMenuCommands, nil, 0, nil );	end;	end.