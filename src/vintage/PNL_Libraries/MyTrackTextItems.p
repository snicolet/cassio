unit MyTrackTextItems;interface	uses		Dialogs;	procedure TrackTextItemsCreate (dialog: DialogPtr; var data: univ Handle);	procedure TrackTextItemsDestroy (var data: univ Handle);	procedure TrackTextItems (data: univ Handle; dialog: DialogPtr);	function AnyTextItemHasChanged (data: univ Handle; dialog: DialogPtr): boolean;	function TextItemHasChanged (data: univ Handle; dialog: DialogPtr; item: integer): boolean;	function TextItemWas (data: univ Handle; item: integer): Str255;implementation	uses		MyStrh, MyDialogs;	procedure TrackTextItemsCreate (dialog: DialogPtr; var data: univ Handle);	begin		data := Handle(NewStrH);		TrackTextItems(data, dialog);	end;	procedure TrackTextItemsDestroy (var data: univ Handle);	begin		DisposeHandle(data);	end;	procedure SafeGetItemText (dialog: DialogPtr; item: integer; var s: Str255);		var			k: integer;	begin		s := '';		GetDItemKind(dialog, item, k);		if k in [editText, statText] then begin			GetItemText(dialog, item, s);		end;	end;	procedure TrackTextItems (data: univ Handle; dialog: DialogPtr);		var			i: integer;			s: Str255;			junk: OSErr;	begin		for i := 1 to CountDItems(dialog) do begin			SafeGetItemText(dialog, i, s);			junk := SetIndStrH(StrHHandle(data), i, s);		end;	end;	function TextItemWas (data: univ Handle; item: integer): Str255;	begin		TextItemWas := GetIndStrH(StrHHandle(data), item);	end;	function TextItemHasChanged (data: univ Handle; dialog: DialogPtr; item: integer): boolean;		var			s: Str255;	begin		SafeGetItemText(dialog, item, s);		TextItemHasChanged := s <> TextItemWas(data, item);	end;	function AnyTextItemHasChanged (data: univ Handle; dialog: DialogPtr): boolean;		var			i: integer;	begin		AnyTextItemHasChanged := false;		for i := 1 to CountDItems(dialog) do begin			if TextItemHasChanged(data, dialog, i) then begin				AnyTextItemHasChanged := true;				leave;			end;		end;	end;end.