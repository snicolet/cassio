unit MyAEUtils;interface	uses		Types, Memory, Processes, Files, TextEdit, AppleEvents;	const		typeMyPropertyToken = 'PTok';		myPropertiesResType = 'MPRP';	type		SuspendedEvent = record				waiting: boolean;				event, reply: AppleEvent;				dispatcher: AEEventHandlerUPP;				refcon: longint;			end;	function GotRequiredParams (var event: AppleEvent): OSErr;	function AEGetDescPtr (desc: AEDesc; desiredType: DescType; p: Ptr; maximumSize: Size; var actualSize: Size): OSErr;	procedure AECreate (var desc: AEDesc);	procedure AEDestroy (var desc: AEDesc); { dispose without error }	function AENull: AEDesc;	function CreateStringDesc (s: Str255; var desc: AEDesc): OSErr;	function CreateLongDesc (n: longint; var desc: AEDesc): OSErr;	function CreateTypeDesc (t: DescType; var desc: AEDesc): OSErr;	function CreateSignatureDesc (t: DescType; var desc: AEDesc): OSErr;	function CreateProcessSerialNumberDesc (const psn: ProcessSerialNumber; var desc: AEDesc): OSErr;	function CreateBooleanDesc (b: boolean; var desc: AEDesc): OSErr;	function CreateFSSpecDesc (fs: FSSpec; var desc: AEDesc): OSErr;	function CreateSelfTarget (var desc: AEDesc): OSErr;	function GetDataFromAEDesc(var desc: AEDesc; typ: DescType; datap: Ptr; datalen: longint): OSErr;{ Guarentteed to preserve x on error }	function GetStringFromAEDesc (desc: AEDesc; var x: Str255): OSErr;	function GetLongFromAEDesc (desc: AEDesc; var x: longint): OSErr;	function GetTypeFromAEDesc (desc: AEDesc; var x: DescType): OSErr;	function GetBooleanFromAEDesc (desc: AEDesc; var x: boolean): OSErr;	function GetFSSpecFromAEDesc (desc: AEDesc; var x: FSSpec): OSErr;	function GetEnumeratedFromAEDesc (desc: AEDesc; var x: DescType): OSErr;	function GetDataFromAERecord(var desc: AERecord; key: AEKeyword; typ: DescType; datap: Ptr; datalen: longint): OSErr;{ Guarentteed to preserve x on error }	function GetStringFromAERecord (var desc: AERecord; key: AEKeyword; var x: Str255): OSErr;	function GetLongFromAERecord (var desc: AERecord; key: AEKeyword; var x: longint): OSErr;	function GetTypeFromAERecord (var desc: AERecord; key: AEKeyword; var x: DescType): OSErr;	function GetBooleanFromAERecord (var desc: AERecord; key: AEKeyword; var x: boolean): OSErr;	function GetFSSpecFromAERecord (var desc: AERecord; key: AEKeyword; var x: FSSpec): OSErr;	function GetEnumeratedFromAERecord (var desc: AERecord; key: AEKeyword; var x: DescType): OSErr;	function PutTESelectionToAERecord (var desc: AERecord; key: AEKeyword; te: TEHandle): OSErr;	function PutStringToAERecord (var desc: AERecord; key: AEKeyword; const s: Str255): OSErr;	function PutLongToAERecord (var desc: AERecord; key: AEKeyword; n: longint): OSErr;	function PutDateToAERecord (var desc: AERecord; key: AEKeyword; date: UInt32): OSErr;	function PutTypeToAERecord (var desc: AERecord; key: AEKeyword; t: DescType): OSErr;	function PutBooleanToAERecord (var desc: AERecord; key: AEKeyword; b: boolean): OSErr;	function PutFSSpecToAERecord (var desc: AERecord; key: AEKeyword; const fs: FSSpec): OSErr;	procedure SendSelfSimpleEvent (class_id, event_id: AEEventID);	function NullSuspendedEvent: SuspendedEvent;	function SuspendEvent (var event, reply: AppleEvent; dispatcher: AEEventHandlerUPP; refcon: longint; var se: SuspendedEvent): OSErr;	procedure ResumeEvent (var se: SuspendedEvent);implementation	uses		Memory, Resources, Errors, AEObjects, AERegistry;	procedure AECreate (var desc: AEDesc);	begin		desc.descriptorType := typeNull;		desc.dataHandle := nil;	end;	function AENull: AEDesc;		var			desc: AEDesc;	begin		AECreate(desc);		AENull := desc;	end;	procedure AEDestroy (var desc: AEDesc);		var			junk: OSErr;	begin		junk := AEDisposeDesc(desc);		AECreate(desc);	end;	function GotRequiredParams (var event: AppleEvent): OSErr;		var			typeCode: DescType;			actualSize: Size;			err: OSErr;	begin		err := AEGetAttributePtr(event, keyMissedKeywordAttr, typeWildCard, typeCode, nil, 0, actualSize);		if err = errAEDescNotFound then begin		(* we got all the required params: all is ok *)			err := noErr;		end else if err = noErr then begin			err := errAEEventNotHandled		end;		GotRequiredParams := err;	end;	function AEGetDescPtr (desc: AEDesc; desiredType: DescType; p: Ptr; maximumSize: Size; var actualSize: Size): OSErr;		var			err: OSErr;			result: AEDesc;			len: longint;	begin		actualSize := 0;		err := AECoerceDesc(desc, desiredType, result);		if err = noErr then begin			actualSize := GetHandleSize(result.dataHandle);			len := actualSize;			if len > maximumSize then begin				len := maximumSize;			end;			BlockMoveData(result.dataHandle^, p, len);		end;		AEDestroy(result);		AEGetDescPtr := err;	end;	function CreateSelfTarget (var desc: AEDesc): OSErr;		var			psn: ProcessSerialNumber;	begin		psn.lowLongOfPSN := kCurrentProcess;		psn.highLongOfPSN := 0;		CreateSelfTarget := AECreateDesc(typeProcessSerialNumber, @psn, SizeOf(psn), desc);	end;	function CreateStringDesc (s: Str255; var desc: AEDesc): OSErr;	begin		CreateStringDesc := AECreateDesc(typeChar, @s[1], length(s), desc);	end;	function CreateLongDesc (n: longint; var desc: AEDesc): OSErr;	begin		CreateLongDesc := AECreateDesc(typeLongInteger, @n, SizeOf(n), desc);	end;	function CreateTypeDesc (t: DescType; var desc: AEDesc): OSErr;	begin		CreateTypeDesc := AECreateDesc(typeType, @t, SizeOf(t), desc);	end;	function CreateSignatureDesc (t: DescType; var desc: AEDesc): OSErr;	begin		CreateSignatureDesc := AECreateDesc(typeApplSignature, @t, SizeOf(t), desc);	end;	function CreateProcessSerialNumberDesc (const psn: ProcessSerialNumber; var desc: AEDesc): OSErr;	begin		CreateProcessSerialNumberDesc := AECreateDesc(typeProcessSerialNumber, @psn, SizeOf(psn), desc);	end;	function CreateBooleanDesc (b: boolean; var desc: AEDesc): OSErr;	begin		CreateBooleanDesc := AECreateDesc(typeBoolean, @b, SizeOf(b), desc);	end;	function CreateFSSpecDesc (fs: FSSpec; var desc: AEDesc): OSErr;	begin		CreateFSSpecDesc := AECreateDesc(typeFSS, @fs, SizeOf(fs), desc);	end;	function GetStringFromAEDesc (desc: AEDesc; var x: Str255): OSErr;		var			result: AEDesc;			err: OSErr;			len: longint;	begin		err := AECoerceDesc(desc, typeChar, result);		if err = noErr then begin			len := GetHandleSize(result.dataHandle);			if len > 255 then begin				len := 255;			end;			x[0] := chr(len);			BlockMoveData(result.dataHandle^, @x[1], len);			AEDestroy(result);		end;		GetStringFromAEDesc := err;	end;	function GetDataFromAEDesc(var desc: AEDesc; typ: DescType; datap: Ptr; datalen: longint): OSErr;		var			actual_size: Size;			err: OSErr;	begin		err := AEGetDescPtr(desc, typ, datap, datalen, actual_size);		if (err = noErr) and (datalen <> actual_size) then begin			err := -14;		end;		GetDataFromAEDesc := err;	end;		function GetLongFromAEDesc (desc: AEDesc; var x: longint): OSErr;		var			len: longint;			err: OSErr;			temp: longint;	begin		err := AEGetDescPtr(desc, typeLongInteger, @temp, SizeOf(temp), len);		if err = noErr then begin			x := temp;		end;		GetLongFromAEDesc := err;	end;	function GetTypeFromAEDesc (desc: AEDesc; var x: DescType): OSErr;		var			len: longint;			err: OSErr;			temp: DescType;	begin		err := AEGetDescPtr(desc, typeType, @temp, SizeOf(temp), len);		if err = noErr then begin			x := temp;		end;		GetTypeFromAEDesc := err;	end;	function GetBooleanFromAEDesc (desc: AEDesc; var x: boolean): OSErr;		var			len: longint;			err: OSErr;			temp: boolean;	begin		err := AEGetDescPtr(desc, typeBoolean, @temp, SizeOf(temp), len);		if err = noErr then begin			x := temp;		end;		GetBooleanFromAEDesc := err;	end;	function GetFSSpecFromAEDesc (desc: AEDesc; var x: FSSpec): OSErr;		var			err: OSErr;			len: longint;			temp: FSSpec;	begin		err := AEGetDescPtr(desc, typeFSS, @temp, SizeOf(temp), len);		if err = noErr then begin			x := temp;		end;		GetFSSpecFromAEDesc := err;	end;	function GetEnumeratedFromAEDesc (desc: AEDesc; var x: DescType): OSErr;		var			err: OSErr;	begin		err := noErr;		if (GetHandleSize(desc.dataHandle) <> SizeOf(DescType)) then begin			err := errAETypeError;		end;		if err = noErr then begin			BlockMoveData(desc.dataHandle^, @x, SizeOf(x));		end;		GetEnumeratedFromAEDesc := err;	end;	function GetStringFromAERecord (var desc: AERecord; key: AEKeyword; var x: Str255): OSErr;		var			dummy: DescType;			actual: Size;			err: OSErr;			temp: Str255;	begin	{ AEGetKeyPtr changed to AEGetParamPtr }		err := AEGetParamPtr(desc, key, typeChar, dummy, @temp[1], 255, actual);		if err = noErr then begin			temp[0] := chr(actual);			x := temp;		end;		GetStringFromAERecord := err;	end;	function GetDataFromAERecord(var desc: AERecord; key: AEKeyword; typ: DescType; datap: Ptr; datalen: longint): OSErr;		var			junk_type: DescType;			actual_size: Size;			err: OSErr;	begin		err := AEGetParamPtr(desc, key, typ, junk_type, datap, datalen, actual_size);		if (err = noErr) and (datalen <> actual_size) then begin			err := -14;		end;		GetDataFromAERecord := err;	end;		function GetLongFromAERecord (var desc: AERecord; key: AEKeyword; var x: longint): OSErr;		var			dummy: DescType;			actual: Size;			err: OSErr;			temp: longint;	begin		err := AEGetParamPtr(desc, key, typeLongInteger, dummy, @temp, SizeOf(temp), actual);		if err = noErr then begin			x := temp;		end;		GetLongFromAERecord := err;	end;	function GetTypeFromAERecord (var desc: AERecord; key: AEKeyword; var x: DescType): OSErr;		var			dummy: DescType;			actual: Size;			err: OSErr;			temp: DescType;	begin		err := AEGetParamPtr(desc, key, typeType, dummy, @temp, SizeOf(temp), actual);		if err = noErr then begin			x := temp;		end;		GetTypeFromAERecord := err;	end;	function GetBooleanFromAERecord (var desc: AERecord; key: AEKeyword; var x: boolean): OSErr;		var			dummy: DescType;			actual: Size;			err: OSErr;			temp: boolean;	begin		err := AEGetParamPtr(desc, key, typeBoolean, dummy, @temp, SizeOf(temp), actual);		if err = noErr then begin			x := temp;		end;		GetBooleanFromAERecord := err;	end;	function GetFSSpecFromAERecord (var desc: AERecord; key: AEKeyword; var x: FSSpec): OSErr;		var			dummy: DescType;			actual: Size;			err: OSErr;			temp: FSSpec;	begin		err := AEGetParamPtr(desc, key, typeFSS, dummy, @temp, SizeOf(temp), actual);		if err = noErr then begin			x := temp;		end;		GetFSSpecFromAERecord := err;	end;	function GetEnumeratedFromAERecord (var desc: AERecord; key: AEKeyword; var x: DescType): OSErr;		var			err: OSErr;			value: AEDesc;	begin		err := AEGetParamDesc(desc, key, typeWildCard, value);		if err = noErr then begin			err := GetEnumeratedFromAEDesc(value, x);		end;		AEDestroy(value);		GetEnumeratedFromAERecord := err;	end;	function PutTESelectionToAERecord (var desc: AERecord; key: AEKeyword; te: TEHandle): OSErr;		var			hhhh: Handle;			state: SignedByte;	begin		hhhh := Handle(TEGetText(te));		state := HGetState(hhhh);		HLock(hhhh);		PutTESelectionToAERecord := AEPutParamPtr(desc, key, typeChar, Ptr(ord(hhhh^) + te^^.selStart), te^^.selEnd - te^^.selStart);		HSetState(hhhh, state);	end;	function PutStringToAERecord (var desc: AERecord; key: AEKeyword; const s: Str255): OSErr;	begin		PutStringToAERecord := AEPutParamPtr(desc, key, typeChar, @s[1], length(s));	end;	function PutLongToAERecord (var desc: AERecord; key: AEKeyword; n: longint): OSErr;	begin		PutLongToAERecord := AEPutParamPtr(desc, key, typeLongInteger, @n, SizeOf(n));	end;	function PutDateToAERecord (var desc: AERecord; key: AEKeyword; date: UInt32): OSErr;		var			longdate: record					zero: longint;					date: UInt32;				end;	begin		longdate.zero := 0;		longdate.date := date;		PutDateToAERecord := AEPutParamPtr(desc, key, 'ldt ', @longdate, SizeOf(longdate)); { typeLongDateTime }	end;	function PutTypeToAERecord (var desc: AERecord; key: AEKeyword; t: DescType): OSErr;	begin		PutTypeToAERecord := AEPutParamPtr(desc, key, typeType, @t, SizeOf(t));	end;	function PutBooleanToAERecord (var desc: AERecord; key: AEKeyword; b: boolean): OSErr;	begin		PutBooleanToAERecord := AEPutParamPtr(desc, key, typeBoolean, @b, SizeOf(b));	end;	function PutFSSpecToAERecord (var desc: AERecord; key: AEKeyword; const fs: FSSpec): OSErr;	begin		PutFSSpecToAERecord := AEPutParamPtr(desc, key, typeFSS, @fs, SizeOf(fs));	end;	procedure SendSelfSimpleEvent (class_id, event_id: AEEventID);		var			event, reply: AppleEvent;			err, junk: OSErr;			target: AEDesc;	begin		AECreate(reply);		err := CreateSelfTarget(target);		err := AECreateAppleEvent(class_id, event_id, target, kAutoGenerateReturnID, kAnyTransactionID, event);		AEDestroy(target);		if err = noErr then begin			junk := AESend(event, reply, kAENoReply + kAEAlwaysInteract, kAENormalPriority, kAEDefaultTimeout, nil, nil);		end;		AEDestroy(event);		AEDestroy(reply);	end;	function NullSuspendedEvent: SuspendedEvent;		var			se: SuspendedEvent;	begin		se.waiting := false;		NullSuspendedEvent := se;	end;	function SuspendEvent (var event, reply: AppleEvent; dispatcher: AEEventHandlerUPP; refcon: longint; var se: SuspendedEvent): OSErr;		var			err: OSErr;	begin		se.event := event;		se.reply := reply;		se.dispatcher := dispatcher;		se.refcon := refcon;		err := AESuspendTheCurrentEvent(event);		se.waiting := err = noErr;		SuspendEvent := err;	end;	procedure ResumeEvent (var se: SuspendedEvent);		var			junk: OSErr;	begin		if se.waiting then begin			se.waiting := false;			junk := AEResumeTheCurrentEvent(se.event, se.reply, se.dispatcher, se.refcon);		end;	end;end.