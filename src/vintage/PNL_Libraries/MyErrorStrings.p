unit MyErrorStrings;interface	uses		Types;	function ErrorStr (id: integer; err: OSStatus): Str255;	function ErrorString (id: integer; err: OSStatus; var e: Str255): boolean;implementation	uses		Memory, TextUtils, Resources;	function ErrorString (id: integer; err: OSStatus; var e: Str255): boolean;		var			h: Handle;			s, n: Str255;			left: longint;			oe: OSErr;			p: Ptr;			len: integer;	begin		ErrorString := false;		NumToString(err, n);		e := n;		h := GetResource('ERRS', id);		if (h <> nil) and (h^ <> nil) then begin			HNoPurge(h);			left := GetHandleSize(h);			p := h^;			while (left > 3) do begin				BlockMoveData(p, @oe, 2);				p := Ptr(ord(p) + 2);				len := BAND(p^, $FF);				BlockMoveData(p, @s, len + 1);				p := Ptr(ord(p) + len + 1);				if err = oe then begin					e := s;					ErrorString := true;					leave;				end;				left := left - (2 + 1 + len);			end;			HPurge(h);		end;	end;	function ErrorStr (id: integer; err: OSStatus): Str255;		var			dummy: boolean;			e: Str255;	begin		dummy := ErrorString(id, err, e);		ErrorStr := e;	end;end.