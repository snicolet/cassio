unit MySAT;interface	uses		SAT;	function GetASingleFaceFromPICT (colorPICTid, bwPICTid: integer; bounds: Rect): FacePtr;	function StartGetttingFaces (colorPICTid, bwPICTid: integer; bounds: Rect): boolean;	function GetAFaceFromPICT (h, v: integer): FacePtr;	procedure FinishGettingFaces;implementation	uses		QDOffscreen;	var		savePort: GrafPtr;		saveDev: GDHandle;		colour_ph, draw_ph: PicHandle;		offscreenGWorld: GWorldPtr;		pm: PixMapHandle;		transparent_colour: integer;		rowbytes: integer;		bounds0: Rect;	function StartGetttingFaces (colorPICTid, bwPICTid: integer; bounds: Rect): boolean;		var			err: OSErr;			baseaddr: Ptr;			r: Rect;	begin		StartGetttingFaces := false;		SATGetPort(savePort, saveDev);		colour_ph := GetPicture(colorPICTid);		if gSAT.initDepth > 1 then begin			draw_ph := colour_ph;		end		else begin			draw_ph := GetPicture(bwPICTid);		end;		if (colour_ph <> nil) and (colour_ph^ <> nil) and (draw_ph <> nil) and (draw_ph^ <> nil) then begin			HNoPurge(Handle(colour_ph));			HNoPurge(Handle(draw_ph));			bounds0 := bounds;			OffsetRect(bounds0, -bounds0.left, -bounds0.top);			err := NewGWorld(offscreenGWorld, 8, bounds0, nil, nil, []);			if err = noErr then begin				pm := GetGWorldPixMap(offscreenGWorld);				if LockPixels(pm) then begin					SetGWorld(CGrafPtr(offscreenGWorld), nil);					r := colour_ph^^.picFrame;					OffsetRect(r, -r.left, -r.top);					DrawPicture(colour_ph, r);					baseaddr := GetPixBaseAddr(pm);					transparent_colour := baseaddr^;					rowbytes := BAND(pm^^.rowBytes, $7FFF);					StartGetttingFaces := true;				end;			end;		end;	end;	function GetAFaceFromPICT (h, v: integer): FacePtr;		var			err: OSErr;			baseaddr: Ptr;			r: Rect;			theface: FacePtr;			x, y: integer;			p: Ptr;	begin		SetGWorld(CGrafPtr(offscreenGWorld), nil);		baseaddr := GetPixBaseAddr(pm);		r := colour_ph^^.picFrame;		OffsetRect(r, -r.left - h, -r.top - v);		DrawPicture(colour_ph, r);		baseaddr := GetPixBaseAddr(pm);		rowbytes := BAND(pm^^.rowBytes, $7FFF);		for y := 0 to bounds0.bottom - 1 do begin			for x := 0 to bounds0.right - 1 do begin				p := Ptr(ord(baseaddr) + y * rowbytes + x);				if p^ = transparent_colour then begin					p^ := 0;				end				else begin					p^ := 255;				end;			end;		end;		theface := SATNewFace(bounds0);		SATSetPortFace(theface);		r := draw_ph^^.picFrame;		OffsetRect(r, -r.left - h, -r.top - v);		DrawPicture(draw_ph, r);		SATSetPortMask(theface);		CopyBits(GrafPtr(offscreenGWorld)^.portBits, theport^.portBits, bounds0, bounds0, srcCopy, nil);		SATChangedFace(theface);		GetAFaceFromPICT := theface;	end;	procedure FinishGettingFaces;	begin		DisposeGWorld(offscreenGWorld);		HPurge(Handle(colour_ph));		HPurge(Handle(draw_ph));		SATSetPort(savePort, saveDev);	end;	function GetASingleFaceFromPICT (colorPICTid, bwPICTid: integer; bounds: Rect): FacePtr;	begin		GetASingleFaceFromPICT := nil;		if StartGetttingFaces(colorPICTid, bwPICTid, bounds) then begin			GetASingleFaceFromPICT := GetAFaceFromPICT(bounds.left, bounds.top);			FinishGettingFaces;		end;	end;end.