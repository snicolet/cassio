unit MyAssocStrings;interface	uses		Memory;	type		AssocStringsObject = object			{ private }			data: Handle						{ public }			function Create: OSStatus;			procedure Destroy;			function Count: longint;			procedure GetIndexedKey( index: longint; var key, value: Str255 );			procedure GetData( const key: Str255; var value: Str255 );			procedure SetData( const key, value: Str255 );			procedure DeleteData( const key: Str255 );		end;implementation	uses		Packages,ToolUtils,		MyLowLevel, MyMemory, MyAssertions;	procedure Next ( data: Handle; var pos: longint );	begin		pos := pos + GetUnsignedByte( data^, pos ) + 1;	end;	procedure CopyString ( data: Handle; pos: longint; var s: Str255 );	begin		BlockMove(AddPtrLong(data^, pos), @s, GetUnsignedByte(data^, pos) + 1);	end;	function GetPos ( data: Handle; const key: Str255; var pos: longint ): boolean;		var			size: longint;			thiskey: Str255;	begin		Assert( data <> nil );		GetPos := false;		size := GetHandleSize(data);		pos := 0;		while pos < size do begin			CopyString(data, pos, thiskey);			if IUEqualString(thiskey, key) = 0 then begin				GetPos := true;				leave;			end;			Next(data, pos);			Next(data, pos);		end;	end;	function AssocStringsObject.Create: OSStatus;	begin		Create := MNewHandle( data, 0 );	end;		procedure AssocStringsObject.Destroy;	begin		MDisposeHandle( data );		dispose(self);	end;		function AssocStringsObject.Count: longint;		var			pos, size: longint;			c: longint;	begin		Assert( data <> nil );		c := 0;		size := GetHandleSize(data);		pos := 0;		while pos < size do begin			Next(data, pos);			Next(data, pos);			Inc(c);		end;		Count := c;	end;	procedure AssocStringsObject.GetIndexedKey( index: longint; var key, value: Str255 );		var			pos, size: longint;	begin		Assert( data <> nil );		size := GetHandleSize(data);		pos := 0;		while (pos < size) and (index > 1) do begin			Next(data, pos);			Next(data, pos);			Dec(index);		end;		if (pos < size) and (index = 1) then begin			CopyString(data, pos, key);			Next(data, pos);			CopyString(data, pos, value);		end else begin			key := '';			value := '';		end;	end;	procedure AssocStringsObject.GetData( const key: Str255; var value: Str255 );		var			pos: longint;	begin		value := '';		if GetPos(data, key, pos) then begin			Next(data, pos);			CopyString(data, pos, value);		end;	end;	procedure AssocStringsObject.SetData( const key, value: Str255 );		var			err: OSErr;			pos: longint;	begin		if GetPos(data, key, pos) then begin			Next(data, pos);			pos := Munger(data, pos, nil, GetUnsignedByte(data^, pos) + 1, @value, length(value) + 1);		end		else begin			err := PtrAndHand(@key, data, length(key) + 1);			err := PtrAndHand(@value, data, length(value) + 1);		end;	end;	procedure AssocStringsObject.DeleteData( const key: Str255 );		var			pos, posn: longint;	begin		if GetPos(data, key, pos) then begin			posn := pos;			Next(data, posn);			Next(data, posn);			pos := Munger(data, pos, nil, posn - pos, @pos, 0);		end;	end;end.