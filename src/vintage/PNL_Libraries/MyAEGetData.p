unit MyAEGetData;interface	uses		Types, AppleEvents;	type		GetSelectionProcType = function ( var reply:AppleEvent ): OSErr;			procedure StartupAEGetData;	procedure ConfigureAEGetData (GetSelectionProc: GetSelectionProcType);implementation	uses		AERegistry, AEObjects, MyStartup;	const		MaxPropLevel = 2; { or whatever number of levels you want to support }	type		propArray = array[1..MaxPropLevel] of DescType;	var		getdata: GetSelectionProcType;	function PropertyOf (theSpec: AERecord; var propLevel: integer; var properties: propArray): boolean;		var			objSpec: AERecord;			typ, t, prop: DescType;			size: longint;			key: AEKeyword;			err: OSErr;	begin		PropertyOf := false; { we don't know this is a property yet }		if propLevel = 0 then begin { 0 means the Apple Event }			key := keyDirectObject;		end else begin			key := keyAEContainer;		end;		if AEGetParamDesc(theSpec, key, typeAERecord, objSpec) = noErr then begin			if (AEGetParamPtr(objSpec, keyAEDesiredClass, typeType, typ, @t, 4, size) = noErr) & (t = cProperty) then begin				if (AEGetParamPtr(objSpec, keyAEKeyForm, typeEnumerated, typ, @t, 4, size) = noErr) & (t = formPropertyID) then begin { this is redundunt, won't hurt to make sure }					if AEGetParamPtr(objSpec, keyAEKeyData, typeType, typ, @prop, 4, size) = noErr then begin { which of property? }						propLevel := propLevel + 1;						properties[propLevel] := prop;						if AESizeOfParam(objSpec, keyAEContainer, typ, size) = noErr then begin { property of what }							if typ = typeNull then begin { prop of application, we are done }								PropertyOf := true;							end else if typ = typeObjectSpecifier then begin { from another object specifer }								if propLevel < MaxPropLevel then { only do it if we have not reach max level }									PropertyOf := PropertyOf(objSpec, propLevel, properties); { go down 1 level }							end; { else it is an error }						end;					end;				end;			end;			err := AEDisposeDesc(objSpec);		end;	end;	function MyGetDataHandler (var event, reply: AppleEvent; theRefcon: longint): OSErr;		var			err: OSErr;			propLevel: integer;			properties: propArray;	begin{$unused(theRefcon)}		err := errAENoSuchObject;		propLevel := 0; { 0 means we are passing in an Apple Event }		if PropertyOf(event, propLevel, properties) & (propLevel = 2) then begin			if (properties[1] = pContents) & (properties[2] = pSelection) then begin { it is content of selection }				err := getdata( reply );			end;		end;		MyGetDataHandler := err;	end;	function InitAEGetData ( var msg: integer ): OSStatus;		var			junk: OSErr;	begin{$unused(msg)}		junk := AEInstallEventHandler(kAECoreSuite, kAEGetData, NewAEEventHandlerProc(MyGetDataHandler), 0, false);		InitAEGetData := noErr;	end;	procedure ConfigureAEGetData (GetSelectionProc: GetSelectionProcType);	begin		getdata := GetSelectionProc;		StartupAEGetData;	end;		procedure StartupAEGetData;	begin		SetStartup( InitAEGetData, nil, 0, nil );	end;end.