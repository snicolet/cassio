unit MyMacBinary;interface	uses		Files;	const		macbin_folder_ftype = 'fold';		macbin_folder_creator_start = -1; { Should be OSType(-1), damn TP! }		macbin_folder_creator_end = -2;	type		MBpacket = packed array[1..128] of Byte;{$PUSH}{$ALIGN MAC68K}	type		MBIIStartHeader = packed record				name: Str63;				ftype: OSType;				fcreator: OSType;				flags_high: Byte;				zero1: Byte;				flocation: Point;				windowID: integer; {? - ignore }				protected: Byte; { low order bit - ignore}				zero2: Byte;				dlen: longint;				rlen: longint;				create_date: UInt32;				mod_date: UInt32;				clen: integer;				flags_low: Byte;			end;		MBIIHeader = packed record				version: SignedByte;				MBIIStart: SignedByte;				space: packed array[2..115] of Byte;				total_unpack_len: longint;{ignore}				second_header_len: integer;{ignore}				versionII: Byte;				minversionII: Byte;				crc: integer;				processorID: integer; {ignore}			end;		MBIIHeaderPtr = ^MBIIHeader;{$ALIGN RESET}{$POP}	type		packet_type = (PT_None, PT_File, PT_StartBlock, PT_EndBlock);	function ValidateMBHeader (var header: MBIIHeader; handle2plus: boolean): packet_type;	procedure CatInfo2MBHeader (var pb: CInfoPBRec; var header: MBIIHeader; dtdbr: integer; var comment: Str255);implementation	uses		MyMemory, MyDesktopDB, CalcCRC;	function ValidateMBHeader (var header: MBIIHeader; handle2plus: boolean): packet_type;		var			ocrc: integer;			typ: packet_type;			start: MBIIStartHeader;			i: integer;	begin		BlockMoveData(@header.MBIIStart, @start, SizeOf(start));		typ := PT_None;		with header do begin			if (version <= ord(handle2plus)) & (MBpacket(header)[75] = 0) then begin				ocrc := 0;				CalcMBCRCBlock(@header, 124, ocrc);				if ocrc = MBIIHeader(header).crc then begin					if (version = 1) & (start.ftype = macbin_folder_ftype) & ((start.fcreator = OSType(macbin_folder_creator_start)) | (start.fcreator = OSType(macbin_folder_creator_end))) then begin						if start.fcreator = OSType(macbin_folder_creator_start) then begin							typ := PT_StartBlock;						end else begin							typ := PT_EndBlock;						end;					end else begin						typ := PT_File;					end;				end else if (version = 0) then begin { Assume its a valid MacBinary I file }					MBpacket(header)[101] := 0; { Zero out the flags low_byte }					total_unpack_len := 0;					second_header_len := 0;					versionII := 129;					minversionII := 129;					crc := 0;					processorID := 0;					typ := PT_File;				end;			end;		end;		if typ = PT_File then begin			typ := PT_None;			if (0 <= start.clen) & (start.clen <= 200)				& (0 <= start.dlen) & (0 <= start.rlen)				& (0 < length(start.name)) & (length(start.name) <= 63) then begin				typ := PT_File;				for i := 1 to length(start.name) do begin					if (start.name[i] = chr(0)) & (start.name[i] = ':') then begin						typ := PT_None;						leave;					end;				end;			end;		end;		if typ in [PT_StartBlock, PT_File] then begin			if (MBpacket(header)[2] < 1) | (MBpacket(header)[2] > 31) then begin				typ := PT_None;			end;		end;		ValidateMBHeader := typ;	end;	procedure CatInfo2MBHeader (var pb: CInfoPBRec; var header: MBIIHeader; dtdbr: integer; var comment: Str255);		var			start: MBIIStartHeader;			fs: FSSpec;			folder: boolean;			ocrc: integer;	begin		folder := BAND(pb.ioFlAttrib, $10) <> 0;		MZero( @header, SizeOf(header) );		MFill(@start, SizeOf(start), 0);		header.version := ord(folder);		header.versionII := 129 + ord(folder);		header.minversionII := 129 + ord(folder);		start.name := pb.ioNamePtr^;		start.flags_high := BAND(BSR(pb.ioFlFndrInfo.fdFlags, 8), $FF);		start.flags_low := BAND(pb.ioFlFndrInfo.fdFlags, $FF);		start.flocation := pb.ioFlFndrInfo.fdLocation;		start.windowID := pb.ioFlFndrInfo.fdFldr;		start.create_date := pb.ioFlCrDat;		start.mod_date := pb.ioFlMdDat;		if folder then begin			start.ftype := macbin_folder_ftype;			start.fcreator := OSType(macbin_folder_creator_start);			start.dlen := 0;			start.rlen := 0;		end else begin			start.ftype := pb.ioFlFndrInfo.fdType;			start.fcreator := pb.ioFlFndrInfo.fdCreator;			start.dlen := pb.ioFlLgLen;			start.rlen := pb.ioFlRLgLen;		end;		fs.vRefNum := pb.ioVRefNum;		fs.parID := pb.ioFlParID;		fs.name := pb.ioNamePtr^;		GetDTDBComment(dtdbr, fs, comment);		start.clen := length(comment);		BlockMoveData(@start, @header.MBIIStart, SizeOf(start));		ocrc := 0;		CalcMBCRCBlock(@header, 124, ocrc);		header.crc := ocrc;	end;end.