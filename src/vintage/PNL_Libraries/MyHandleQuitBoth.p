unit MyHandleQuitBoth;interface	uses		Types;	procedure StartupHandleQuitBoth;	procedure ConfigureHandleQuitBoth (creator: OSType; both_index, justus_index: integer);implementation	uses		TextUtils, Menus,		MyTypes, MyProcesses, MyFMenus, MyStartup, MyOOMenus,		BaseGlobals;	var		quitBoth: boolean;		creatorType: OSType;		both, justus: integer;	procedure DoQuit;	begin		quitNow := true;		if quitBoth then begin			QuitApplication(creatorType, application);		end;	end;	procedure SetQuit (themenu, theitem: integer);		var			dummyb: boolean;			er: EventRecord;			nqb: boolean;			process: ProcessSerialNumber;			s: Str255;			fs: fileInfo;	begin		dummyb := GetOSEvent(0, er);		nqb := (BAND(er.modifiers, optionKey) <> 0) and FindProcess(creatorType, application, process, fs);		if nqb <> quitBoth then begin			quitBoth := nqb;			if quitBoth then begin				GetIndString(s, global_strh_id, both);			end else begin				GetIndString(s, global_strh_id, justus);			end;			SetMenuItemText(GetMenuHandle(themenu), theitem, s);		end;	end;	function InitHandleQuitBoth(var msg: integer): OSStatus;	begin{$unused(msg)}		quitBoth := false;		SetFBoth(Cquit, DoQuit, SetQuit);		InitHandleQuitBoth:= noErr;	end;	procedure ConfigureHandleQuitBoth (creator: OSType; both_index, justus_index: integer);	begin		creatorType := creator;		both := both_index;		justus := justus_index;	end;		procedure StartupHandleQuitBoth;	begin		StartupFMenus;		StartupOOMenus;		SetStartup(InitHandleQuitBoth, nil, 0,nil);	end;	end.