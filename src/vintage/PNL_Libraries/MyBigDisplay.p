unit MyBigDisplay;interface	type		StyleSetting = record				font: integer;				size: integer;				face: Style;			end;		ChunkKind = (CK_None, CK_Text, CK_Picture);		ChunkRecord = record				data_length: longint;				case kind : ChunkKind of					CK_Text: (							ss: StyleSetting;					);					CK_Picture: (					);			end;		LineRecord = record				offset: longint; { offset into chunks Handle }				ascent, descent: integer;				dataoffset: longint;			end;		LineRecordPtr = ^LineRecord;		LineRecordHandle = ^LineRecordPtr;		BigDisplay = record{ You can set these, and then call Recalc }				leading: integer;				width: integer;{ You can look, but don't touch }				port: GrafPtr;				total_height: longint;				line_count: longint;{ Don't even look }				chunks: Handle;				lines: LineRecordHandle;			end;	function CreateBigDisplay (var bd: BigDisplay; port: GrafPtr): OSErr;	procedure DestroyBigDisplay (var bd: BigDisplay);	function AddBDText (var bd: BigDisplay; var ss: StyleSetting; p: Ptr; len: longint): OSErr;	function RecalculateBigDisplay (var bd: BigDisplay): OSErr;implementation	uses		MyMemory;	procedure GetStyleSetting (var ss: StyleSetting);	begin		ss.font := thePort^.txFont;		ss.size := thePort^.txSize;		ss.face := thePort^.txFace;	end;	procedure SetStyleSetting (var ss: StyleSetting);	begin		TextFont(ss.font);		TextSize(ss.size);		TextFace(ss.face);	end;	function CreateBigDisplay (var bd: BigDisplay; port: GrafPtr): OSErr;		var			err: OSErr;	begin		bd.leading := 2;		bd.width := 200;		bd.port := port;		bd.total_height := 0;		bd.line_count := 0;		err := MNewHandle(bd.chunks, 0);		if err = noErr then			err := MNewHandle(bd.lines, 0);		CreateBigDisplay := err;	end;	procedure DestroyBigDisplay;	begin		MDisposeHandle(bd.chunks);		MDisposeHandle(bd.lines);	end;	function AddBDText (var bd: BigDisplay; font, size: integer; face: Style; p: Ptr; len: longint): OSErr;		var			err, junk: OSErr;			cr: ChunkRecord;			orgsize: longint;	begin		err := noErr;		if length(s) > 0 then begin			orgsize := GetHandleSize(bd.chunks);			cr.data_length := length(s);			cr.kind := CK_Text;			cr.font := font;			cr.size := size;			cr.face := face;			err := PtrAndHand(@cr, bd.chunks, SizeOf(ChunkRecord));			if err = noErr then				err := PtrAndHand(p, bd.chunks, len);			if err <> noErr then begin				SetHandleSize(bd.chunks, orgsize);			end;		end;		AddBDText := err;	end;	function RecalculateBigDisplay (var bd: BigDisplay; var height: longint): OSErr;		var			savedss: StyleSetting;			pos: longint;			line: longint;			offset, newoffset: longint;			cr: ChunkRecord;			lr: LineRecord;			h, w, used: integer;			fi: FontInfo;			slbc: StyledLineBreakCode;	begin		SetPort(bd.port);		GetStyleSetting(savedss);		pos := 0;		bd.total_height := 0;		bd.line_count := 0;		line := 1;		junk := MSetHandleSize(bd.lines, 0);		lr.offset := 0;		lr.ascent := 0;		lr.descent := 0;		lr.dataoffset := 0;		h := 0;		LockHigh(bd.chunks);		while pos < GetHandleSize(bd.chunks) do begin			BlockMove(Ptr(ord(bd.chunks^) + pos), @cr, SizeOf(ChunkRecord));			pos := pos + SizeOf(ChunkRecord);			offset := 0;			used := 0;			if cr.kind = CK_Text then begin				SetStylSetting(cr.ss);				GetFontInfo(fi);				if fi.ascent > lr.ascent then					lr.ascent := fi.ascent;				if fi.descent > lr.descent then					lr.descent := fi.descent;1:				w := width - used;				slbc := StyledLineBreak(Ptr(ord(bd.chunks^) + pos), cr.data_length, offset, cr.data_length, 0, w, newoffset);				if newoffset = offset then begin					if used = 0 then begin						newoffset := newoffset + 1; { force at least one character per line! }						w := width;					end					else begin						BreakLine;						goto 1;					end;				end;				used := used + w;			end;			pos := pos + cr.data_length;		end;		HUnLock(bd.chunks);		SetStyleSetting(savedss);	end;end.