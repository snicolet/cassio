unit MyForeBackGround;interface	const		def_stack = longint(24) * 1024;		def_masters = 10;	var		foreground_app: boolean;	procedure InitInForeOrBackground (back_stack, fore_stack: longint; back_masters, fore_masters: integer);implementation	uses		Types, Resources, Fonts, Windows, QuickDraw, Menus, TextEdit, Dialogs, Memory, LowMem,		MyTypes, MySizeResource;		{$IFC not GENERATINGPOWERPC}	function StackPtr: longint;	inline		$2E8F;{$ENDC}	procedure InitInForeOrBackground (back_stack, fore_stack: longint; back_masters, fore_masters: integer);		const			CurApNameA = $910;		var			size: sizeRsrc;			i: integer;			stack, masters: longint;{$IFC not undefined THINK_Pascal}			zero: Handle;{$ENDC}			applicationZone: THz;	begin{$IFC undefined THINK_Pascal}		InitGraf(@qd.thePort);{$ELSEC}		InitGraf(@thePort);{$ENDC}		GetSizeResource(size);		foreground_app := not size.only_background;{ Check if we are running in the environment }{$IFC not undefined THINK_Pascal}		zero := GetResource('ZERO', 0);		if (zero <> nil) & (HomeResFile(zero) <> CurResFile) then begin			foreground_app := true;		end;{$ENDC}		if foreground_app then begin			InitFonts;			InitWindows;			InitMenus;			TEInit;			InitDialogs(nil);			stack := fore_stack;			masters := fore_masters;		end else begin			stack := back_stack;			masters := back_masters;		end;		if stack = 0 then begin			stack := def_stack;		end;		if masters = 0 then begin			masters := def_masters;		end;{$IFC not GENERATINGPOWERPC}		SetApplLimit(Ptr(StackPtr - stack));{$ENDC}		MaxApplZone;		for i := 1 to masters do begin			MoreMasters;		end;		applicationZone := GetZone;		if applicationZone^.bkLim <> LMGetHeapEnd then begin			LMSetHeapEnd(applicationZone^.bkLim);		end;	end;end.