unit MyCTB;interface	uses		Connections;	function CTBInit: OSErr;	procedure CTBFinish;	function CTBJustConfigure: OSErr;	function CTBMakeConnection (var cn: connHandle): OSErr;	procedure CTBDestroy (var cn: connHandle);	function MyCMOpen (cn: ConnHandle; timeout: longint): OSErr;	function MyCMClose (cn: ConnHandle): OSErr;	function MyCMRead (cn: ConnHandle; buffer: univ Ptr; var size: longint): OSErr;	function MyCMWrite (cn: ConnHandle; buffer: univ Ptr; var size: longint): OSErr;	procedure MyCMIdle (cn: ConnHandle);	function MyCMDataAvailable (cn: ConnHandle): longint;implementation	uses		Resources, MyUtils, CommResources;	const		Buffer_Size = 10000;		userCancelled = -10;	var		RcvBuffer: Handle;	type		AsyncStuff = record				pending: boolean;				errCode: OSErr;				asyncCount: CMBufferSizes;			end;		AsyncStuffPtr = ^AsyncStuff;{$S Main}{$PUSH}{$D-}{ CTBComplete - completion routine }	procedure CTBComplete (cn: ConnHandle);		var			stuffP: AsyncStuffPtr;	begin		stuffP := AsyncStuffPtr(cn^^.refcon);		stuffP^.errCode := cn^^.errCode;		BlockMove(@cn^^.asyncCount, @stuffP^.asyncCount, SizeOf(CMBufferSizes));		stuffP^.pending := false;	end;{$POP}{$S}	function WaitOn (var b: boolean): OSErr;		var			er: EventRecord;			oe: OSErr;			dummy: boolean;	begin		oe := noErr;		while b do begin			dummy := WaitNextEvent(everyEvent, er, 5, nil);			if er.what = keyDown then begin				oe := userCancelled;				leave;			end;		end;		WaitOn := oe;	end;	procedure CTBTrouble (oe: OSErr);	begin		if oe <> noErr then			DebugStr(CharToString('CTBTrouble Error ', oe));	end;{ CTBExists - is the CTB installed? }	function CTBExists: boolean;		const			CTBTrap = $8B;			UnimplementedTrap = $9F;	begin		CTBExists := NGetTrapAddress(UnimplementedTrap, OSTrap) <> NGetTrapAddress(CTBTrap, OSTrap);{ Why not use Gestalt??? }	end;	function CTBGetTool (var tool: Str255; var procID: integer): OSErr;		var			oe: OSErr;	begin		oe := noErr;		tool := 'TGE TCP Tool';		procID := CMGetProcID(tool);		if procID < 0 then begin			oe := CRMGetIndToolName(classCM, 1, tool);			if (oe = noErr) and (tool = '') then				oe := -1;			if oe = noErr then begin				procID := CMGetProcID(tool);				if procID < 0 then					oe := -1;			end;		end;		CTBGetTool := oe;	end;	function CTBCreate (var cn: connHandle; procID: integer; flags: CMRecFlags): OSErr;		var			oe: OSErr;			bs: CMBufferSizes;	begin		oe := noErr;		BlockZero(@bs, sizeof(bs));		flags := cmNoMenus; { | cmQuiet? }		cn := CMNew(procID, flags, bs, 0, 0);		if cn = nil then			oe := -1;		CTBCreate := oe;	end;	function CTBConfigure (var cn: connHandle; var tool: Str255; must_config: boolean): OSErr;		var			oe: OSErr;			cfigH: Handle;			result: OSErr;			pt: Point;	begin		oe := noErr;		cfigH := GetNamedResource('CTfg', tool);		if cfigH <> nil then begin			if GetPtrSize(cn^^.config) = GetHandleSize(cfigH) then begin				BlockMove(cfigH^, cn^^.config, GetPtrSize(cn^^.config));				BlockMove(cfigH^, cn^^.oldConfig, GetPtrSize(cn^^.oldConfig));			end;			ReleaseResource(cfigH);		end;		if must_config | CMValidate(cn) then begin			SetPt(pt, 10, 40);			result := CMChoose(cn, pt, nil);			case result of				chooseDisaster, chooseFailed, chooseAborted: 					oe := result;				chooseOKMajor, chooseOKMinor:  begin				{ save the name string }					CMGetToolName(cn^^.procID, tool);					BlockMove(cn^^.config, cn^^.oldConfig, GetPtrSize(cn^^.config));				end;				otherwise					;			end;		end;		CTBConfigure := oe;	end;	procedure CTBDestroy (var cn: connHandle);	begin		if cn <> nil then begin			CMDispose(cn);			cn := nil;		end;	end;{ Configure tool and save configurationo prefs file - yeah right :-}	function CTBJustConfigure: OSErr;		var			tool: Str255;			procID: integer;			oe: OSErr;			cn: connHandle;	begin		oe := CTBGetTool(tool, procID);		if oe = noErr then			oe := CTBCreate(cn, procID, cmNoMenus);		if oe = noErr then begin			oe := CTBConfigure(cn, tool, true);			CTBDestroy(cn);		end;		CTBJustConfigure := oe;	end;{ Create a connection and configure it if necessary }	function CTBMakeConnection (var cn: connHandle): OSErr;		var			tool: Str255;			procID: integer;			oe: OSErr;	begin		oe := CTBGetTool(tool, procID);		if oe = noErr then			oe := CTBCreate(cn, procID, cmNoMenus);		if oe = noErr then begin			oe := CTBConfigure(cn, tool, false);			if oe <> noErr then				CTBDestroy(cn);		end;		CTBMakeConnection := oe;	end;{ InitCTB - initialize the CommToolbox }	function CTBInit: OSErr;		var			oe: OSErr;	begin		RcvBuffer := nil;		oe := noErr;		if not CTBExists then			oe := cmGenericError;		if oe = noErr then			oe := InitCTBUtilities;		if oe = noErr then			oe := InitCRM;		if oe = noErr then			oe := InitCM;		CTBInit := oe;	end;	procedure CTBFinish;	begin	end;{ MyCMOpen - call CMOpen }	function MyCMOpen (cn: ConnHandle; timeout: longint): OSErr;	begin		MyCMOpen := CMOpen(cn, false, nil, timeout);	end;{ MyCMClose - call CMClose }	function MyCMClose (cn: ConnHandle): OSErr;	begin		MyCMClose := CMClose(cn, false, nil, -1, true);	end;{ MyCMRead - call CMRead }	function MyCMReadAsync (cn: ConnHandle; buffer: univ Ptr; var size: longint; timeout: longint): OSErr;		var			oe: OSErr;			stuff: AsyncStuff;			junk: CMFlags;	begin		cn^^.refcon := ord(@stuff);		stuff.pending := true;		oe := CMRead(cn, buffer, size, cmData, true, @CTBComplete, timeout, junk);		if oe = noErr then begin			oe := WaitOn(stuff.pending);			if oe = noErr then				oe := stuff.errCode;			if oe = userCancelled then				oe := CMIOKill(cn, ord(cmDataIn));		end		else begin			size := 0;		end;		MyCMReadAsync := oe;	end;	function MyCMRead (cn: ConnHandle; buffer: univ Ptr; var size: longint): OSErr;		var			oe: OSErr;			junk: CMFlags;	begin		oe := CMRead(cn, buffer, size, cmData, false, nil, 1, junk);		MyCMRead := oe;	end;{ MyCMWrite - call CMWrite }	function MyCMWriteAsync (cn: ConnHandle; buffer: univ Ptr; var size: longint): OSErr;		var			oe: OSErr;			stuff: AsyncStuff;	begin		cn^^.refcon := ord(@stuff);		stuff.pending := true;		oe := CMWrite(cn, buffer, size, cmData, true, @CTBComplete, -1, 0);		if oe = noErr then begin			oe := WaitOn(stuff.pending);			if oe = noErr then				oe := stuff.errCode;			if oe = userCancelled then				oe := CMIOKill(cn, ord(cmDataOut));		end;		if oe = noErr then			size := stuff.asyncCount[cmDataOut]		else			size := 0;		CTBTrouble(oe);		MyCMWriteAsync := oe;	end;{ MyCMWrite - call CMWrite }	function MyCMWrite (cn: ConnHandle; buffer: univ Ptr; var size: longint): OSErr;		var			oe: OSErr;	begin		oe := CMWrite(cn, buffer, size, cmData, false, nil, -1, 0);		MyCMWrite := oe;	end;{ MyCMIdle - do the things I should do at CMIdle time }	procedure MyCMIdle (cn: connHandle);	begin		CMIdle(cn);	end;{ CTBDataCount - how much data do we have? }	function MyCMDataAvailable (cn: connHandle): longint;		var			flags: CMStatFlags;			sizes: CMBufferSizes;			oe: OSErr;	begin		oe := CMStatus(cn, sizes, flags);		if (oe = noErr) and (BAND(flags, cmStatusDataAvail) <> 0) then			MyCMDataAvailable := sizes[cmDataIn]		else			MyCMDataAvailable := 0;	end;end.