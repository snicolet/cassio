unit CalcCRC;interface	uses		Types;	var		crctabl:Handle;		procedure StartupCalcCRC;	procedure CalcMBCRC (var crc: integer; v: integer);	procedure CalcMBCRCBlock (p: univ Ptr; len: longint; var crc: integer);implementation	uses		Resources, Errors, ToolUtils,		MyStartup;			type		CRCTablArray = array[0..255] of integer;		CRCTablArrayPtr = ^CRCTablArray;		CRCTablArrayHandle = ^CRCTablArrayPtr;{$IFC GENERATINGPOWERPC}	procedure CalcMBCRC (var crc: integer; v: integer);	begin		crc:=BXOR(CRCTablArrayHandle(crctabl)^^[BAND(BXOR(BSR(crc,8),v),$FF)],BSL(crc,8));	end;	procedure CalcMBCRCBlock (p: univ Ptr; len: longint; var crc: integer);		var			cp:CRCTablArrayPtr;	begin		cp:=CRCTablArrayHandle(crctabl)^;		while len>0 do begin			crc:=BXOR(CRCTablArrayHandle(crctabl)^^[BAND(BXOR(BSR(crc,8),BAND(p^,$FF)),$FF)],BSL(crc,8));			inc(longint(p));			dec(len);		end;	end;{$ELSEC}	procedure CalcMBCRCTabl (crctabl:Handle; var crc: integer; v: integer);     external;	procedure CalcMBCRCBlockTabl (crctabl:Handle; p: univ Ptr; len: longint; var crc: integer);     external;	procedure CalcMBCRC (var crc: integer; v: integer);	begin		CalcMBCRCTabl(crctabl,crc,v);	end;		procedure CalcMBCRCBlock (p: univ Ptr; len: longint; var crc: integer);	begin		CalcMBCRCBlockTabl(crctabl,p,len,crc);	end;{$ENDC}	function InitCalcCRC(var msg: integer):OSStatus;		var			err:OSErr;	begin{$unused(msg)}		crctabl:=Get1Resource('CRCt',128);		if crctabl<>nil then begin			MoveHHi(crctabl);			HLock(crctabl); { Must be locked, since these routines can be called at interupt time }			err:=noErr;		end else begin			err:=resNotFound;		end;		InitCalcCRC:=err;	end;	procedure StartupCalcCRC;	begin		SetStartup(InitCalcCRC, nil, 0, nil);	end;end.