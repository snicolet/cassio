unit MyListManager;interface	uses		Types, Lists;			type		LClickSafeProc = function( list: ListHandle; refcon: univ longint ):boolean;		function LCount( list: ListHandle ): integer;	function LCountSelections (list: ListHandle): integer;	function LHasSelection (list: ListHandle): boolean;	function LAllSelected( list: ListHandle ): boolean;	procedure LSetSingleSelection (list: ListHandle; v: integer);	procedure LSetAllSelections ( list: ListHandle; on: boolean);	function LPointToCell (list: ListHandle; pt: Point; var c: Cell): boolean;	function LGetFirstSelection (list: ListHandle; var c: Cell): boolean;	function LGetLastSelection (list: ListHandle; var c: Cell): boolean;	function LClickSafe(localPt:Point; modifiers:integer; list:ListRef; proc: LClickSafeProc; refcon: univ longint ):boolean;implementation	uses		OSUtils, Traps, Quickdraw;			function LCount( list: ListHandle ): integer;	begin		LCount := list^^.dataBounds.bottom;	end;		function LCountSelections (list: ListHandle): integer;		var			c: Cell;			count: integer;	begin		count := 0;		c.h := 0;		c.v := 0;		while LGetSelect(true, c, list) do begin			count := count + 1;			c.v := c.v + 1;		end;		LCountSelections := count;	end;	function LHasSelection (list: ListHandle): boolean;		var			c: Cell;	begin		c.h := 0;		c.v := 0;		LHasSelection := LGetSelect(true, c, list);	end;	function LAllSelected( list: ListHandle ): boolean;		var			c: Cell;			i: integer;	begin		LAllSelected := true;		for i := 0 to LCount( list ) - 1 do begin			c.h := 0;			c.v := i;			if not LGetSelect( false, c, list ) then begin				LAllSelected := false;				leave;			end;		end;	end;		procedure LSetAllSelections ( list: ListHandle; on: boolean);		var			i: integer;			c: Cell;	begin		for i := 0 to LCount( list ) - 1 do begin			c.h := 0;			c.v := i;			LSetSelect(on, c, list);		end;	end;	procedure LSetSingleSelection (list: ListHandle; v: integer);		var			c: Cell;	begin		c.h := 0;		c.v := v;		LSetSelect(true, c, list);		c.v := 0;		c.h := 0;		while LGetSelect(true, c, list) do begin			if c.v <> v then begin				LSetSelect(false, c, list);			end;			c.v := c.v + 1;			c.h := 0;		end;	end;	function LPointToCell (list: ListHandle; pt: Point; var c: Cell): boolean;	begin		c.h := 0;		c.v := -1;		if PtInRect(pt, list^^.rView) then begin			c.v := list^^.visible.top + (pt.v - list^^.rView.top) div list^^.cellSize.v;		end;		LPointToCell := PtInRect(c, list^^.dataBounds);	end;	function LGetLastSelection (list: ListHandle; var c: Cell): boolean;		var			tmp: integer;	begin		LGetLastSelection := false;		c.h := 0;		c.v := 0;		while LGetSelect(true, c, list) do begin			LGetLastSelection := true;			tmp := c.v;			c.v := c.v + 1;		end;		c.v := tmp;	end;	function LGetFirstSelection (list: ListHandle; var c: Cell): boolean;	begin		c.h := 0;		c.v := 0;		LGetFirstSelection := LGetSelect(true, c, list);	end;	var		hack_lclick_proc: LClickSafeProc;		hack_lclick_list: ListHandle;		hack_lclick_refcon: longint;		function LClickProc: boolean;	begin		LClickProc := hack_lclick_proc( hack_lclick_list, hack_lclick_refcon );	end;{$IFC not GENERATINGPOWERPC}(* *	LClickGlue() * *	On 68K, an LClickProc needs to return the result in the Z register. *	This is pretty hard to do from a 'real' function; so this glue function *	calls the 'real' LClickProc() function and then tests the return value *	in D0 to set the Z bit based on the return result from the function. *)	procedure LClickGlue; asm;	begin		CLR.W		-(SP)		JSR 			LClickProc		MOVE.B		(SP)+, D0		TST.B		D0		RTS	end;	{$ENDC}	function LClickSafe(localPt:Point; modifiers:integer; list:ListRef; proc: LClickSafeProc; refcon: univ longint ):boolean;		var			savedcl: ProcPtr;			listClickUPP: UniversalProcPtr;	begin		if proc = nil then begin			LClickSafe := LClick(localPt, modifiers, list);		end else begin			hack_lclick_proc := proc;			hack_lclick_list := list;			hack_lclick_refcon := refcon;			savedcl := list^^.lClickLoop;{$IFC GENERATINGPOWERPC}			listClickUPP := NewListClickLoopProc( @LClickProc );{$ELSEC}			listClickUPP := NewListClickLoopProc( @LClickGlue );{$ENDC}			list^^.lClickLoop := listClickUPP;			LClickSafe := LClick(localPt, modifiers, list);			list^^.lClickLoop := savedcl;			hack_lclick_proc := nil;		end;	end;	end.