unit MyOSQueues;interface	uses		OSUtils;			type		MyQElem = record				qLink: QElemPtr;				qType: integer;			end;		MyQElemPtr = ^MyQElem;	procedure XEnqueue (qElement: QElemPtr; qHeader: QHdrPtr);	function XDequeue (qElement: QElemPtr; qHeader: QHdrPtr): OSErr;	procedure Enque (var queue: QHdr; pbp: univ MyQElemPtr; event: integer);	function Deque (var queue: QHdr; pbp: univ MyQElemPtr; var event: integer): boolean;	procedure AddEvent (var events: QHdr; pbp: univ MyQElemPtr; event: integer);	function GetEvent (var events: QHdr; var pbp: univ MyQElemPtr; var event: integer): boolean;implementation	uses		MyAssertions;	procedure XEnqueue (qElement: QElemPtr; qHeader: QHdrPtr);	begin{    Assert(qElement^.ioQElem.qLink = nil);}		Enqueue(qElement, qHeader);	end;	function XDequeue (qElement: QElemPtr; qHeader: QHdrPtr): OSErr;		var			err: OSErr;	begin		err := Dequeue(qElement, qHeader);		if err = noErr then begin			qElement^.qLink := nil;		end;		XDequeue := err;	end;	procedure Enque (var queue: QHdr; pbp: univ MyQElemPtr; event: integer);	begin		pbp^.qType := event;		XEnqueue(QElemPtr(pbp), @queue);	end;	procedure AddEvent (var events: QHdr; pbp: univ MyQElemPtr; event: integer);	begin		pbp^.qType := event;		XEnqueue(QElemPtr(pbp), @events);	end;	function Deque (var queue: QHdr; pbp: univ MyQElemPtr; var event: integer): boolean;		var			oe: OSErr;	begin		Deque := false;		if pbp <> nil then begin			oe := XDequeue(QElemPtr(pbp), @queue);			if oe = noErr then begin				event := pbp^.qType;				Deque := true;			end;		end;	end;	function GetEvent (var events: QHdr; var pbp: univ MyQElemPtr; var event: integer): boolean;	begin		pbp := MyQElemPtr(events.qHead);		GetEvent := Deque(events, pbp, event);	end;end.