unit MyDialogs;interface	uses		Types, Quickdraw, Controls, Events, TextEdit, Windows, Dialogs, Menus,		MyUtils;	const		i_ok = 1;		i_cancel = 2;		i_discard = 3;	var		grey_pattern: PixPatHandle;	var		gStandardModalFilterProc:UniversalProcPtr;		gCancelModalFilterProc:UniversalProcPtr;		gDiscardModalFilterProc:UniversalProcPtr;		gOutlineDefault1Proc:UniversalProcPtr;			procedure StartupDialogs;	procedure SetMyDialogFont(ft:MyFontType);	procedure EnterWindow (window: WindowPtr; ft:MyFontType; face: Style; var saved: SavedWindowInfo);	procedure ExitWindow (saved: SavedWindowInfo);	procedure SetItemText (window: DialogPtr; item: integer; text: Str255);	procedure GetItemText (window: DialogPtr; item: integer; var text: Str255);	function GetItemTextF (window: DialogPtr; item: integer): Str255;	procedure OutlineDefault1ForeBackground (window: DialogPtr; item: integer; foreground: Boolean);	procedure OutlineDefault1 (window: DialogPtr; item: integer);	procedure SetUpDefaultOutline(window: DialogPtr; def_item, user_item: integer; sethandler: Boolean);	procedure FlashDItem (window: DialogPtr; item: integer);	procedure SetDItemRect (window: DialogPtr; item: integer; rr: Rect);	procedure GetDItemRect (window: DialogPtr; item: integer; var rr: Rect);	procedure SetDItemKind (window: DialogPtr; item: integer; k: integer);	procedure GetDItemKind (window: DialogPtr; item: integer; var k: integer);	function IsControlDialogKind( kind: integer ): boolean;	procedure OffsetDItem( window: DialogPtr; item: integer; dh, dv: integer );	function GetDControlHandle (window: DialogPtr; item: integer): ControlHandle;	function GetDItemHandle (window: DialogPtr; item: integer): Handle;{	procedure SetDItemHandle (window: DialogPtr; item: integer; h: univ Handle);}	procedure SetUserItemProc (window: DialogPtr; item: integer; proc: UniversalProcPtr);	function GetDCtlEnable (window: DialogPtr; item: integer): boolean;	procedure SetDCtlEnable (window: DialogPtr; item: integer; on: boolean);	function GetDCtlTitle (window: DialogPtr; item: integer): Str255;	procedure SetDCtlTitle (window: DialogPtr; item: integer; s: Str255);	function GetDCtlBoolean (window: DialogPtr; item: integer): boolean;	procedure SetDCtlBoolean (window: DialogPtr; item: integer; value: boolean);	procedure ToggleDCtlBoolean (window: DialogPtr; item: integer);	function GetDCtlValue (window: DialogPtr; item: integer): integer;	procedure SetDCtlValue (window: DialogPtr; item: integer; value: integer);	function GetDCtlMax (window: DialogPtr; item: integer): integer;	procedure SetDCtlMax (window: DialogPtr; item: integer; value: integer);	function GetDCtlMin (window: DialogPtr; item: integer): integer;	procedure SetDCtlMin (window: DialogPtr; item: integer; value: integer);	function GetDCtlHilite (window: DialogPtr; item: integer): integer;	procedure SetDCtlHilite (window: DialogPtr; item: integer; hilite: integer);	procedure DrawDItem (window: DialogPtr; item: integer);	function GetPopupMHandle (window: DialogPtr; item: integer): MenuHandle;	procedure SetPopUpMenuOnMouseDown (window: DialogPtr; item: integer; text: Str255);	procedure GetPopUpItemText (window: DialogPtr; item: integer; var text: Str255);	procedure SetWindowTitle (window: WindowPtr; title: Str255);	function SelectedTextItem (window: DialogPtr): integer;	procedure SelectDialogItem(window: DialogPtr; item: integer);	procedure GetDialogTextSelection(window: DialogPtr; var item, start, fin: integer);	procedure DrawTheFriggingGrowIcon (window: WindowPtr; bounds: Rect);	procedure DisplayStyledString (window: DialogPtr; item: integer; s: Str255);{ s= "font:size:style:just:text" }	procedure DrawStyledTextUserItem( window: DialogPtr; item: integer; ft: MyFontType; face: Style; const data: Str255 );	procedure ShiftTab (window: DialogPtr);	procedure ManualTab (window: DialogPtr; shift: boolean);	function CountDItems (window: DialogPtr): integer;	procedure DrawGrayRect (window: DialogPtr; item: integer; title: Str255);	procedure SetDialogTextFont (window: DialogPtr; ft:MyFontType; face: Style);	function StandardModalFilter (window: DialogPtr; var er: EventRecord; var item: integer): boolean;	function CancelModalFilter (window: DialogPtr; var er: EventRecord; var item: integer): boolean;	function DiscardModalFilter (window: DialogPtr; var er: EventRecord; var item: integer): boolean;	function TrackItems(window:WindowPtr; i1,i2,i3:integer):boolean;	function PointOverEditTextItem( window: WindowPtr; localwhere: Point ): integer;	function OverEditTextItem: Boolean;	procedure StyleTextBox( text: Handle; styles: StScrpHandle; var box: Rect; just: integer);	procedure DialogGetTextDropInformation( window: DialogPtr; localwhere: Point; var field: integer; var offset: integer; hilite: RgnHandle; invert: RgnHandle );{	procedure GetDAFont (var font: integer);  -- use LMGetDlgFont }implementation	uses		QuickdrawText, Fonts, Memory, Palettes, OSUtils, TextUtils, 		MyTypes, MyStrings, MyUtils, MyMemory, MySystemGlobals, MyStartup, 		MyEvents, MyAssertions;			var		gOutlineDeviceLoopProc:UniversalProcPtr;	{$ifc not do_debug}{$definec AssertValidDialogItem(w,i)}{$elsec}{$definec AssertValidDialogItem(w,i) AssertValidDialogItemCode(w,i)}{$endc}	procedure AssertValidDialogItemCode( window: DialogPtr; item: integer );	begin		Assert( (window <> nil) & (0 < item) & (item <= CountDItems(window)) );	end;		procedure PenPatGray;	begin		if grey_pattern = nil then begin			PenPat(GetQDGlobals^.gray);		end else begin			PenPixPat(grey_pattern);		end;	end;	procedure SetItemText (window: DialogPtr; item: integer; text: Str255);		var			it: integer;			ih: Handle;			box: Rect;			oldtext: Str255;	begin		AssertValidDialogItem( window, item );		GetDialogItem(window, item, it, ih, box);		GetDialogItemText(ih, oldtext);		if oldtext <> text then begin			SetDialogItemText(ih, text);		end;	end;	procedure GetItemText (window: DialogPtr; item: integer; var text: Str255);		var			it: integer;			ih: Handle;			box: Rect;	begin		AssertValidDialogItem( window, item );		GetDialogItem(window, item, it, ih, box);		GetDialogItemText(ih, text);	end;	function GetItemTextF (window: DialogPtr; item: integer): Str255;		var			text: Str255;	begin		AssertValidDialogItem( window, item );		GetItemText(window, item, text);		GetItemTextF := text;	end;	var		gODRect:Rect;		gODEnabled:Boolean;			procedure OutlineDeviceLoop (depth: integer; deviceFlags: integer; targetDevice: GDHandle; ignore:longint);		var			backGround,foreGround:RGBColor;			dummy:boolean;	begin{$unused(deviceFlags, ignore)}		if not gODEnabled then begin			if depth=1 then begin				PenPat(GetQDGlobals^.gray);			end else begin				MakeRGBColor($0000,$0000,$0000,backGround);				MakeRGBColor($0000FFFF,$0000FFFF,$0000FFFF,foreGround);				dummy:=GetGray(targetDevice,backGround,foreGround);				RGBForeColor(foreGround);			end;		end;		FrameRoundRect(gODRect, 16, 16);		PenPat(GetQDGlobals^.black);		ForeColor(blackColor);	end;		procedure OutlineDefault1ForeBackground(window: DialogPtr; item: integer; foreground: Boolean);	begin		AssertValidDialogItem( window, item );		SetPort(window);		GetDItemRect(window, item, gODRect);		InsetRect(gODRect, 2, 2);		gODEnabled := GetDCtlEnable(window, 1) & (FrontWindow = window) & foreground;		PenSize(3, 3);		SafeDeviceLoopRect(gODRect, gOutlineDeviceLoopProc, 0, 0);		PenNormal;	end;	procedure OutlineDefault1(window: DialogPtr; item: integer);	begin		OutlineDefault1ForeBackground( window, item, InForeground );	end;	procedure SetUpDefaultOutline(window: DialogPtr; def_item, user_item: integer; sethandler: Boolean);		var			box: Rect;{$ifc do_debug}			kind: integer;{$endc}	begin{$ifc do_debug}		AssertValidDialogItem( window, def_item );		AssertValidDialogItem( window, user_item );		GetDItemKind( window, def_item, kind );		Assert( band(kind,bnot(itemDisable)) = ctrlItem + btnCtrl );		GetDItemKind( window, user_item, kind );		Assert( band(kind,bnot(itemDisable)) = userItem );		Assert( gOutlineDefault1Proc <> nil );{$endc}		GetDItemRect( window, def_item, box);		InsetRect( box, -6,-6 );		SetDItemRect( window, user_item, box );		if sethandler then begin			SetUserItemProc( window, user_item, gOutlineDefault1Proc );		end;	end;	procedure FlashDItem(window: DialogPtr; item: integer);		var			f: longint;	begin		AssertValidDialogItem( window, item );		SetDCtlHilite(window, item, kControlButtonPart);		Delay(2, f);		SetDCtlHilite(window, item, 0);	end;	procedure SetDItemRect (window: DialogPtr; item: integer; rr: Rect);		var			kind: integer;			h: Handle;			r: Rect;	begin		AssertValidDialogItem( window, item );		GetDialogItem(window, item, kind, h, r);		SetDialogItem(window, item, kind, h, rr);	end;	procedure GetDItemRect (window: DialogPtr; item: integer; var rr: Rect);		var			kind: integer;			h: Handle;	begin		AssertValidDialogItem( window, item );		GetDialogItem(window, item, kind, h, rr);	end;	procedure SetDItemKind (window: DialogPtr; item: integer; k: integer);		var			kk: integer;			h: Handle;			r: Rect;	begin		AssertValidDialogItem( window, item );		GetDialogItem(window, item, kk, h, r);		SetDialogItem(window, item, k, h, r);	end;	procedure GetDItemKind (window: DialogPtr; item: integer; var k: integer);		var			r: Rect;			h: Handle;	begin		GetDialogItem(window, item, k, h, r);	end;	function IsControlDialogKind( kind: integer ): boolean;	begin		IsControlDialogKind := band( kind, bnot(itemDisable) )- ctrlItem in [btnCtrl, chkCtrl, radCtrl, resCtrl];	end;		procedure OffsetDItem( window: DialogPtr; item: integer; dh, dv: integer );		var			kind: integer;			data: Handle;			r: Rect;	begin		AssertValidDialogItem( window, item );		GetDialogItem( window, item, kind, data, r );		OffsetRect( r, dh, dv );		SetDialogItem( window, item, kind, data, r );		if IsControlDialogKind( kind ) then begin			MoveControl( ControlHandle( data ), r.left, r.top );		end;	end;		function GetDControlHandle (window: DialogPtr; item: integer): ControlHandle;	begin		GetDControlHandle := ControlHandle(GetDItemHandle(window, item));	end;	function GetDItemHandle (window: DialogPtr; item: integer): Handle;		var			kind: integer;			h: Handle;			r: Rect;	begin		AssertValidDialogItem( window, item );		GetDialogItem(window, item, kind, h, r);		GetDItemHandle := h;	end;	procedure SetDItemHandle (window: DialogPtr; item: integer; h: univ Handle);		var			kind: integer;			hh: Handle;			r: Rect;	begin		AssertValidDialogItem( window, item );		GetDialogItem(window, item, kind, hh, r);		SetDialogItem(window, item, kind, h, r);	end;	procedure SetUserItemProc (window: DialogPtr; item: integer; proc: UniversalProcPtr);		var			kind: integer;			hh: Handle;			r: Rect;	begin		Assert( proc <> nil );		AssertValidDialogItem( window, item );		GetDialogItem(window, item, kind, hh, r);		Assert( band(kind,bnot(itemDisable)) = userItem );		SetDialogItem(window, item, kind, Handle(proc), r);	end;		function GetDCtlHilite (window: DialogPtr; item: integer): integer;	begin		GetDCtlHilite := ControlHandle(GetDItemHandle(window, item))^^.contrlHilite;	end;	procedure SetDCtlHilite (window: DialogPtr; item: integer; hilite: integer);		var			ch: ControlHandle;	begin		ch := ControlHandle(GetDItemHandle(window, item));		if ch^^.contrlHilite <> hilite then begin			HiliteControl(ch, hilite);		end;	end;	function GetDCtlEnable (window: DialogPtr; item: integer): boolean;	begin		GetDCtlEnable := GetDCtlHilite(window, item) <> 255;	end;	procedure SetDCtlEnable (window: DialogPtr; item: integer; on: boolean);	begin		SetDCtlHilite(window, item, 255 * ord(not on))	end;	function GetDCtlTitle (window: DialogPtr; item: integer): Str255;		var			s: Str255;	begin		GetControlTitle(GetDControlHandle(window, item), s);		GetDCtlTitle := s;	end;	procedure SetDCtlTitle (window: DialogPtr; item: integer; s: Str255);		var			ch: ControlHandle;			old: Str255;	begin		ch := GetDControlHandle(window, item);		GetControlTitle(ch, old);		if old <> s then begin			SetControlTitle(ch, s);		end;	end;	function GetDCtlBoolean (window: DialogPtr; item: integer): boolean;	begin		GetDCtlBoolean := GetControlValue(GetDControlHandle(window, item)) <> 0;	end;	procedure SetDCtlBoolean (window: DialogPtr; item: integer; value: boolean);	begin		SetControlValue(GetDControlHandle(window, item), ord(value));	end;	procedure ToggleDCtlBoolean (window: DialogPtr; item: integer);	begin		SetDCtlBoolean(window, item, not GetDCtlBoolean(window, item));	end;	function GetDCtlValue (window: DialogPtr; item: integer): integer;	begin		GetDCtlValue := GetControlValue(GetDControlHandle(window, item));	end;	procedure SetDCtlValue (window: DialogPtr; item: integer; value: integer);	begin		SetControlValue(GetDControlHandle(window, item), value);	end;	function GetDCtlMax (window: DialogPtr; item: integer): integer;	begin		GetDCtlMax := GetControlMaximum(GetDControlHandle(window, item));	end;	procedure SetDCtlMax (window: DialogPtr; item: integer; value: integer);	begin		SetControlMaximum(GetDControlHandle(window, item), value);	end;	function GetDCtlMin (window: DialogPtr; item: integer): integer;	begin		GetDCtlMin := GetControlMinimum(GetDControlHandle(window, item));	end;	procedure SetDCtlMin (window: DialogPtr; item: integer; value: integer);	begin		SetControlMinimum(GetDControlHandle(window, item), value);	end;	procedure DrawDItem (window: DialogPtr; item: integer);	begin		Draw1Control(GetDControlHandle(window, item));	end;	function GetPopupMHandle (window: DialogPtr; item: integer): MenuHandle;		type			MenuHandlePtr = ^MenuHandle;			MenuHandleHandle = ^MenuHandlePtr;	begin		GetPopupMHandle := MenuHandleHandle(GetDControlHandle(window, item)^^.contrlData)^^;	end;	procedure SetPopUpMenuOnMouseDown (window: DialogPtr; item: integer; text: Str255);		var			mh: MenuHandle;			i, index: integer;			s: Str255;	begin		mh := GetPopupMHandle(window, item);		if text = '' then begin			GetMenuItemText(mh, 1, text);		end;		GetMenuItemText(mh, 2, s);		if s = '-' then begin			DeleteMenuItem(mh, 2);			DeleteMenuItem(mh, 1);		end;		index := 0;		for i := 1 to CountMItems(mh) do begin			GetMenuItemText(mh, i, s);			if (IUEqualString(s, text) = 0) then begin				index := i;				leave;			end;		end;		if index = 0 then begin			InsertMenuItem(mh, '(-;fred', 0);			SetMenuItemText(mh, 1, text);			index := 1;		end;		SetDCtlValue(window, item, index);	end;	procedure GetPopUpItemText (window: DialogPtr; item: integer; var text: Str255);		var			mh: MenuHandle;	begin		mh := GetPopupMHandle(window, item);		GetMenuItemText(GetPopupMHandle(window, item), GetDCtlValue(window, item), text);	end;	procedure SetWindowTitle (window: WindowPtr; title: Str255);		var			s: Str255;	begin		Assert( window <> nil );		GetWTitle(window, s);		if s <> title then begin			SetWTitle(window, title);		end;	end;	function SelectedTextItem (window: DialogPtr): integer;	begin		Assert( window <> nil );		SelectedTextItem := DialogPeek(window)^.editField + 1;	end;	procedure SelectDialogItem(window: DialogPtr; item: integer);	begin		AssertValidDialogItem( window, item );		SelectDialogItemText(window, item, 0, maxint);	end;		procedure GetDialogTextSelection(window: DialogPtr; var item, start, fin: integer);	begin		Assert( window <> nil );		item := SelectedTextItem( window );		if item > 0 then begin			start := DialogPeek(window)^.textH^^.selStart;			fin := DialogPeek(window)^.textH^^.selEnd;		end else begin			start := -1;			fin := -1;		end;		if item > 0 then begin			AssertValidDialogItem( window, item );		end;	end;		function CountDItems (window: DialogPtr): integer;	begin		Assert( window <> nil );{    count := CountDITL(window);}		CountDItems := integerH(DialogPeek(window)^.items)^^ + 1;	end;	procedure ManualTab (window: DialogPtr; shift: boolean);		var			orgitem, i, count: integer;			k: integer;	begin		Assert( window <> nil );		orgitem := SelectedTextItem(window);		count := CountDItems(window);		if (orgitem > 0) & (count > 1) then begin			i := orgitem;			repeat				if shift then begin					i := i - 1;					if i = 0 then begin						i := count;					end;				end else begin					i := i + 1;					if i > count then begin						i := 1;					end;				end;				GetDItemKind(window, i, k);			until (i = orgitem) | (k = editText);		end;		GetDItemKind(window, i, k);		if k = editText then begin			SelectDialogItem(window, i);		end;	end;	procedure ShiftTab (window: DialogPtr);		var			orgitem, i, count: integer;			k: integer;	begin		Assert( window <> nil );		orgitem := SelectedTextItem(window);		count := CountDItems(window);		if (orgitem > 0) & (count > 1) then begin			i := orgitem;			repeat				i := i - 1;				if i = 0 then begin					i := count;				end;				GetDItemKind(window, i, k);			until (i = orgitem) | (k = editText);		end;		GetDItemKind(window, i, k);		if k = editText then begin			SelectDialogItem(window, i);		end;	end;	procedure DrawTheFriggingGrowIcon (window: WindowPtr; bounds: Rect);		var			clip: RgnHandle;	begin		Assert( window <> nil );		SetPort(window);		PenNormal;		clip := NewRgn;		GetClip(clip);		ClipRect(bounds);		DrawGrowIcon(window);		SetClip(clip);		DisposeRgn(clip);	end;	function DoButtonKey(window:DialogPtr; item:integer; var er: EventRecord; var item_hit:integer):boolean;	begin		if GetDCtlEnable(window,item) then begin			FlashDItem(window, item);			item_hit:=item;			DoButtonKey := true;		end else begin			SysBeep(10);			er.what:=nullEvent;			DoButtonKey := false;		end;	end;		function StandardModalFilter (window: DialogPtr; var er: EventRecord; var item: integer): boolean;	begin		Assert( window <> nil );		StandardModalFilter := false;		if EventIsKeyDown( er ) & EventHasOK( er ) then begin			StandardModalFilter:= DoButtonKey(window, i_ok, er, item);		end;	end;	function CancelModalFilter (window: DialogPtr; var er: EventRecord; var item: integer): boolean;	begin		Assert( window <> nil );		CancelModalFilter := false;		if StandardModalFilter(window, er, item) then begin			CancelModalFilter := true;		end else if EventIsKeyDown( er ) & EventHasCancel( er ) then begin			CancelModalFilter:= DoButtonKey(window, i_cancel, er, item);		end;	end;	function DiscardModalFilter (window: DialogPtr; var er: EventRecord; var item: integer): boolean;	begin		Assert( window <> nil );		DiscardModalFilter := false;		if CancelModalFilter(window, er, item) then begin			DiscardModalFilter := true;		end else if EventIsKeyDown( er ) & EventHasDiscard( er ) then begin			DiscardModalFilter:= DoButtonKey(window, i_discard, er, item);		end;	end;	procedure SetMyDialogFont(ft:MyFontType);		var			font, size:integer;	begin		GetMyFonts(ft, font, size);		SetDialogFont(font);	end;	procedure EnterWindow (window: WindowPtr; ft:MyFontType; face: Style; var saved: SavedWindowInfo);	begin		Assert( window <> nil );		GetPort(saved.oldport);		SetPort(window);		saved.thisport := window;		saved.font := window^.txFont;		saved.size := window^.txSize;		saved.face := window^.txFace;		SetMyFont(ft);		TextFace(face);		Assert( saved.thisport <> nil );	end;	procedure ExitWindow (saved: SavedWindowInfo);	begin		Assert( saved.thisport <> nil );		SetPort(saved.thisport);		TextFont(saved.font);		TextSize(saved.size);		TextFace(saved.face);		SetPort(saved.oldport);	end;	procedure SetDialogTextFont (window: DialogPtr; ft:MyFontType; face: Style);		var			saved: SavedWindowInfo;			fi: FontInfo;			te: TEHandle;			font, size: integer;	begin		EnterWindow(window, ft, face, saved);		GetFontInfo(fi);		GetMyFonts(ft, font, size);		te := DialogPeek(window)^.textH;		te^^.txFont := font;		te^^.txSize := size;		te^^.txFace := face;		te^^.lineHeight := fi.ascent + fi.descent + fi.leading;		te^^.fontAscent := fi.ascent;		TECalText(te);		ExitWindow(saved);	end;	procedure DrawGrayRect (window: DialogPtr; item: integer; title: Str255);		const			left_indent = 20;			gap = 2;		var			r, er: Rect;			fi: FontInfo;			sw: integer;			saved: SavedWindowInfo;	begin		EnterWindow(window, MFT_Geneva9, [], saved);		GetDItemRect(window, item, r);		GetFontInfo(fi);		MoveTo(r.left + left_indent, r.top + fi.ascent);		sw := StringWidth(title);		er.top := r.top;		er.bottom := er.top + fi.ascent + fi.descent;		er.left := r.left + left_indent;		er.right := er.left + sw;		EraseRect(er);		DrawString(title);		PenPatGray;		r.top := r.top + (fi.ascent) div 2;		MoveTo(er.left - gap, r.top);		LineTo(r.left, r.top);		LineTo(r.left, r.bottom);		LineTo(r.right, r.bottom);		LineTo(r.right, r.top);		LineTo(er.right + gap, r.top);		PenNormal;		ExitWindow(saved);	end;	function TrackItems(window:WindowPtr; i1,i2,i3:integer):boolean;		var			rgn:RgnHandle;		procedure AddItem(i:integer);			var				itemrect:Rect;				tmp:RgnHandle;		begin			if i <> 0 then begin				GetDItemRect(window,i,itemrect);				tmp := NewRgn;				RectRgn(tmp, itemrect);				UnionRgn(rgn, tmp, rgn);				DisposeRgn(tmp);			end;		end;		var			inside,newinside:boolean;			mouse:Point;	begin		Assert( window <> nil );		rgn := NewRgn;		AddItem(i1);		AddItem(i2);		AddItem(i3);		InvertRgn(rgn);		inside:=true;		while StillDown do begin			GetMouse(mouse);			newinside := PtInRgn(mouse,rgn);			if newinside <> inside then begin				InvertRgn(rgn);				inside := newinside;			end;		end;		if inside then begin			InvertRgn(rgn);		end;		TrackItems := inside;	end;	procedure DrawStyledTextUserItem( window: DialogPtr; item: integer; ft: MyFontType; face: Style; const data: Str255 );		var			box: Rect;			fi: FontInfo;			saved: SavedWindowInfo;	begin		Assert( window <> nil );		SetPort( window );		EnterWindow ( window, ft, face, saved );		GetDItemRect( window, item, box );		GetFontInfo( fi );		MoveTo( box.left, box.top + fi.ascent );		EraseRect( box );		DrawString( data );		ExitWindow( saved );	end;	procedure DisplayStyledString (window: DialogPtr; item: integer; s: Str255);		var			box: Rect;			just: integer;			this: Str255;			font, size, i, j, def_font, def_size: integer;			st: Style;			fi: FontInfo;			fixsize: boolean;			oldfont, oldsize: integer;			oldface: Style;			hot: Boolean; { parse for <> and blue-underline them }			teh:TEHandle;			tsr:TextStyle;	begin		Assert( window <> nil );		SetPort(window);		oldfont := window^.txFont;		oldsize := window^.txSize;		oldface := window^.txFace;		GetMyFonts(MFT_Geneva9, def_font, def_size);		GetDItemRect(window, item, box);		if SplitAt(s, ':', this, s) then begin			hot := false;			fixsize := false;			if this = '' then begin				font := def_font;			end else begin				GetFNum(this, font);				if font = 0 then begin					fixsize := true;					font := def_font;				end;			end;			if SplitAt(s, ':', this, s) then begin				if this = '' then begin					size := def_size;				end else begin					size := StrToNum(this);				end;				if SplitAt(s, ':', this, s) then begin					st := [];					for i := 1 to length(this) do begin						case this[i] of							'0'..'7':begin								st := st + [StyleItem(ord(this[i]) - 48)];							end;							'H','h': begin								hot := true;							end;							otherwise begin							end;						end;					end;					if SplitAt(s, ':', this, s) then begin						if this = '' then begin							just := teJustLeft;						end else begin							just := StrToNum(this);						end;						TextFont(font);						TextSize(size);						TextFace(st);						if fixsize then begin							GetFontInfo(fi);							while (fi.ascent + fi.descent > box.bottom - box.top) do begin								if size > 48 then begin									size := 48;								end else if size > 36 then begin									size := 36;								end else if size > 27 then begin									size := 27;								end else if size > 24 then begin									size := 24;								end else if size > 18 then begin									size := 18;								end else if size > 14 then begin									size := 14;								end else if size > 12 then begin									size := 12;								end else begin									size := 9;									TextSize(size);									leave;								end;								TextSize(size);								GetFontInfo(fi);							end;						end;						if false then begin							TETextBox(@s[1], length(s), box, just);						end else begin							teh := TEStyleNew(box,box);							if teh<>nil then begin								TESetText(@s[1],length(s),teh);								TESetAlignment(just,teh);								if hot then begin									for i := 1 to length(s) do begin										if s[i] = '<' then begin											j := i + 1;											while (j <= length(s)) & (s[j] <> '>') do begin												j := j + 1;											end;											TESetSelect(i,j-1,teh);											tsr.tsFace := st + [underline];											tsr.tsColor.red := 0;											tsr.tsColor.green := 0;											tsr.tsColor.blue := $FFFF;											TESetStyle(doFace + doColor,tsr,false,teh);										end;									end;								end;								TEUpdate(box,teh);								TEDispose(teh);							end;						end;					end;				end;			end;		end;		TextFont(oldfont);		TextSize(oldsize);		TextFace(oldface);	end;	function PointOverEditTextItem( window: WindowPtr; localwhere: Point ): integer;		var			item: integer;			k: integer;	begin		Assert( window <> nil );		item := FindDialogItem(window, localwhere) + 1;		if item > 0 then begin			GetDItemKind(window, item, k);			if k <> editText then begin				item := 0;			end;		end;		PointOverEditTextItem := item;	end;		function OverEditTextItem: Boolean;		var			window: WindowPtr;			over: Boolean;			localpt: Point;	begin		window := FrontWindow;		over := false;		if (window <> nil) & (WindowPeek(window)^.windowKind = kDialogWindowKind) then begin			SetPort(window);			GetMouse(localpt);			over := PointOverEditTextItem( window, localpt ) > 0;		end;		OverEditTextItem := over;	end;		procedure DialogGetTextDropInformation( window: DialogPtr; localwhere: Point; var field: integer; var offset: integer; hilite: RgnHandle; invert: RgnHandle );		procedure GetOffsetAndInsertionRect( te: TEHandle; localwhere: Point; var offset: integer; var insertion: Rect );			var				basepoint: Point;				theStyle: TextStyle;				lineHeight: integer;				fontAscent: integer;		begin			offset := TEGetOffset( localwhere, te );			basepoint := TEGetPoint( offset, te );			TEGetStyle( offset, theStyle, lineHeight, fontAscent, te );			insertion.left := basepoint.h;			insertion.right := insertion.left + 2;			insertion.bottom := basepoint.v;			insertion.top := insertion.bottom - lineHeight;		end;				const			v_offset = 5000;		var			field_contents: Str255;			field_rect, insertion_rect: Rect;			te: TEHandle;			saved: SavedWindowInfo;	begin		field := PointOverEditTextItem( window, localwhere );		if field > 0 then begin			GetDItemRect( window, field, field_rect );			InsetRect( field_rect, -2, -2 );			RectRgn( hilite, field_rect );			InsetRect( field_rect, 2, 2 );			if SelectedTextItem( window ) = field then begin				GetOffsetAndInsertionRect( DialogPeek(window)^.textH, localwhere, offset, insertion_rect );							end else begin				{ enter the window, set the font info }				EnterWindow( window, MFT_Geneva9, [], saved );				TextFont( DialogPeek(window)^.textH^^.txFont );				TextSize( DialogPeek(window)^.textH^^.txSize );				{ put everything off the screen }				OffsetRect( field_rect, 0, v_offset);				localwhere.v := localwhere.v + v_offset;				{ create a te rect and see where the mouse is }				te := TENew( field_rect, field_rect );				GetItemText( window, field, field_contents );				TESetText( @field_contents[1], length(field_contents), te );				GetOffsetAndInsertionRect( te, localwhere, offset, insertion_rect );				TEDispose( te );				{ push the insertion rect back in to place }				OffsetRect( insertion_rect, 0, -v_offset);				{ restore the state }				ExitWindow( saved );			end;			RectRgn( invert, insertion_rect );		end;	end;		procedure StyleTextBox( text: Handle; styles: StScrpHandle; var box: Rect; just: integer);		var			te: TEHandle;			r: Rect;			saved_state: SignedByte;	begin		Assert( text <> nil );		HLockState( text, saved_state );		if styles = nil then begin			TETextBox( text^, GetHandleSize(text), box, just);		end else begin			te := TEStyleNew( box, box );			TEStyleInsert(text^, GetHandleSize(text), StScrpHandle(styles), te);			TEUpdate(r, te);			TEDispose(te);		end;		HSetState( text, saved_state );	end;	function InitMyDialogs(var msg: integer): OSStatus;		var			grey_colour: RGBColor;			sysenv: SysEnvRec;	begin{$unused(msg)}		gStandardModalFilterProc:=NewModalFilterProc(StandardModalFilter);		gCancelModalFilterProc:=NewModalFilterProc(CancelModalFilter);		gDiscardModalFilterProc:=NewModalFilterProc(DiscardModalFilter);		gOutlineDefault1Proc:=NewUserItemProc(OutlineDefault1);		gOutlineDeviceLoopProc:=NewDeviceLoopDrawingProc(OutlineDeviceLoop);		if (SysEnvirons(1, sysenv) = noErr) & sysenv.hasColorQD then begin			grey_pattern := NewPixPat;		end else begin			grey_pattern := nil;		end;		if grey_pattern <> nil then begin			MakeRGBColor($8000,$8000,$8000,grey_colour);			MakeRGBPat(grey_pattern, grey_colour);		end;		InitMyDialogs := noErr;	end;	procedure StartupDialogs;	begin		SetStartup(InitMyDialogs, nil, 0, nil);	end;end.