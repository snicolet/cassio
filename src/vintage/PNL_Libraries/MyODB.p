unit MyODB;interface	uses		Types,		ODBEngine;		const		generic_odb_error = -234;			type		MODBRecord = record			odb: odbRef;			filern: SInt16;		end;		function MODBError( result: odbBool ): OSStatus;	procedure AddODBBoolean( var err: OSStatus; result: odbBool );	function MODBOpen( const spec: FSSpec; var mor: MODBRecord ): OSStatus;	function MODBCreateOpen( const spec: FSSpec; var mor: MODBRecord; fcreator, ftype: OSType ): OSStatus;	{ if you want a fresh, empy database, call FSpDelete, MODBCreateOpen }	function MODBClose( var mor: MODBRecord; save: boolean ): OSStatus;		function MODBIsType( odb: odbRef; const key: Str255; reqtype: OSType ): boolean;	function MODBNewTable( odb: odbRef; const key: Str255 ): OSStatus;	function MODBGetValueHandle( odb: odbRef; const key: Str255; var data: Handle ): OSStatus;	function MODBSetValueHandle( odb: odbRef; const key: Str255; typ: OSType; data: Handle ): OSStatus;	function MODBGetValueLong( odb: odbRef; const key: Str255; var n: univ longint ): OSStatus;	function MODBSetValueLong( odb: odbRef; const key: Str255; typ: OSType; n: univ longint ): OSStatus;implementation	uses		Errors,		MyUtils, MyMemory, MyStrings;			function MODBError( result: odbBool ): OSStatus;	begin		if result = 0 then begin			MODBError := generic_odb_error;		end else begin			MODBError := noErr;		end;	end;		procedure AddODBBoolean( var err: OSStatus; result: odbBool );	begin		if (err = noErr) & (result = 0) then begin			err := generic_odb_error;		end;	end;		function MODBOpen( const spec: FSSpec; var mor: MODBRecord ): OSStatus;		var			err, junk: OSErr;	begin		err := FSpOpenDF( spec, fsRdWrPerm, mor.filern );		if err = noErr then begin			if err = noErr then begin				err := MODBError( odbOpenFile( mor.filern, mor.odb ) );			end;			if err <> noErr then begin				junk := FSClose( mor.filern );			end;		end;		MODBOpen := err;	end;		function MODBCreateOpen( const spec: FSSpec; var mor: MODBRecord; fcreator, ftype: OSType ): OSStatus;		var			err, junk: OSErr;			created: boolean;	begin		created := false;		err := FSpOpenDF( spec, fsRdWrPerm, mor.filern );		if (err = fnfErr) then begin			err := FSpCreate( spec, fcreator, ftype, 0 );			created := err = noErr;			err := FSpOpenDF( spec, fsRdWrPerm, mor.filern );		end;		if err = noErr then begin			if (err = noErr) & created then begin				err := MODBError( odbNewFile( mor.filern ) );			end;			if err = noErr then begin				err := MODBError( odbOpenFile( mor.filern, mor.odb ) );			end;			if err <> noErr then begin				junk := FSClose( mor.filern );			end;		end;		if (err <> noErr) & created then begin			junk := FSpDelete( spec );		end;		MODBCreateOpen := err;	end;		function MODBClose( var mor: MODBRecord; save: boolean ): OSStatus;		var			err: OSStatus;	begin		err := noErr;		if save then begin			AddODBBoolean( err, odbSaveFile( mor.odb ) );		end;		AddODBBoolean( err, odbCloseFile( mor.odb ) );		AddOSStatus( err, FSClose( mor.filern ) );		MODBClose := err;	end;		function MODBIsType( odb: odbRef; const key: Str255; reqtype: OSType ): boolean;		var			typ: OSType;	begin		MODBIsType := false;		if (odbGetType( odb, key, typ ) <> 0) & (typ = reqtype) then begin			MODBIsType := true;		end;	end;		function MODBNewTable( odb: odbRef; const key: Str255 ): OSStatus;		var			err: OSStatus;			left: Str255;			p: integer;			junk_result: odbBool;	begin		err := noErr;		if not MODBIsType( odb, key, tablevaluetype ) then begin			if odbNewTable( odb, key ) = 0 then begin				left := key;				p := 1;				while (p <= length( key )) do begin					if key[p] = '.' then begin						left[0] := chr(p-1);						junk_result := odbNewTable( odb, left );					end;					Inc(p);				end;				junk_result := odbNewTable( odb, key );				if MODBIsType( odb, key, tablevaluetype ) then begin					err := noErr;				end else begin					err := generic_odb_error;				end;			end;		end;		MODBNewTable := err;	end;		function MODBGetValueLong( odb: odbRef; const key: Str255; var n: univ longint ): OSStatus;		var			err: OSStatus;			value: odbValueRecord;	begin		n := 0;		if odbGetValue( odb, key, value ) <> 0 then begin			n := value.data.longvalue;			odbDisposeValue( odb, value );		end else begin			err := generic_odb_error;		end;		MODBGetValueLong := err;	end;		function MODBSetValueLong( odb: odbRef; const key: Str255; typ: OSType; n: univ longint ): OSStatus;		var			err: OSStatus;			value: odbValueRecord;			left, right: Str255;	begin		value.valuetype := typ;		value.data.longvalue := n;		err := noErr;		if odbSetValue( odb, key, value ) = 0 then begin			err := generic_odb_error;			if SplitRightAt( key, '.', left, right ) then begin				err := MODBNewTable( odb, left );				err := MODBError( odbSetValue( odb, key, value ) );			end;		end;		odbDisposeValue( odb, value );		MODBSetValueLong := err;	end;		function MODBGetValueHandle( odb: odbRef; const key: Str255; var data: Handle ): OSStatus;		var			err: OSStatus;			value: odbValueRecord;	begin		data := nil;		if odbGetValue( odb, key, value ) <> 0 then begin			data := value.data.binaryvalue;			err := HandToHand( data );			if err <> noErr then begin				data := nil;			end;			odbDisposeValue( odb, value );		end else begin			err := generic_odb_error;		end;		if err <> noErr then begin			MDisposeHandle( data );		end;		MODBGetValueHandle := err;	end;		function MODBSetValueHandle( odb: odbRef; const key: Str255; typ: OSType; data: Handle ): OSStatus;		var			err: OSStatus;			value: odbValueRecord;			left, right: Str255;	begin		err := HandToHand( data );		if err = noErr then begin			value.valuetype := typ;			value.data.binaryvalue := data;			err := noErr;			if odbSetValue( odb, key, value ) = 0 then begin				err := generic_odb_error;				if SplitRightAt( key, '.', left, right ) then begin					err := MODBNewTable( odb, left );					err := MODBError( odbSetValue( odb, key, value ) );				end;			end;			odbDisposeValue( odb, value );		end;		MODBSetValueHandle := err;	end;	end.