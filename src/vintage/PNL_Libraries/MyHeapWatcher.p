unit MyHeapWatcher;interface	procedure StartupHeapWatcher;	procedure ConfigureHeapWatcher( enabled: boolean );	implementation	uses		MyOOMainLoop, MyStartup, MyAssertions, MyUtils, MyDialogs;	{$ifc not do_debug}	procedure StartupHeapWatcher;	begin	end;		procedure ConfigureHeapWatcher( enabled: boolean );	begin	end;	{$elsec}	const		res_id = 9367;			type		Items = ( I_None, I_Total, I_Contig );			type		HeapWatcherObject = object(DObject)			procedure DoIdleAlways;			override;		end;			var		gHWenabled: boolean;		heapwindow: HeapWatcherObject;	procedure HeapWatcherObject.DoIdleAlways;		var			t,c: longint;	begin		PurgeSpace( t, c );		SetItemText( window, ord(I_Total), NumToStr( t ) );		SetItemText( window, ord(I_Contig), NumToStr( c ) );	end;		function InitHeapWatcher( var msg: integer ): OSStatus;	begin{$unused(msg)}		if gHWenabled then begin			new(heapwindow);			heapwindow.Create( res_id );			heapwindow.onlyone := @heapwindow;			heapwindow.DoIdleAlways;			ShowWindow( heapwindow.window );		end else begin			heapwindow := nil;		end;		InitHeapWatcher := noErr;	end;	procedure FinishHeapWatcher;	begin		if heapwindow <> nil then begin			heapwindow.DoClose;		end;	end;		procedure ConfigureHeapWatcher( enabled: boolean );	begin		gHWenabled := enabled;		StartupHeapWatcher;	end;		procedure StartupHeapWatcher;	begin		StartupMainLoop;		SetStartup( InitHeapWatcher, nil, 0, FinishHeapWatcher );	end;	{$endc}end.