unit MyDatabase;interface	uses		Types, Files;	const		DB_Normal = 0;		DB_CaseSensitive = $00000001;		DB_Null = 0;	const		fileFormatErr = -10;		duplicateKeyErr = -11;		keyNotFoundErr = -12;	function DatabaseCreate (var fs: FSSpec; hashsize: integer; flags: longint): OSErr;{ You should create the file before calling this using FSpCreate.  Any existing data will be destroyed. }{ hashsize is the number of hash table entries (initial file size will be around 4*hashsize }{ hashsize should be prime }	function DatabaseOpen (var fs: FSSpec; var refnum: longint): OSErr;	function DatabaseFlush (refnum: longint): OSErr;	function DatabaseClose (refnum: longint): OSErr;	function DatabaseAdd (refnum: longint; key: Str255; data: Handle; overwriteok: boolean): OSErr;	function DatabaseSetInfo (refnum: longint; key: Str255; var id: longint; size: longint; overwriteok: boolean): OSErr;	function DatabaseSetChunk (refnum: longint; id: longint; pos: longint; data: Handle): OSErr;	function DatabaseGet (refnum: longint; key: Str255; data: Handle): OSErr; { data may be nil }	function DatabaseGetInfo (refnum: longint; key: Str255; var id: longint; var size: longint): OSErr;	function DatabaseGetChunk (refnum: longint; id: longint; pos, len: longint; data: Handle): OSErr;	function DatabaseDelete (refnum: longint; key: Str255; data: Handle): OSErr; { data may be nil }	function DatabaseIndex (refnum: longint; var pos: longint; var key: Str255; data: Handle): OSErr;{ pass in zero the first time, then whatever you got last time to get next.   data may be nil }	function DatabasePack (refnum: longint): OSErr;{ uses about hashsize*8+8k memory in the heap }implementation	uses		Memory, Packages, 		MyFileSystemUtils, MyMemory,TextUtils;	const		File_Magic = 'PLDB';		Current_Version = 1;		Max_Hash = 30011;		free_next = -1;{ File format: }{ magic:longint }{ version: longint }{ flags:longint }{ hashsize: integer}{ hashtable: array[1..hashsize] of entryptr (offset into file) }{ entry is: }{ next:entryptr }{ keylen:integer }{ datalen:longint }{ key:bytes }{ data:bytes }{ free entries have next=-1.  next links always point further into the file, never backwards }{$PUSH}{$ALIGN MAC68K}	type		ShortFileHeader = record				magic: OSType;				version: longint;				flags: longint;				hashsize: integer;				rn: integer; { not valid in file obviously }			end;		HashTableArray = array[0..Max_Hash] of longint;		LongFileHeader = record				magic: OSType;				version: longint;				flags: longint;				hashsize: integer;				rn: integer; { not valid in file obviously }				hashtable: HashTableArray;			end;		FileHeaderPtr = ^LongFileHeader;		FileHeaderHandle = ^FileHeaderPtr;		HashTablePtr = ^HashTableArray;		EntryRecord = record				next: longint;				keylen: integer;				datalen: longint;			end;{$ALIGN RESET}{$POP}	const		File_Header_Size = SizeOf(ShortFileHeader);		Entry_Size = SizeOf(EntryRecord);	function DatabaseCreate (var fs: FSSpec; hashsize: integer; flags: longint): OSErr;		var			err, oerr: OSErr;			fhp: FileHeaderPtr;			count: longint;			rn: integer;			i: integer;	begin		if hashsize > Max_Hash then begin			hashsize := Max_Hash;		end;		count := File_Header_Size + 4 * longint(hashsize);		err := FSpOpenDF(fs, fsRdWrPerm, rn);		if err = noErr then begin			err := SetEOF(rn, count);			if err = noErr then				err := MNewPtr(fhp, count);			if err = noErr then begin				fhp^.magic := File_Magic;				fhp^.version := Current_Version;				fhp^.flags := flags;				fhp^.hashsize := hashsize;				for i := 0 to hashsize - 1 do begin					fhp^.hashtable[i] := 0;				end;				err := FSWrite(rn, count, Ptr(fhp));				MDisposePtr(fhp);			end;			oerr := FSClose(rn);			if err = noErr then				err := oerr;		end;		DatabaseCreate := err;	end;	function DatabaseOpen (var fs: FSSpec; var refnum: longint): OSErr;		var			err, junk: OSErr;			fh: ShortFileHeader;			rn: integer;			count: longint;			fhp: FileHeaderPtr;	begin		err := FSpOpenDF(fs, fsRdWrPerm, rn);		if err = noErr then begin			count := File_Header_Size;			err := FSRead(rn, count, @fh);			if err = noErr then begin				if (fh.magic <> File_magic) or (fh.version <> Current_Version) or (fh.hashsize < 1) or (fh.hashsize > Max_Hash) then begin					err := fileFormatErr;				end;			end;			if err = noErr then begin				count := 4 * longint(fh.hashsize);				err := MNewPtr(fhp, File_header_Size + count);			end;			if err = noErr then begin				BlockMove(@fh, Ptr(fhp), File_Header_Size);				fhp^.rn := rn;				err := FSRead(rn, count, Ptr(ord(fhp) + File_Header_Size));				if err <> noErr then begin					MDisposePtr(fhp);				end;			end;			if err <> noErr then begin				junk := FSClose(rn);			end;		end;		refnum := longint(fhp);		if err <> noErr then begin			refnum := DB_Null;		end;		DatabaseOpen := err;	end;	function DatabaseFlush (refnum: longint): OSErr;		var			err: OSErr;			fhp: FileHeaderptr;			pb: ParamBlockRec;	begin		fhp := FileHeaderPtr(refnum);		err := MyFSWriteAt(fhp^.rn, fsFromStart, 0, GetPtrSize(Ptr(fhp)), Ptr(fhp));		if err = noErr then begin			pb.ioRefNum := fhp^.rn;			err := PBFlushFileSync(@pb);		end;		DatabaseFlush := err;	end;	function DatabaseClose (refnum: longint): OSErr;		var			err, oerr: OSErr;			fhp: FileHeaderptr;	begin		fhp := FileHeaderPtr(refnum);		err := MyFSWriteAt(fhp^.rn, fsFromStart, 0, GetPtrSize(Ptr(fhp)), Ptr(fhp));		oerr := FSClose(fhp^.rn);		if err = noErr then			err := oerr;		MDisposePtr(fhp);		DatabaseClose := err;	end;	function Hash (var key: Str255; hashsize: integer): integer;		var			h, i: integer;	begin		h := 0;		for i := 1 to length(key) do begin			h := ((32 * longint(h)) + ord(key[i])) mod hashsize;		end;		Hash := h;	end;	function ReadEntry (fhp: FileHeaderPtr; pos: longint; var entry: EntryRecord; var key: Str255): OSErr;		var			err: OSErr;	begin		err := MyFSReadAt(fhp^.rn, pos, Entry_Size, @entry);		if err = noErr then begin{$PUSH}{$R-}			key[0] := chr(entry.keylen);{$POP}			if entry.keylen > 0 then begin				err := MyFSReadAt(fhp^.rn, pos + Entry_Size, entry.keylen, @key[1]);			end;		end;		ReadEntry := err;	end;	function Find (fhp: FileHeaderPtr; var key: Str255; var h: integer; var preoffset, offset: longint; var entry: EntryRecord): OSErr;{ err = noErr ==> no error.  offset<>0 ==> found. preoffset is the fileoffset that points to offset (even if not found) }		var			err: OSErr;			thiskey: Str255;	begin		h := Hash(key, fhp^.hashsize);		preoffset := File_Header_Size + 4 * longint(h);		offset := fhp^.hashtable[h];		err := noErr;		while (offset <> 0) & (err = noErr) do begin			err := ReadEntry(fhp, offset, entry, thiskey);			if err = noErr then begin				if BAND(fhp^.flags, DB_CaseSensitive) <> 0 then begin					if thiskey = key then begin						leave;					end;				end else begin					if IUEqualString(thiskey, key) = 0 then begin						leave;					end;				end;				preoffset := offset;				offset := entry.next;			end;		end;		Find := err;	end;	function WriteLink (fhp: FileHeaderPtr; pos: longint; link: longint): OSErr;		var			h: integer;			err: OSErr;	begin		if pos >= File_Header_Size + 4 * longint(fhp^.hashsize) then begin			err := MyFSWriteAt(fhp^.rn, fsFromStart, pos, 4, @link);		end else begin			err := noErr;			h := (pos - File_Header_size) div 4;			fhp^.hashtable[h] := link;		end;		WriteLink := err;	end;	function WriteFreeLink (fhp: FileHeaderPtr; pos: longint): OSErr;		var			link: longint;	begin		link := free_next;		WriteFreeLink := MyFSWriteAt(fhp^.rn, fsFromStart, pos, 4, @link);	end;	function FindSpace (fhp: FileHeaderptr; key: Str255; size: longint; overwriteok: boolean; var offset: longint): OSErr;		var			err: OSErr;			h: integer;			preoffset, v: longint;			entry: EntryRecord;			filelen: longint;			oldsize: longint;	begin		err := Find(fhp, key, h, preoffset, offset, entry);		if (err = noErr) & (offset <> 0) & not overwriteok then			err := duplicateKeyErr;		if (err = noErr) & (offset <> 0) then begin			if entry.datalen = size then begin{ all set }			end else if entry.datalen > size + Entry_Size then begin				oldsize := entry.datalen;				entry.datalen := size;				err := MyFSWriteAt(fhp^.rn, fsFromStart, offset, Entry_Size, @entry);				if err = noErr then begin					entry.next := free_next;					entry.keylen := 0;					entry.datalen := oldsize - size - Entry_Size;					err := MyFSWriteAt(fhp^.rn, fsFromStart, offset + Entry_Size + length(key) + size, Entry_Size, @entry);				end;			end else begin				err := WriteLink(fhp, preoffset, entry.next);				v := free_next;				if err = noErr then					err := WriteFreeLink(fhp, offset);				offset := entry.next;				while (offset <> 0) & (err = noErr) do begin					err := MyFSReadAt(fhp^.rn, offset, 4, @entry);					if err = noErr then begin						preoffset := offset;						offset := entry.next;					end;				end;			end;		end;		if (err = noErr) & (offset = 0) then begin { add at end of file after entry at preoffset }			err := GetEOF(fhp^.rn, filelen);			if err = noErr then begin				err := SetEOF(fhp^.rn, filelen + Entry_Size + length(key) + size);			end;			entry.next := 0;			entry.keylen := length(key);			entry.datalen := size;			if err = noErr then				err := MyFSWriteAt(fhp^.rn, fsFromStart, filelen, Entry_Size, @entry);			if err = noErr then				err := MyFSWrite(fhp^.rn, length(key), @key[1]);			if err = noErr then begin				err := WriteLink(fhp, preoffset, filelen);			end;			offset := filelen;		end;		offset := offset + Entry_Size + length(key);		FindSpace := err;	end;	function DatabaseAdd (refnum: longint; key: Str255; data: Handle; overwriteok: boolean): OSErr;		var			err: OSErr;			fhp: FileHeaderptr;			offset: longint;			handlesize: longint;			state: SignedByte;	begin		fhp := FileHeaderPtr(refnum);		handlesize := GetHandleSize(data);		err := FindSpace(fhp, key, handlesize, overwriteok, offset);		if err = noErr then begin			HLockState(data, state);			err := MyFSWriteAt(fhp^.rn, fsFromStart, offset, handlesize, data^);			HSetState(data, state);		end;		DatabaseAdd := err;	end;	function DatabaseSetInfo (refnum: longint; key: Str255; var id: longint; size: longint; overwriteok: boolean): OSErr;		var			err: OSErr;			fhp: FileHeaderptr;	begin		fhp := FileHeaderPtr(refnum);		err := FindSpace(fhp, key, size, overwriteok, id);		DatabaseSetInfo := err;	end;	function DatabaseSetChunk (refnum: longint; id: longint; pos: longint; data: Handle): OSErr;		var			err: OSErr;			fhp: FileHeaderptr;			state: SignedByte;	begin		fhp := FileHeaderPtr(refnum);		HLockState(data, state);		err := MyFSWriteAt(fhp^.rn, fsFromStart, id + pos, GetHandleSize(data), data^);		HSetState(data, state);		DatabaseSetChunk := err;	end;	function Get (fhp: FileHeaderPtr; var key: Str255; var h: integer; var preoffset, offset: longint; var entry: EntryRecord; data: Handle): OSErr;		var			err: OSErr;			state: SignedByte;	begin		err := Find(fhp, key, h, preoffset, offset, entry);		if (err = noErr) & (offset = 0) then			err := keyNotFoundErr;		if err = noErr then begin			if data <> nil then begin				HUnlockState(data, state);				SetHandleSize(data, entry.datalen);				err := MemError;				if err = noErr then begin					HLock(data);					err := MyFSReadAt(fhp^.rn, offset + Entry_Size + entry.keylen, entry.datalen, data^);				end;				HSetState(data, state);			end;		end;		Get := err;	end;	function DatabaseGet (refnum: longint; key: Str255; data: Handle): OSErr;		var			h: integer;			preoffset, offset: longint;			entry: EntryRecord;	begin		DatabaseGet := Get(FileHeaderPtr(refnum), key, h, preoffset, offset, entry, data);	end;	function DatabaseGetInfo (refnum: longint; key: Str255; var id: longint; var size: longint): OSErr;		var			h: integer;			preoffset, offset: longint;			entry: EntryRecord;	begin		DatabaseGetInfo := Get(FileHeaderPtr(refnum), key, h, preoffset, offset, entry, nil);		id := offset + Entry_Size + entry.keylen;		size := entry.datalen;	end;	function DatabaseGetChunk (refnum: longint; id: longint; pos, len: longint; data: Handle): OSErr;		var			err: OSErr;			state: SignedByte;	begin		HUnlockState(data, state);		SetHandleSize(data, len);		err := MemError;		if err = noErr then begin			HLock(data);			err := MyFSReadAt(FileHeaderPtr(refnum)^.rn, id + pos, len, data^);		end;		HSetState(data, state);		DatabaseGetChunk := err; { Thanks Marcel/Metrowerks! }	end;	function DatabaseDelete (refnum: longint; key: Str255; data: Handle): OSErr; { data may be nil }		var			err: OSErr;			fhp: FileHeaderptr;			h: integer;			preoffset, offset: longint;			entry: EntryRecord;	begin		fhp := FileHeaderPtr(refnum);		err := Get(fhp, key, h, preoffset, offset, entry, data);		if err = noErr then begin			err := WriteLink(fhp, preoffset, entry.next);			if err = noErr then				err := WriteFreeLink(fhp, offset);		end;		DatabaseDelete := err;	end;	function DatabaseIndex (refnum: longint; var pos: longint; var key: Str255; data: Handle): OSErr;		var			err: OSErr;			fhp: FileHeaderptr;			start, filelen: longint;			entry: EntryRecord;			count: longint;	begin		fhp := FileHeaderPtr(refnum);		start := File_Header_Size + 4 * longint(fhp^.hashsize);		if pos = 0 then			pos := start;		err := GetEOF(fhp^.rn, filelen);		entry.next := free_next;		while (err = noErr) & (entry.next = free_next) & (start <= pos) & (pos < filelen) do begin			err := ReadEntry(fhp, pos, entry, key);			pos := pos + Entry_Size + entry.keylen + entry.datalen;		end;		if (err = noErr) & (entry.next = free_next) then			err := keyNotFoundErr;		if (err = noErr) & (data <> nil) then begin			SetHandleSize(data, entry.datalen);			err := MemError;			if err = noErr then begin				count := entry.datalen;				err := FSRead(fhp^.rn, count, data^);			end;		end;		DatabaseIndex := err;	end;	function DatabasePack (refnum: longint): OSErr;		const			buffer_size = 8192;		var			err: OSErr;			fhp: FileHeaderptr;			preoffsets, offsets: HashTablePtr;			start, filelen: longint;			srcpos, destpos: longint;			entry: EntryRecord;			key: Str255;			len, count: longint;			buffer: Ptr;			h: integer;	begin		fhp := FileHeaderPtr(refnum);		err := MNewPtr(preoffsets, 4 * longint(fhp^.hashsize));		offsets := nil;		if err = noErr then			err := MNewPtr(offsets, 4 * longint(fhp^.hashsize));		buffer := nil;		if err = noErr then			err := MNewPtr(buffer, buffer_size);		start := File_Header_Size + 4 * longint(fhp^.hashsize);		if err = noErr then			err := GetEOF(fhp^.rn, filelen);		if err = noErr then begin			for h := 0 to fhp^.hashsize - 1 do begin				preoffsets^[h] := File_header_Size + longint(h) * 4;				offsets^[h] := fhp^.hashtable[h];			end;			srcpos := start;			destpos := start;			while (err = noErr) & (srcpos < filelen) do begin				err := ReadEntry(fhp, srcpos, entry, key);				if (err = noErr) then begin					len := Entry_Size + entry.keylen + entry.datalen;					if (entry.next = free_next) then begin { skip it }						srcpos := srcpos + len;					end else begin{ ok, now we need to move this entry from srcpos to destpos, updating the link pointing to it }{ Find hash }						h := Hash(key, fhp^.hashsize);						if (err = noErr) & (offsets^[h] <> srcpos) then							err := fileFormatErr;{ Update link }						if err = noErr then							err := WriteLink(fhp, preoffsets^[h], destpos);						preoffsets^[h] := destpos;						offsets^[h] := entry.next;{ Copy entry }						if srcpos = destpos then begin							destpos := destpos + len;							srcpos := srcpos + len;						end else begin							while (err = noErr) & (len > 0) do begin								count := len;								if count > buffer_size then									count := buffer_size;								err := MyFSReadAt(fhp^.rn, srcpos, count, buffer);								if err = noErr then									err := MyFSWriteAt(fhp^.rn, fsFromStart, destpos, count, buffer);								len := len - count;								srcpos := srcpos + count;								destpos := destpos + count;							end;						end;					end;				end;			end;			if err = noErr then				err := SetEOF(fhp^.rn, destpos);		end;		MDisposePtr(preoffsets);		MDisposePtr(offsets);		MDisposePtr(buffer);		DatabasePack := err;	end;end.{ Edit history }{11 Dec 95	pnl		Original }{Ê5 May 96	jc			Changes to support large DBs ÐÊagain, since I lost the original edits }{ 21 Aug 96	pnl		Added 68k alignment directives, fixed case, merged back in to main source }