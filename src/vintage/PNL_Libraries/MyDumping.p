unit MyDumping;interface	uses		Types, Memory;	const		dump_name = 'Dumping_dump_file';	procedure InitDumping (safe, clean, tofile, totext: boolean);	procedure Dumping (safe, clean, tofile, totext: boolean);	procedure FinishDumping;	procedure DumpLine (s: Str255);	procedure DumpStr (s: Str255);	procedure DumpNum (n: longint);	procedure DumpValue (s: Str255; n: longint);	procedure DumpByte (n: integer);	procedure DumpWord (n: longint);	procedure DumpLong (n: longint);	procedure DumpData (p: Ptr; len: longint);	procedure DumpText (p: Ptr; len: longint);	procedure DumpHeap (hz: THz);implementation	uses		TextUtils, Files, Resources,		MyTypes, MyStrings;			var		dump_tofile, dump_totext, dump_safe: boolean;		dump: integer;{$IFC undefined BackgroundOnly}{$SETC BackgroundOnly = FALSE}{$ENDC}	function NumToStr (n: longint): Str31;		var			s: Str255;	begin		NumToString(n, s);		NumToStr := s;	end;	procedure InitDumping (safe, clean, tofile, totext: boolean);		var			oe: OSErr;	begin{    oe := FSDelete(dump_name, 0);}		oe := Create(dump_name, 0, 'R*ch', 'TEXT');		oe := FSOpen(dump_name, 0, dump);		oe := SetFPos(dump, fsFromLEOF, 0);		Dumping(safe, clean, tofile, totext);		if not clean and tofile then begin			DumpLine('');			DumpLine('Dump File');			DumpLine('');		end;	end;	procedure Dumping (safe, clean, tofile, totext: boolean);		var			oe: OSErr;	begin		if clean then begin			oe := SetEOF(dump, 0);			oe := SetFPos(dump, fsFromLEOF, 0);		end;		dump_safe := safe;		dump_tofile := tofile;		dump_totext := totext;{$IFC  not BackgroundOnly}		if dump_totext then begin{			ShowText;}		end;{$ENDC}	end;	procedure FinishDumping;		var			oe: OSErr;	begin		oe := FSClose(dump);		dump := 0;		dump_tofile := false;		dump_totext := false;	end;	procedure DumpStr (s: Str255);		var			oe: OSErr;			pb: ParamBlockRec;			count: longint;	begin		if dump_tofile then begin			count := length(s);			oe := FSWrite(dump, count, @s[1]);			if dump_safe then begin				pb.ioRefNum := dump;				oe := PBFlushFileSync(@pb);				pb.ioNamePtr := nil;				pb.ioVRefNum := 0;				oe := PBFlushVolSync(@pb);			end;		end;{$IFC not BackgroundOnly}		if dump_totext then begin			if s[length(s)] = cr then begin				Delete( s, length(s), 1 );				writeln( s );			end else begin				write(s);			end;		end;{$ENDC}	end;	procedure DumpLine (s: Str255);	begin		DumpStr(concat(s, chr(13)));	end;	procedure DumpNum (n: longint);	begin		DumpStr(NumToStr(n));	end;	procedure DumpValue (s: Str255; n: longint);	begin		DumpStr(concat(s, ' ', NumToStr(n), chr(13)));	end;	function HexN (n: integer): char;	begin		n := BAND(n, $F);		if n > 9 then			n := n + 7;		HexN := chr(n + 48);	end;	function HexB (n: integer): Str15;	begin		n := BAND(n, $FF);		HexB := concat(HexN(BSR(n, 4)), HexN(n));	end;	procedure DumpByte (n: integer);	begin		DumpStr(HexB(n));	end;	procedure DumpWord (n: longint);	begin		DumpStr(concat(HexB(BSR(n, 8)), HexB(n)));	end;	procedure DumpLong (n: longint);	begin		DumpStr(concat(HexB(BSR(n, 24)), HexB(BSR(n, 16)), HexB(BSR(n, 8)), HexB(n)));	end;	procedure DumpData (p: Ptr; len: longint);		var			offset: longint;		procedure D (p: Ptr; n: integer);			var				s: Str255;				i, b: integer;		begin			s := concat(HexB(BSR(offset, 16)), HexB(BSR(offset, 8)), HexB(offset), ': ');			for i := 1 to 16 do begin				if i <= n then					s := concat(s, HexB(Ptr(ord(p) + i - 1)^))				else					s := concat(s, '  ');				s := concat(s, ' ');				if i mod 4 = 0 then					s := concat(s, ' ');			end;			for i := 1 to n do begin				b := BAND(Ptr(ord(p) + i - 1)^, $FF);				if (b < 32) | (b >= 127) then					b := ord('.');				s := concat(s, chr(b));			end;			DumpLine(s);		end;	begin		offset := 0;		while (len > 16) do begin			D(p, 16);			p := Ptr(ord(p) + 16);			len := len - 16;			offset := offset + 16;		end;		if len > 0 then			D(p, len);	end;	procedure DumpText (p: Ptr; len: longint);		var			offset: longint;			l, i: integer;			s: Str255;	begin		offset := 0;		while len > 0 do begin			l := 64;			if l > len then				l := len;			BlockMove(p, @s[1], l);			s[0] := chr(l);			for i := 1 to length(s) do begin				if (s[i] < chr(32)) or (s[i] >= chr(127)) then begin					s[i] := '.';				end;			end;			s := concat(HexB(BSR(offset, 16)), HexB(BSR(offset, 8)), HexB(offset), ': ', s);			DumpLine(s);			len := len - l;			p := Ptr(ord(p) + l);		end;	end;	procedure DumpHeap (hz: THz);{$PUSH}{$ALIGN MAC68K}		type			ExpandedBlockHeader = record					typ: integer; { 0 = free, 1 = nonrel, 2 = rel }					flags: integer; {res, purgeable, locked }					correct: integer;					hsize: integer;					psize: longint;					other: longint;				end;		type			blockHeader = record					l1: longint;					l2: longint;					l3: longint;				end;			blockHeaderPtr = ^blockHeader;{$ALIGN RESET}{$POP}		procedure ConvertHeader (p: blockHeaderPtr; var ebh: ExpandedBlockHeader);		begin			if false then begin				ebh.typ := BAND(BSR(p^.l1, 30), $03);				ebh.flags := 0;				ebh.correct := BAND(BSR(p^.l1, 24), $0F);				ebh.psize := BAND(p^.l1, $00FFFFFF);				ebh.other := p^.l2;				ebh.hsize := 8;			end			else begin				ebh.typ := BAND(BSR(p^.l1, 30), $03);				ebh.flags := BAND(BSR(p^.l1, 21), $07);				ebh.correct := BAND(p^.l1, $00FF);				ebh.psize := p^.l2;				ebh.other := p^.l3;				ebh.hsize := 12;			end;		end;		var			p, data: Ptr;			h: Handle;			ebh: ExpandedBlockHeader;			s: Str255;			lsize: longint;			state: integer;			resfile: integer;			resid: integer;			restyp: ResType;			resname: Str255;			resfilename: Str255;			pb: FCBPBRec;			err: OSErr;	begin		DumpLine(StringOf('Heap Dump ', hz, '-', hz^.bkLim, ' ', hz^.zcbFree));		p := @hz^.heapData;		while OSType(p) < OSType(hz^.bkLim) do begin			ConvertHeader(blockHeaderPtr(p), ebh);			lsize := ebh.psize - ebh.correct - ebh.hsize;			data := Ptr(ord(p) + ebh.hsize);			s := StringOf(data, lsize : 10, ' ');			case ebh.typ of				0: 					s := concat(s, 'F');				1: 					s := concat(s, 'P');				2:  begin					h := RecoverHandle(data);					s := StringOf(s, 'H ', h, ' ');					state := HGetState(h);					if BAND(state, $20) <> 0 then						s := concat(s, 'R')					else						s := concat(s, ' ');					if BAND(state, $40) <> 0 then						s := concat(s, 'P')					else						s := concat(s, ' ');					if BAND(state, $80) <> 0 then						s := concat(s, 'L')					else						s := concat(s, ' ');					if BAND(state, $20) <> 0 then begin						resfile := HomeResFile(h);						resfilename := 'Unknown resource file';						if resfile <> -1 then begin							pb.ioNamePtr := @resfilename;							pb.ioVRefNum := 0;							pb.ioRefNum := resfile;							pb.ioFCBIndx := 0;							err := PBGetFCBInfoSync(@pb);						end;						GetResInfo(h, resid, restyp, resname);						s := StringOf(s, ' ', OSTypeToString(restyp), '=', resid : 1);						if resname <> '' then							s := concat(s, ' "', resname, '"');						s := concat(s, ' [', resfilename, ']');					end;				end;			end;			DumpLine(s);			if lsize > 16 then				lsize := 16;			DumpData(Ptr(ord(p) + ebh.hsize), lsize);			p := Ptr(ord(p) + ebh.psize);		end;		if Ptr(p) <> Ptr(hz^.bkLim) then begin			DumpLine('Hmmm, end of last block isn''t at the end of the heap!');		end;	end;end.