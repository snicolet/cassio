unit MyDES;interface	uses		Types;{$PUSH}{$ALIGN MAC68K}	type		desData = record				case boolean of					false: (							hi: longint;							lo: longint;					);					true: (							bytes: packed array[1..8] of Byte;					)			end;{$ALIGN RESET}{$POP}	procedure StartupDES;	procedure EncryptDES (var plain, key, cipher: desData);	procedure DecryptDES (var cipher, key, plain: desData);implementation	uses		Resources, Errors,		MyStartup;			const		kInitalTr = 8;		kFinalTr = 9;		kKeyTr1 = 10;		kKeyTr2 = 11;		kFiddle = 12;	type		posType = 0..63;		mappingType = packed array[posType] of Byte;	var		mappings: array[0..12] of mappingType;	procedure ReMap (var data: desData; map: integer);		var			i: integer;			t: desData;			tmp: longint;	begin		t := data;		data.lo := 0;		data.hi := 0;		i := 0;		tmp := $80000000;		while (tmp <> 0) do begin			if mappings[map, i] >= 128 then begin				if BTST(t.hi, mappings[map, i] - 128) then begin					data.hi := BOR(data.hi, tmp);				end; {if}			end else begin				if BTST(t.lo, mappings[map, i]) then begin					data.hi := BOR(data.hi, tmp);				end; {if}			end; {if}			tmp := BSR(tmp, 1);			i := i + 1;		end; {while}		tmp := $80000000;		while (tmp <> 0) do begin			if mappings[map, i] >= 128 then begin				if BTST(t.hi, mappings[map, i] - 128) then begin					data.lo := BOR(data.lo, tmp);				end; {if}			end else begin				if BTST(t.lo, mappings[map, i]) then begin					data.lo := BOR(data.lo, tmp);				end; {if}			end; {if}			tmp := BSR(tmp, 1);			i := i + 1;		end; {while}	end;	procedure KeyRotateLeft (var key: desData);	begin		key.lo := BROTL(key.lo, 1);		if BTST(key.lo, 28) then begin			key.lo := BAND(BOR(key.lo, $00000001), $0FFFFFFF);		end else begin			key.lo := BAND(key.lo, $0FFFFFFE);		end; {if}		key.hi := BROTL(key.hi, 1);		if BTST(key.hi, 28) then begin			key.hi := BAND(BOR(key.hi, $00000001), $0FFFFFFF);		end else begin			key.hi := BAND(key.hi, $0FFFFFFE);		end; {if}	end;	procedure KeyRotateRight (var key: desData);	begin		key.lo := BROTR(key.lo, 1);		if BTST(key.lo, 31) then begin			key.lo := BAND(BOR(key.lo, $08000000), $0FFFFFFF);		end else begin			key.lo := BAND(key.lo, $07FFFFFF);		end; {if}		key.hi := BROTR(key.hi, 1);		if BTST(key.hi, 31) then begin			key.hi := BAND(BOR(key.hi, $08000000), $0FFFFFFF);		end else begin			key.hi := BAND(key.hi, $07FFFFFF);		end; {if}	end;	procedure Stage (var key, cipher: desData);		var			i: integer;			t: longint;			tmp: desData;	begin		tmp.lo := 0;		tmp.hi := 0;		t := BROTL(cipher.lo, 1);		for i := 1 to 8 do begin			t := BROTL(t, 4);			tmp.bytes[i] := BAND(t, $0FF);		end;		i := 0;		t := $80000000;		while (t <> 0) do begin			if BTST(key.hi, mappings[kKeyTr2, i]) then begin				tmp.hi := BXOR(tmp.hi, t);			end; {if}			t := BSR(t, 1);			i := i + 1;		end; {while}		t := $80000000;		while (t <> 0) do begin			if BTST(key.lo, mappings[kKeyTr2, i]) then begin				tmp.lo := BXOR(tmp.lo, t);			end; {if}			t := BSR(t, 1);			i := i + 1;		end; {while}		tmp.hi := BAND(tmp.hi, $3F3F3F3F);		tmp.lo := BAND(tmp.lo, $3F3F3F3F);		t := 0;		for i := 0 to 7 do begin			t := BOR(BROTL(t, 4), mappings[i, tmp.bytes[i+1]]);		end; {for}		tmp.lo := t;		i := 0;		t := $80000000;		while (t <> 0) do begin			if BTST(tmp.lo, mappings[kFiddle, i]) then begin				cipher.hi := BXOR(cipher.hi, t);			end; {if}			t := BSR(t, 1);			i := i + 1;		end; {while}	end;	procedure EncryptDES (var plain, key, cipher: desData);		var			tmpkey: desData;			t: longint;			rots: longint;	begin		tmpkey := key;		ReMap(tmpkey, kKeyTr1);		tmpkey.lo := BAND(tmpkey.lo, $0FFFFFFF);		tmpkey.hi := BAND(tmpkey.hi, $0FFFFFFF);		cipher := plain;		ReMap(cipher, kInitalTr);{0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0}		rots := $0000C081;		while (rots <> 0) do begin			KeyRotateLeft(tmpkey);			Stage(tmpkey, cipher);			if not BTST(rots, 0) then begin				KeyRotateLeft(tmpkey);			end;			rots := BSR(rots, 1);			if rots <> 0 then begin				t := cipher.lo;				cipher.lo := cipher.hi;				cipher.hi := t;			end; {if}		end; {while}		ReMap(cipher, kFinalTr);	end;	procedure DecryptDES (var cipher, key, plain: desData);		var			tmpkey: desData;			t: longint;			rots: longint;	begin		tmpkey := key;		ReMap(tmpkey, kKeyTr1);		tmpkey.lo := BAND(tmpkey.lo, $0FFFFFFF);		tmpkey.hi := BAND(tmpkey.hi, $0FFFFFFF);		plain := cipher;		ReMap(plain, kInitalTr);		t := plain.lo;		plain.lo := plain.hi;		plain.hi := t;{0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0}		rots := $0000C081;		while (rots <> 0) do begin			t := plain.lo;			plain.lo := plain.hi;			plain.hi := t;			Stage(tmpkey, plain);			KeyRotateRight(tmpkey);			if not BTST(rots, 0) then begin				KeyRotateRight(tmpkey);			end;			rots := BSR(rots, 1);		end; {while}		ReMap(plain, kFinalTr);	end;{$IFC 0}	procedure SetupMappings;		procedure InitMapping (var o: mappingType; a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63: Byte);		begin			o[0] := a00;			o[1] := a01;			o[2] := a02;			o[3] := a03;			o[4] := a04;			o[5] := a05;			o[6] := a06;			o[7] := a07;			o[8] := a08;			o[9] := a09;			o[10] := a10;			o[11] := a11;			o[12] := a12;			o[13] := a13;			o[14] := a14;			o[15] := a15;			o[16] := a16;			o[17] := a17;			o[18] := a18;			o[19] := a19;			o[20] := a20;			o[21] := a21;			o[22] := a22;			o[23] := a23;			o[24] := a24;			o[25] := a25;			o[26] := a26;			o[27] := a27;			o[28] := a28;			o[29] := a29;			o[30] := a30;			o[31] := a31;			o[32] := a32;			o[33] := a33;			o[34] := a34;			o[35] := a35;			o[36] := a36;			o[37] := a37;			o[38] := a38;			o[39] := a39;			o[40] := a40;			o[41] := a41;			o[42] := a42;			o[43] := a43;			o[44] := a44;			o[45] := a45;			o[46] := a46;			o[47] := a47;			o[48] := a48;			o[49] := a49;			o[50] := a50;			o[51] := a51;			o[52] := a52;			o[53] := a53;			o[54] := a54;			o[55] := a55;			o[56] := a56;			o[57] := a57;			o[58] := a58;			o[59] := a59;			o[60] := a60;			o[61] := a61;			o[62] := a62;			o[63] := a63;		end;	begin		InitMapping(mappings[kInitalTr], 6, 14, 22, 30, 134, 142, 150, 158, 4, 12, 20, 28, 132, 140, 148, 156, 2, 10, 18, 26, 130, 138, 146, 154, 0, 8, 16, 24, 128, 136, 144, 152, 7, 15, 23, 31, 135, 143, 151, 159, 5, 13, 21, 29, 133, 141, 149, 157, 3, 11, 19, 27, 131, 139, 147, 155, 1, 9, 17, 25, 129, 137, 145, 153);		InitMapping(mappings[kFinalTr], 24, 152, 16, 144, 8, 136, 0, 128, 25, 153, 17, 145, 9, 137, 1, 129, 26, 154, 18, 146, 10, 138, 2, 130, 27, 155, 19, 147, 11, 139, 3, 131, 28, 156, 20, 148, 12, 140, 4, 132, 29, 157, 21, 149, 13, 141, 5, 133, 30, 158, 22, 150, 14, 142, 6, 134, 31, 159, 23, 151, 15, 143, 7, 135);		InitMapping(mappings[kKeyTr1], 0, 0, 0, 0, 7, 15, 23, 31, 135, 143, 151, 159, 6, 14, 22, 30, 134, 142, 150, 158, 5, 13, 21, 29, 133, 141, 149, 157, 4, 12, 20, 28, 0, 0, 0, 0, 1, 9, 17, 25, 129, 137, 145, 153, 2, 10, 18, 26, 130, 138, 146, 154, 3, 11, 19, 27, 131, 139, 147, 155, 132, 140, 148, 156);		InitMapping(mappings[kKeyTr2], 0, 0, 14, 11, 17, 4, 27, 23, 0, 0, 25, 0, 13, 22, 7, 18, 0, 0, 5, 9, 16, 24, 2, 20, 0, 0, 12, 21, 1, 8, 15, 26, 0, 0, 15, 4, 25, 19, 9, 1, 0, 0, 26, 16, 5, 11, 23, 8, 0, 0, 12, 7, 17, 0, 22, 3, 0, 0, 10, 14, 6, 20, 27, 24);		InitMapping(mappings[kFiddle], 16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);		InitMapping(mappings[7], 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11);		InitMapping(mappings[6], 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12);		InitMapping(mappings[5], 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13);		InitMapping(mappings[4], 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3);		InitMapping(mappings[3], 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14);		InitMapping(mappings[2], 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12);		InitMapping(mappings[1], 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9);		InitMapping(mappings[0], 14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13);	end;	procedure CreateResource;		var			fs: FSSpec;			resfile: integer;			hhhh: Handle;			err: OSErr;	begin		SetupMappings;		err := FSMakeFSSpec(0, 0, 'Zany:DESData', fs);		err := FSpDelete(fs);		FSpCreateResFile(fs, 'RSED', 'rsrc', 0);		resfile := FSpOpenResFile(fs, fsRdWrPerm);		if resfile <> -1 then begin			err := PtrToHand(@mappings, hhhh, SizeOf(mappings));			AddResource(hhhh, 'DESd', 128, '');			CloseResFile(resfile);		end;	end;{$ENDC}	function InitDES(var msg: integer):OSStatus;		var			err: OSErr;			hhhh: Handle;	begin{$unused(msg)}		hhhh := GetResource('DESd', 128);		if (hhhh = nil) | (hhhh^ = nil) | (GetHandleSize(hhhh) <> SizeOf(mappings)) then begin			err := resNotFound;		end else begin			BlockMoveData(hhhh^, @mappings, SizeOf(mappings));			ReleaseResource(hhhh);			err := noErr;		end;		InitDES:=err;	end;	procedure StartupDES;	begin		SetStartup(InitDES, nil, 0, nil);	end;	end.