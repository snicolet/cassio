unit MyBinHex;interface	uses		Files;	const		notEnoughData = 1;	type		BinHexEncodeState = record				state: integer;				bits: integer;				repcnt, lastbyte: integer;				linepos: integer;				dlen, rlen: longint;				crc: integer;				crlf: boolean;				datafork: boolean;			end;	procedure StartupBinHex;	procedure BinHexEncodeStart (var bh: BinHexEncodeState; crlf: boolean; name: Str63; var fi: FInfo; dlen, rlen: longint; p: Ptr; len: longint; var count: longint);	procedure BinHexEncodeChunk (var bh: BinHexEncodeState; p: Ptr; len: longint; var count: longint; eofork, eofile: boolean);	function BinHexDecodeStart (var bh: BinHexEncodeState; var name: Str63; var fi: FInfo; var dlen, rlen: longint; p: Ptr; len: longint; var count: longint): OSErr;	function BinHexDecodeChunk (var bh: BinHexEncodeState; inp: Ptr; inlen: longint; var inused: longint; outp: Ptr; outlen: longint; var outused: longint; var eofork, eofile: boolean): OSErr;implementation	uses		Memory, CalcCRC, MyLowLevel, MyStartup;	const		binhex_start_string_hack = '(This file must be converted with BinHex 4.0)';		binhex_check_length = 33;		first_binhex_char = ord('(');		second_binhex_char = ord('T');		mapbc_hack = '!"#$%&''()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr';		rep = $90;		dud_byte = $FF;	var		mapbc: string[64];		binhex_start_string:string[63];		map: packed array[0..255] of Byte;	procedure BinHexEncodeStart (var bh: BinHexEncodeState; crlf: boolean; name: Str63; var fi: FInfo; dlen, rlen: longint; p: Ptr; len: longint; var count: longint);		var			headerlen: integer;			q: Ptr;			s: Str255;	begin		q := p;		s := binhex_start_string;		BlockMoveData(@s[1], q, length(s));		OffsetPtr(q, length(s));		q^ := 13;		OffsetPtr(q, 1);		if crlf then begin			q^ := 10;			OffsetPtr(q, 1);		end;		q^ := ord(':');		OffsetPtr(q, 1);		headerlen := SubPtrPtr(q, p);		p := q;		BlockMoveData(@name, q, length(name) + 1);		OffsetPtr(q, length(name) + 1);		q^ := 0;		OffsetPtr(q, 1);		BlockMoveData(@fi.fdType, q, 4);		OffsetPtr(q, 4);		BlockMoveData(@fi.fdCreator, q, 4);		OffsetPtr(q, 4);		BlockMoveData(@fi.fdFlags, q, 2);		OffsetPtr(q, 2);		BlockMoveData(@dlen, q, 4);		OffsetPtr(q, 4);		BlockMoveData(@rlen, q, 4);		OffsetPtr(q, 4);		count := SubPtrPtr(q, p);		bh.state := 0;		bh.bits := 0;		bh.linepos := 1;		bh.crc := 0;		bh.crlf := crlf;		BinHexEncodeChunk(bh, p, len - headerlen, count, true, false);		count := count + headerlen;	end;	procedure BinHexEncodeChunk (var bh: BinHexEncodeState; p: Ptr; len: longint; var count: longint; eofork, eofile: boolean);{ p & len may be odd, count is in/out }		var			c, newcount: longint;			src, dst: Ptr;			b1, b2, b3: integer;	begin		CalcMBCRCBlock(p, count, bh.crc);		if eofork then begin			BlockMoveData(@bh.crc, AddPtrLong(p, count), 2);			count := count + 2;			bh.crc := 0;		end;		if count > 0 then begin			dst := AddPtrLong(p, len);			src := AddPtrLong(p, count);{ First RLE encode (ie, change $90 to $90,$00) }			newcount := 0;			for c := 1 to count do begin				OffsetPtr(src, -1);				if BAND(src^, $FF) = rep then begin					OffsetPtr(dst, -1);					dst^ := 0;					newcount := newcount + 1;				end;				OffsetPtr(dst, -1);				dst^ := src^;				newcount := newcount + 1;			end;{ Then enhqx }			src := dst;			dst := p;			count := 0;			while newcount > 0 do begin				case bh.state of					0:  begin						while (newcount >= 3) & (bh.linepos < 60) do begin							b1 := src^;							OffsetPtr(src, 1);							b2 := src^;							OffsetPtr(src, 1);							b3 := src^;							OffsetPtr(src, 1);							dst^ := SignedByte(mapbc[BAND(BSR(b1, 2), $3F) + 1]);							OffsetPtr(dst, 1);							dst^ := SignedByte(mapbc[BAND(BOR(BSL(b1, 4), BAND(BSR(b2, 4), $0F)), $3F) + 1]);							OffsetPtr(dst, 1);							dst^ := SignedByte(mapbc[BAND(BOR(BSL(b2, 2), BAND(BSR(b3, 6), $03)), $3F) + 1]);							OffsetPtr(dst, 1);							dst^ := SignedByte(mapbc[BAND(b3, $3F) + 1]);							OffsetPtr(dst, 1);							newcount := newcount - 3;							bh.linepos := bh.linepos + 4;							count := count + 4;						end;						if newcount > 0 then begin							b1 := src^;							OffsetPtr(src, 1);							dst^ := SignedByte(mapbc[BAND(BSR(b1, 2), $3F) + 1]);							OffsetPtr(dst, 1);							bh.bits := b1;							newcount := newcount - 1;							bh.linepos := bh.linepos + 1;							count := count + 1;							bh.state := 2;						end;					end;					2:  begin						b2 := src^;						OffsetPtr(src, 1);						dst^ := SignedByte(mapbc[BAND(BOR(BSL(bh.bits, 4), BAND(BSR(b2, 4), $0F)), $3F) + 1]);						OffsetPtr(dst, 1);						bh.bits := b2;						newcount := newcount - 1;						bh.linepos := bh.linepos + 1;						count := count + 1;						bh.state := 4;					end;					4:  begin						b3 := src^;						OffsetPtr(src, 1);						dst^ := SignedByte(mapbc[BAND(BOR(BSL(bh.bits, 2), BAND(BSR(b3, 6), $03)), $3F) + 1]);						OffsetPtr(dst, 1);						bh.linepos := bh.linepos + 2;						if bh.linepos > 64 then begin							dst^ := 13;							OffsetPtr(dst, 1);							count := count + 1;							if bh.crlf then begin								dst^ := 10;								OffsetPtr(dst, 1);								count := count + 1;							end;							bh.linepos := 1;						end;						dst^ := SignedByte(mapbc[BAND(b3, $3F) + 1]);						OffsetPtr(dst, 1);						newcount := newcount - 1;						count := count + 2;						bh.state := 0;					end;				end;			end;		end;		if eofile then begin			case bh.state of				0:  begin				end;				2:  begin					dst^ := SignedByte(mapbc[BAND(BSL(bh.bits, 4), $3F) + 1]);					OffsetPtr(dst, 1);					count := count + 1;				end;				4:  begin					dst^ := SignedByte(mapbc[BAND(BSL(bh.bits, 2), $3F) + 1]);					OffsetPtr(dst, 1);					count := count + 1;				end;			end;			dst^ := ord(':');			OffsetPtr(dst, 1);			dst^ := 13;			OffsetPtr(dst, 1);			count := count + 2;			if bh.crlf then begin				dst^ := 10;				OffsetPtr(dst, 1);				count := count + 1;			end;		end;	end;	procedure BHGetByte (var bh: BinHexEncodeState; p: Ptr; len: longint; var count: longint; var err: OSErr; var n: integer);		procedure GB (var n: integer);			label				1;			var				b: integer;		begin			if err = noErr then begin1:				while (count < len) & (AddPtrLong(p, count)^ < 32) do begin					count := count + 1;				end;				if count >= len then begin					err := notEnoughData;				end else begin					b := map[BAND(AddPtrLong(p, count)^, $FF)];					count := count + 1;					if b = dud_byte then begin						err := -3;					end else begin						case bh.state of							0:  begin								bh.bits := b;								bh.state := 1;								goto 1;							end;							1:  begin								n := BOR(BSL(bh.bits, 2), BAND(BSR(b, 4), $03));								bh.bits := b;								bh.state := 2;							end;							2:  begin								n := BOR(BSL(bh.bits, 4), BAND(BSR(b, 2), $0F));								bh.bits := b;								bh.state := 3;							end;							3:  begin								n := BOR(BSL(bh.bits, 6), BAND(b, $3F));								bh.state := 0;							end;						end;						n := BAND(n, $FF);					end;				end;			end;		end;		label			1;		var			c: integer;			oldstate: BinHexEncodeState;			oldcount: longint;	begin1:		if err = noErr then begin			oldstate := bh;			oldcount := count;			if bh.repcnt > 0 then begin				n := bh.lastbyte;				bh.repcnt := bh.repcnt - 1;			end else begin				GB(n);				if (err = noErr) & (n = rep) then begin					GB(c);					if err = noErr then begin						case c of							0: 								; { Do nothing, pass back the literal rep }							1: 								goto 1; { Pretty damn stupid to have a rep count of 1 }							otherwise begin								n := bh.lastbyte;								bh.repcnt := c - 2;							end;						end;					end;				end;			end;			if err = notEnoughData then begin				bh := oldstate;				count := oldcount;			end else begin				CalcMBCRC(bh.crc, n);				bh.lastbyte := n;			end;		end;	end;	function BinHexDecodeStart (var bh: BinHexEncodeState; var name: Str63; var fi: FInfo; var dlen, rlen: longint; p: Ptr; len: longint; var count: longint): OSErr;		var			err: OSErr;		procedure GetByte (var n: integer);		begin			BHGetByte(bh, p, len, count, err, n);		end;		procedure GetInteger (var x: univ integer);			var				n, i: integer;		begin			x := 0;			for i := 1 to 2 do begin				GetByte(n);				x := BOR(BSL(x, 8), n);			end;		end;		procedure GetLong (var x: univ longint);			var				n, i: integer;		begin			x := 0;			for i := 1 to 4 do begin				GetByte(n);				x := BOR(BSL(x, 8), n);			end;		end;		var			namelen, n, i: integer;			thecrc, realcrc: integer;	begin		err := notEnoughData;		count := 0;		while count < len - binhex_check_length do begin			if AddPtrLong(p, count)^ = first_binhex_char then begin				if AddPtrLong(p, count + 1)^ = second_binhex_char then begin					i := 3;					while (i <= binhex_check_length) and (AddPtrLong(p, count + i - 1)^ = ord(binhex_start_string[i])) do begin						i := i + 1;					end;					if i > binhex_check_length then begin						err := noErr;						leave;					end;				end;			end;			count := count + 1;		end;		if err = noErr then begin			count := count + binhex_check_length;			while (count < len) & (AddPtrLong(p, count)^ >= 32) do begin				count := count + 1;			end;			while (count < len) & (AddPtrLong(p, count)^ <= 32) do begin				count := count + 1;			end;			if count >= len then begin				err := notEnoughData;			end else if (AddPtrLong(p, count)^ <> ord(':')) then begin				err := -73;			end else begin				count := count + 1;			end;		end;		if err = noErr then begin			bh.state := 0;			bh.repcnt := 0;			bh.crc := 0;			GetByte(namelen);			if (err = noErr) & ((namelen <= 0) | (namelen > 63)) then begin				err := -4;			end;		end;		if (err = noErr) then begin			name[0] := chr(namelen);			if (err = noErr) then begin				for i := 1 to namelen do begin					GetByte(n);					name[i] := chr(n);				end;			end;			GetByte(n);			if (err = noErr) & (n <> 0) then begin				err := -5;			end;			GetLong(fi.fdType);			GetLong(fi.fdCreator);			GetInteger(fi.fdFlags);			GetLong(dlen);			bh.dlen := dlen;			GetLong(rlen);			bh.rlen := rlen;			realcrc := bh.crc;			GetInteger(thecrc);			bh.crc := 0;			bh.datafork := true;			if (err = noErr) & ((dlen < 0) | (dlen > $10000000) | (rlen < 0) | (rlen > $10000000) | (thecrc <> realcrc)) then begin				err := -6;			end;		end;		BinHexDecodeStart := err;	end;	function BinHexDecodeChunk (var bh: BinHexEncodeState; inp: Ptr; inlen: longint; var inused: longint; outp: Ptr; outlen: longint; var outused: longint; var eofork, eofile: boolean): OSErr;		var			err: OSErr;			n, h, l: integer;			oldinused: longint;			oldstate: BinHexEncodeState;			realcrc, thecrc: integer;	begin		err := noErr;		inused := 0;		outused := 0;		eofork := false;		eofile := false;		while (err = noErr) & (bh.dlen > 0) & (outused < outlen) do begin			BHGetByte(bh, inp, inlen, inused, err, n);			if err = noErr then begin				bh.dlen := bh.dlen - 1;				AddPtrLong(outp, outused)^ := n;				outused := outused + 1;			end;		end;		if (err = noErr) & (bh.dlen = 0) then begin			oldstate := bh;			oldinused := inused;			realcrc := bh.crc;			BHGetByte(bh, inp, inlen, inused, err, h);			BHGetByte(bh, inp, inlen, inused, err, l);			if err = noErr then begin				thecrc := BOR(BSL(h, 8), l);				if thecrc <> realcrc then begin					err := -8;				end else begin					eofork := true;					eofile := not bh.datafork;					bh.datafork := false;					bh.dlen := bh.rlen;				end;			end else if err = notEnoughData then begin				err := noErr;				bh := oldstate;				inused := oldinused;			end;		end;		if err = notEnoughData then begin			err := noErr;		end;		BinHexDecodeChunk := err;	end;	procedure StartupBinHex;		var			i: integer;	begin		mapbc := mapbc_hack;		binhex_start_string := binhex_start_string_hack;		for i := 0 to 255 do begin			map[i] := dud_byte;		end;		for i := 1 to length(mapbc) do begin			map[ord(mapbc[i])] := i - 1;		end;		StartupCalcCRC;	end;end.