unit MyTranslateISO;interface	uses		Types;	procedure StartupTranslateISO;	function NetToMac (p: Ptr; len: longint; var last_char_was_cr: boolean): longint;	procedure NetToMacNoEOL (p: Ptr; len: longint);	function MacToNet (p: Ptr; len: longint): longint;	procedure MacToNetNoEOL (p: Ptr; len: longint);implementation	uses		Resources, Errors,Toolutils, MyStartup, MyAssertions;	type		tablArray = packed array[0..255] of Byte;		tablArrayPtr = ^tablArray;			var		tabl:Handle; { NOTE: NetToMac lf->cr }		procedure NetToMacNoEOL (p: Ptr; len: longint);		var			tp:tablArrayPtr;			b:integer;	begin		Assert( (p <> nil) & (len >= 0) );		Assert( tabl <> nil );		tp:=tablArrayPtr(tabl^);		while len>0 do begin			b:=BAND(p^,$FF);			if (b <> 13) & (b <> 10) then begin				p^ := SignedByte(tp^[b]);			end;			Inc(longint(p));			Dec(len);		end;	end;	procedure MacToNetNoEOL (p: Ptr; len: longint);		var			tp:tablArrayPtr;			b:integer;	begin		Assert( (p <> nil) & (len >= 0) );		Assert( tabl <> nil );		tp:=tablArrayPtr(longint(tabl^)+256);		while len>0 do begin			b:=BAND(p^,$FF);			if (b <> 13) & (b <> 10) then begin				p^ := SignedByte(tp^[b]);			end;			Inc(longint(p));			Dec(len);		end;	end;	type		Bytes = packed array[0..0] of Byte;		BytePtr = ^Bytes;	function NetToMac (p: Ptr; len: longint; var last_char_was_cr: boolean): longint;		var			src,dst:BytePtr;			tp:tablArrayPtr;			b:Byte;			last_cr: boolean;	begin		Assert( tabl <> nil );		Assert( (p <> nil) & (len >= 0) );		tp:=tablArrayPtr(tabl^);		last_cr := last_char_was_cr;		src:=BytePtr(p);		dst:=BytePtr(p);		while len>0 do begin			b:=src^[0];			Inc(longint(src));			Dec(len);			if b = 10 then begin				if not last_cr then begin					dst^[0]:= 13;					Inc(longint(dst));				end;				last_cr := false;			end else if b = 13 then begin				dst^[0]:= 13;				Inc(longint(dst));				last_cr := true;			end else begin				dst^[0]:= tp^[b];				Inc(longint(dst));				last_cr := false;			end;		end;		last_char_was_cr := last_cr;		NetToMac:=longint(dst)-longint(p);	end;	function MacToNet (p: Ptr; len: longint): longint;		var			src,dst:BytePtr;			tp:tablArrayPtr;			b:Byte;			i:longint;			destlen:longint;	begin		Assert( tabl <> nil );		Assert( (p <> nil) & (len >= 0) );		tp:=tablArrayPtr(longint(tabl^)+256);		destlen:=len;		src:=BytePtr(p);{ first find the final length of the block }		i:=len;		while i>0 do begin			if src^[0]=13 then begin				Inc(destlen);			end;			Inc(longint(src));			Dec(i)		end;		dst := BytePtr(longint(p) + destlen);		src := BytePtr(longint(p) + len);		i:=len;		while i>0 do begin			Dec(longint(src));			b := src^[0];			if b = 13 then begin				Dec(longint(dst));				dst^[0] := 10;			end;			Dec(longint(dst));			dst^[0] := tp^[b];			Dec(i);		end;		MacToNet:=destlen;	end;	function InitTranslateISO(var msg: integer):OSStatus;		var			err:OSErr;			tp:tablArrayPtr;	begin{$unused(msg)}		tabl:=Get1Resource('taBL',128);		Assert( tabl <> nil );		if tabl<>nil then begin			HNoPurge(tabl);			DetachResource(tabl);			MoveHHi(tabl);			HLock(tabl); { Must be locked, since these routines can be called at interupt time }			tp:=tablArrayPtr(tabl^); { NetToMac map lf -> cr }			tp^[10] := 13;			err:=noErr;		end else begin			err:=resNotFound;		end;		InitTranslateISO:=err;	end;		procedure StartupTranslateISO;	begin		SetStartup(InitTranslateISO, nil, 0, nil);	end;	end.	procedure TestSpeeds;		function NS (n: longint): Str255;			var				s: Str255;		begin			NumToString(n, s);			NS := s;		end;		var			data:Handle;			s:Str255;			i:integer;			t,t1,t2,t3,t4:longint;			size:longint;			len1,len2,len3,len4:longint;			junk:OSErr;	begin		s:=concat('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa',chr(13));		junk := MNewHandle( data, 0 );		for i:=1 to 1000 do begin			junk:=PtrAndHand(@s[1],data,length(s));		end;		size:=GetHandleSize(data);		SetHandleSize(data,size*2);		t:=TickCount;		len1:=MacToNet(data^,size);		t1:=TickCount-t;		t:=TickCount;		len2:=NetToMac(data^,len1);		t2:=TickCount-t;		t:=TickCount;		len3:=PPCMacToNet(data^,len2);		t3:=TickCount-t;		t:=TickCount;		len4:=PPCNetToMac(data^,len3);		t4:=TickCount-t;		DebugStr(concat(NS(size),',',NS(len1),',',NS(len2),',',NS(len3),',',NS(len4),',',NS(t1),',',NS(t2),',',NS(t3),',',NS(t4)));		MDisposeHandle( data );	end;		{ Result was:		61000,62000,61000,62000,61000,8,7,12,8	}