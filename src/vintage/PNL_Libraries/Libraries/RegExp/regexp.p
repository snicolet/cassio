unit RegExp;interface	uses		Types;			const		NSUBEXP  = 10;	type		regexp = record			startp: array[0..NSUBEXP-1] of Ptr;			endp: array[0..NSUBEXP-1] of Ptr;			regstart: longint;			{ Internal use only. }			reganch: longint;		{ Internal use only. }			regmust: Ptr;			{ Internal use only. }			regmlen: longint;		{ Internal use only. }			data: longint;			{ Unwarranted chumminess with compiler. }		end;		regexpPtr = ^regexp;		RegErrorProc = procedure (msg: CStringPtr);		var		regerror_proc: RegErrorProc;			function regcomp( expression: CStringPtr; excompat: longint ): regexpPtr;	procedure regfree( prog: regexpPtr );	function regexec( prog: regexpPtr; data: CStringPtr ): longint;	function regsub( prog: regexpPtr; source: CStringPtr; dest: CStringPtr; n: longint ): CStringPtr;		procedure regerror( msg: CStringPtr ); { you must define this }implementation	procedure regerror( msg: CStringPtr );	begin		if regerror_proc <> nil then begin			regerror_proc( msg );		end;	end;	end.