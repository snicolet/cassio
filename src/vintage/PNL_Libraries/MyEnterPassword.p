unit MyEnterPassword;interface	uses		Events, Dialogs;	procedure CreateEnterPassword (var p: Ptr; dlg: DialogPtr; item: integer);	procedure DisposeEnterPassword (var p: Ptr);	procedure HandleEnterPassword (p: Ptr; var er: EventRecord);	procedure GetEnterPassword (p: Ptr; var password: Str255);	procedure SetEnterPassword (var p: Ptr; password: Str255);	procedure PasteEnterPassword (p: Ptr; h: Handle);	procedure DeleteEnterPassword (p: Ptr);implementation	uses		MyStrings, MyTypes, MyUtils, MyDialogs, MyEvents, MyLowLevel, MyMemory;	const		my_bullet = '¥';	type		EPRecord = record				teh: TEHandle;				dlg: DialogPtr;				item: integer;			end;		EPRecordPtr = ^EPRecord;	procedure CreateEnterPassword (var p: Ptr; dlg: DialogPtr; item: integer);		var			dest, view: Rect;			ep: EPRecordPtr;			junk: OSErr;	begin		SetPort(dlg);		junk := MNewPtr( ep, SizeOf(EPRecord) );		SetRect(dest, 8000, 8010, 8100, 8020);		view := dest;		ep^.teh := TENew(dest, view);		ep^.dlg := dlg;		ep^.item := item;{    h := TEGetText(ep^.teh);}		p := Ptr(ep);	end;	procedure DisposeEnterPassword (var p: Ptr);		var			ep: EPRecordPtr;	begin		ep := EPRecordPtr(p);		TEDispose(ep^.teh);		MDisposePtr( ep );		p := nil;	end;	procedure SetEnterPassword (var p: Ptr; password: Str255);		var			ep: EPRecordPtr;			i: integer;	begin		ep := EPRecordPtr(p);		TESetText(@password[1], length(password), ep^.teh);		for i := 1 to length(password) do begin			password[i] := my_bullet;		end;		SetItemText(ep^.dlg, ep^.item, password);	end;	procedure GetEnterPassword (p: Ptr; var password: Str255);		var			ep: EPRecordPtr;			h: CharsHandle;	begin		ep := EPRecordPtr(p);		h := TEGetText(ep^.teh);		HandleToString(h, password);	end;	procedure HandleEnterPassword (p: Ptr; var er: EventRecord);		var			ep: EPRecordPtr;			ch: Char;	begin		ep := EPRecordPtr(p);		if (ep^.dlg = FrontWindow) & (SelectedTextItem(ep^.dlg) = ep^.item) then begin			if EventIsKeyDown( er ) & not EventHasCommandKey( er ) then begin				ch := EventChar( er );				case ch of					cr, enter, tab, leftArrow, rightArrow, upArrow, downArrow:						;					otherwise begin						if (ch <> bs) & (ch < spc) then begin							SysBeep(1);							er.what := nullEvent;						end else begin							TESetSelect(DialogPeek(ep^.dlg)^.textH^^.selStart, DialogPeek(ep^.dlg)^.textH^^.selEnd, ep^.teh);							TEKey(ch, ep^.teh);							if (ch <> bs) & DirtyKey(ch) then begin								er.message := ord(my_bullet);							end;						end;					end;				end;			end;		end;	end;	procedure PasteEnterPassword (p: Ptr; h: Handle);		var			ep: EPRecordPtr;			len: longint;			i: integer;			s: Str255;			bad: boolean;			th: TEHandle;	begin		ep := EPRecordPtr(p);		if (SelectedTextItem(ep^.dlg) = ep^.item) then begin			len := GetHandleSize(h);			bad := len > 255;			if not bad then begin				for i := 0 to len - 1 do begin					if BAND(AddPtrLong(h^, i)^, $FF) < 32 then begin						bad := true;						leave;					end;				end;			end;			if bad then begin				SysBeep(1);			end else begin				th := DialogPeek(ep^.dlg)^.textH;				HLock(h);				TESetSelect(th^^.selStart, th^^.selEnd, ep^.teh);				TEDelete(ep^.teh);				TEInsert(h^, len, ep^.teh);				s[0] := chr(len);				for i := 1 to len do begin					s[i] := my_bullet;				end;				TEDelete(th);				TEInsert(@s[1], len, th);			end;		end;	end;		procedure DeleteEnterPassword (p: Ptr);		var			ep: EPRecordPtr;			th: TEHandle;	begin		ep := EPRecordPtr(p);		if (SelectedTextItem(ep^.dlg) = ep^.item) then begin			th := DialogPeek(ep^.dlg)^.textH;			TESetSelect(th^^.selStart, th^^.selEnd, ep^.teh);			TEDelete(ep^.teh);			TEDelete(th);		end;	end;	end.