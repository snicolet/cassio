unit MyGrowZones;interface	uses		Types;	procedure StartupGrowZones;	procedure ConfigureGrowZones(size: longint);	function MemoryCritical: boolean;	function EnoughSpace (total, contig: longint): boolean;	procedure IdleGrowZone; { Called by IdleStartup, you can call it yourself }implementation	uses		Memory, OSUtils,		PreserveA5, MyCallProc, MyStartup, MyMemory;	var		gzh: Handle;		gz_size: longINt;	function MyGrowZone (size: longint): longint;		var			saved_A5:Ptr;	begin{$unused(size)}		saved_A5 := SetPreservedA5;		if gzh <> nil then begin			MyGrowZone := GetHandleSize(gzh);			MDisposeHandle( gzh );		end else begin			MyGrowZone := 0;		end;		RestoreA5(saved_A5);	end;	function MemoryCritical: boolean;	begin		MemoryCritical := gzh = nil;	end;	function EnoughSpace (total, contig: longint): boolean;		var			t, c: longint;	begin		PurgeSpace(t, c);		EnoughSpace := not MemoryCritical and (t >= total) and (c >= contig);	end;	procedure IdleGrowZone;		var			junk: OSErr;	begin		if gzh = nil then begin			junk := MNewHandle( gzh, gz_size );		end;	end;	procedure ConfigureGrowZones(size: longint);	begin		StartupGrowZones;		gz_size := size;	end;		function InitGrowZone(var msg: integer): OSStatus;	begin{$unused(msg)}		SetGrowZone(NewProc(@MyGrowZone,uppPascal44ProcInfo));		gzh := nil;		IdleGrowZone;		InitGrowZone := noErr;	end;	procedure FinishGrowZone;	begin		if gzh <> nil then begin			MDisposeHandle( gzh );		end;	end;	procedure StartupGrowZones;	begin		StartupPreserveA5;		SetStartup(InitGrowZone, IdleGrowZone, 30, FinishGrowZone);	end;	end.