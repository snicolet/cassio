unit MyWindowsMenu;interface	procedure StartupWindowsMenu;	procedure UpdateWindowsMenu;	function DoWindowsMenuItem (themenu, theitem: integer): boolean;implementation	uses		Fonts, MyFMenus, MyTypes, MyStartup, MyMenus, MyOOMainLoop, MyStrings;	var		menu: MenuHandle;		skip, base: integer;		wason: boolean;	function GetNextWindow (var wp: WindowPeek): boolean;	begin		if wp = nil then begin			wp := WindowPeek(FrontWindow);		end else begin			wp := wp^.nextWindow;		end;		while (wp <> nil) & (not wp^.visible | (GetWType(WindowPtr(wp)) = WT_NotMine)) do begin			wp := wp^.nextWindow;		end;		GetNextWindow := wp <> nil;	end;	procedure SetEnableMenu (on: boolean);	begin		if (skip > 0) then begin			SetFMenu(M_Windows);			if (BAND(menu^^.enableFlags, BSL(1, skip) - 1) <> 0) then begin				on := true;			end;		end;		if wason <> on then begin			wason := on;			SetItemEnable(menu, 0, on);			DrawMenuBar;		end;	end;	procedure UpdateWindowsMenu;		var			wp: WindowPeek;			title: Str255;			i: integer;			first: boolean;	begin		for i := CountMItems(menu) downto skip + 1 do begin			DeleteMenuItem(menu, i);		end;		wp := nil;		first := true;		while GetNextWindow(wp) do begin			if first and (skip > 0) then begin				AppendMenu(menu, '(-');			end;			GetWTitle(WindowPtr(wp), title);			LimitStringLength(title, 40, 'É');			SafeAppendMenu(menu, title);			if first & (WindowPtr(wp) = FrontWindow) then begin				SetItemMark(menu, base, chr(checkMark));			end;			first := false;		end;		SetEnableMenu(not first);	end;	function DoWindowsMenuItem (themenu, theitem: integer): boolean;		var			wp: WindowPeek;	begin		DoWindowsMenuItem := false;		if (themenu = M_Windows) and (theitem >= base) then begin			DoWindowsMenuItem := true;			wp := nil;			while (theitem >= base) do begin				if not GetNextWindow(wp) then begin					leave;				end;				theitem := theitem - 1;			end;			if wp <> nil then begin				SelectWindow(WindowPtr(wp));			end;			HiliteMenu(0);		end;	end;	procedure SetSendToBack(themenu,theitem:integer);		var			wp:WindowPeek;	begin		wp:=nil;		SetIDItemEnable(themenu, theitem, GetNextWindow(wp) & GetNextWindow(wp)); { At least two windows }	end;		procedure DoSendToBack;		var			wp,first, last:WindowPeek;	begin		wp:=nil;		if GetNextWindow(wp) then begin			first := wp;			last:=nil;			while GetNextWindow(wp) do begin				last := wp;			end;			if last<>nil then begin				SendBehind(WindowPtr(first),WindowPtr(last));			end;		end;	end;		function InitWindowsMenu( var msg: integer ): OSStatus;	begin{$unused(msg)}		menu := GetFMenu(M_Windows);		InsertMenu(menu, 0);		skip := CountMItems(menu);		base := skip + 1 + ord(skip > 0);		wason := true;		UpdateWindowsMenu;		SetFBoth('stbk', DoSendToBack, SetSendToBack);		InitWindowsMenu := noErr;	end;	procedure StartupWindowsMenu;	begin		StartupFMenus;		SetStartup( InitWindowsMenu, nil, 0, nil );	end;end.