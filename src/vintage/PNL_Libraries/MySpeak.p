unit MySpeak;interface	uses		Types;	procedure StartupSpeak;	function SpeakBusy: boolean;	procedure SpeakStr (s: Str255);	procedure Speak (id, index: integer);	function SpeechAvailable: boolean;implementation	uses		Speech, GestaltEqu, TextUtils, CodeFragments,		MyStartup;{$SETC debug=0}	function HasSpeechLib:boolean;	begin{$IFC GENERATINGPOWERPC}		HasSpeechLib := longint(@SpeakString) <> kUnresolvedCFragSymbolAddress;{$ELSEC}		HasSpeechLib := true;{$ENDC}	end;	function SpeechAvailable: boolean;		var			v: longint;	begin{$IFC debug}		SpeechAvailable := true;{$ELSEC}		SpeechAvailable := (Gestalt(gestaltSpeechAttr, v) = noErr) and BTST(v, gestaltSpeechMgrPresent) and HasSpeechLib;{$ENDC}	end;	function SpeakBusy: boolean;	begin{$IFC debug}		SpeakBusy := false;{$ELSEC}		SpeakBusy := SpeechAvailable and (SpeechBusy > 0);{$ENDC}	end;	procedure SpeakStr (s: Str255);	begin{$IFC debug}		DebugStr(concat('Speak ', s));{$ELSEC}		if not SpeechAvailable or (SpeakString(@s) <> noErr) then begin			SysBeep(1);		end;{$ENDC}	end;	procedure Speak (id, index: integer);		var			s: Str255;	begin		GetIndString(s, id, index);		SpeakStr(s);	end;	procedure FinishSpeak;	begin{$IFC not debug}		if SpeechAvailable then begin			SpeakStr('');		end;{$ENDC}	end;	procedure StartupSpeak;	begin		SetStartup(nil, nil, 0, FinishSpeak);	end;	end.