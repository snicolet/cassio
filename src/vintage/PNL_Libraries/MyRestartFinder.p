unit MyRestartFinder;interface	uses		Files;	procedure RestartFinder (tofront, dontwait: boolean);	procedure QuitFinder;	procedure GetFinderFS (var fs: fileInfo);	procedure StartFinder (fs: fileInfo; tofront, dontwait: boolean);implementation	uses		AppleEvents, MyProcesses, MyFDFlags;	const		finder_creator = 'MACS';		finder_type = 'FNDR';		sharing_creator = 'hhgg';		sharing_type = 'INIT';	procedure QuitFinder;	begin		QuitApplication(sharing_creator, sharing_type);		QuitApplication(finder_creator, finder_type);	end;	procedure GetFinderFS (var fs: fileInfo);		var			psn: ProcessSerialNumber;	begin		if not FindProcess(finder_creator, finder_type, psn, fs) then begin			fs.name := '';		end;	end;	procedure StartFinder (fs: fileInfo; tofront, dontwait: boolean);		var			psn, our_psn: ProcessSerialNumber;			er: EventRecord;			dummy: boolean;			same: boolean;			t: longint;			junk: OSErr;	begin		if GetCurrentProcess(our_psn) = noErr then begin			if fs.name = '' then begin				junk := LaunchApp(finder_creator, finder_type, tofront);			end else begin				junk := LaunchFSSpec(fs, tofront);			end;			if not dontwait then begin{ Wait until we're not the FrontProcess, else we may ExitToShell before the Finder }{ has fully restarted - which causes system error 41 if we are the only app running. }				t := TickCount + 10 * 60;				while (GetFrontProcess(psn) = noErr) and (SameProcess(psn, our_psn, same) = noErr) and same and (TickCount < t) do begin					dummy := WaitNextEvent(everyEvent, er, 15, nil);				end;			end;		end;	end;	procedure RestartFinder (tofront, dontwait: boolean);		var			finder_fs: fileInfo;	begin		GetFinderFS(finder_fs);		QuitFinder;		StartFinder(finder_fs, tofront, dontwait);	end;end.