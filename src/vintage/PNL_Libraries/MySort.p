unit MySort;interface			type		SortObject = object			procedure GetEntry( n: longint; dst_left: boolean ); { override and retrieve to left/right entry }			procedure SetEntry( n: longint; src_left: boolean ); { override and set from left/right entry }			function Compare: integer; { override and return -1, 0, 1 }			procedure Sort( count: longint );		end;implementation	procedure SortObject.GetEntry( n: longint; dst_left: boolean );	begin{$unused(n,dst_left)}	end;		procedure SortObject.SetEntry( n: longint; src_left: boolean );	begin{$unused(n,src_left)}	end;		function SortObject.Compare: integer;	begin		Compare := 0;	end;		procedure SortObject.Sort( count: longint );		var			i, j: longint;	begin		for i := 2 to count do begin			GetEntry( i, true );			j := i - 1;			repeat				GetEntry( j, false );				if Compare < 0 then begin					SetEntry( j + 1, false );					j := j - 1;				end else begin					leave;				end;			until j = 0;			SetEntry( j + 1, true );		end;	end;end.	type		MySortObject = object(SortObject)				data: Str255;				left, right: char;				procedure GetEntry( n: longint; dst_left: boolean );				override;				procedure SetEntry( n: longint; src_left: boolean );				override;				function Compare: integer;				override;			end;				procedure MySortObject.GetEntry( n: longint; dst_left: boolean );	begin		if dst_left then begin			left := data[n];		end else begin			right := data[n];		end;	end;		procedure MySortObject.SetEntry( n: longint; src_left: boolean );	begin		if src_left then begin			data[n] := left;		end else begin			data[n] := right;		end;	end;		function MySortObject.Compare: integer;	begin		if left < right then begin			Compare := -1;		end else if left = right then begin			Compare := 0;		end else begin			Compare := 1;		end;	end;		var		obj: MySortObject;begin	writeln('Hello');	new(obj);	obj.data := 'testing1234cba';	writeln( obj.data );	obj.Sort( length(obj.data) );	writeln( obj.data );end.