unit MyProgress;interface	uses		Types;	procedure PaintBarberPoll (r: Rect; offset: integer);	procedure PaintProgress (r: Rect; done, total: longint);implementation	uses		Memory, FixMath,		MyTypes, MyLowLevel, MyUtils, MyMemory;	var		gPPFilled,gPPEmpy:Rect;		procedure PaintProgress (r: Rect; done, total: longint);		var			w, uw: integer;			dark,light:RGBColor;	begin		FrameRect(r);		InsetRect(r, 1, 1);		if total<0 then begin			EraseRect(r);		end else begin			w := r.right - r.left;			if total <= 0 then begin				uw := 0;			end else if done >= total then begin				uw := w;			end else begin				uw := FracMul(w, FracDiv(done, total));			end;			gPPFilled:=r;			gPPEmpy:=r;			gPPFilled.right := r.left + uw;			gPPEmpy.left :=  r.left + uw;				MakeRGBColor($4000,$4000,$4000,dark);			MakeRGBColor($CCCC,$CCCC,$FFFF,light);			RGBForeColor(dark);			RGBBackColor(light);			PaintRect(gPPFilled);			RGBForeColor(light);			RGBBackColor(dark);			PaintRect(gPPEmpy);			ForeColor(blackColor);			BackColor(whiteColor);		end;	end;{$PUSH}{$ALIGN MAC68K}	type		MyPicture = record				size: integer;				r1: Rect;				data1: array[1..17] of integer;				r2: Rect;				nintyeight: integer;				rowbytes: integer;				r3: Rect;				data2: array[1..34] of integer;				r4: Rect;				r5: Rect;				mode: integer;				eor: integer;			end;		MyPicturePtr = ^MyPicture;		MyPictureHandle = ^MyPicturePtr;{$ALIGN RESET}{$POP}	procedure PaintBarberPoll (r: Rect; offset: integer);		var			ph: MyPictureHandle;			rb: integer;			ts: integer;			p: ^integer;			i, j: integer;			b1, b2: integer;			o: integer;			junk: OSErr;	begin		FrameRect(r);		InsetRect(r, 1, 1);		rb := (2 * (r.right - r.left) + 15) div 16 * 2;		ts := SizeOf(MyPicture) + (r.bottom - r.top) * (rb + 2);		junk := MNewHandle( ph, ts );		HLock(Handle(ph));		with ph^^ do begin			size := ts;			r1 := r;			r2 := r;			r3 := r;			r4 := r;			r5 := r;			nintyeight := $0098;			rowbytes := BOR(rb, $8000);			mode := 0;			StuffHex(@data1, '001102FF0C00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0001000A');			StuffHex(@data2, '0000000000000000004800000048000000000002000100020000000000000000000000000000000000000002000000000000000000014444444444440002CCCCCCCCFFFF');			p := @eor;			for i := r.top to r.bottom - 1 do begin				p^ := BOR(BSL(rb + 1, 8), rb - 1);				OffsetPtr(p, 2);				o := BAND((offset + i) * 2, 31);				if o < 16 then begin					b1 := BSR($5555AAAA, o);					b2 := BSR($AAAA5555, o);				end else begin					b1 := BSR($AAAA5555, o - 16);					b2 := BSR($5555AAAA, o - 16);				end;				for j := 1 to rb div 2 do begin					if odd(j) then begin						p^ := b1;					end else begin						p^ := b2;					end;					OffsetPtr(p, 2);				end;			end;			p^ := $00FF; {end of record}		end;		DrawPicture(PicHandle(ph), r);		MDisposeHandle( ph );	end;end.