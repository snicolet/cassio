unit MyOOMainLoop;interface	uses		Types, Menus, Quickdraw, QuickdrawText, Events, Windows, Dialogs, AppleEvents, Drag,		MyFMenus;	const		WT_NotMine = 'NtMe';		WT_Generic = 'Genr';		bad_window_id = -1;		kAECloseAll = 'Clos';	type		SCType = (SCSave, SCCancel, SCDiscard);		WObject = object				window: DialogPtr;				resid: integer;				window_type: OSType;				window_id: longint;				growRect: Rect; { minimum/maximum Rect size (for use with grow window) }				zoomSize: Point; { Optimum zoom size }				zoomed: boolean;				unzoomed: Rect;				draw_grow_icon: boolean;				is_active: boolean;				is_default_object: boolean;				close_hides_window: boolean;				popup_title_menu: MenuHandle;				AppleGuideWindowType: Str31;				onlyone: ^WObject;	{ Set onlyone^ to nil when we destroy ourselves }				timetoclose:boolean;				{ private TrackingHandler variables }				th_can_accept_drag: boolean;				th_drag_hilited: boolean;				th_drag_hilite_visible: boolean;				th_ever_left_original_hilite_region: boolean;				th_drag_hilite_rgn: RgnHandle;				th_drag_original_hilite_rgn: RgnHandle;				th_drag_invert_rgn: RgnHandle;				procedure JointCreate (id: integer);				procedure Create (id: integer);				procedure CreateBehind (id: integer; behind: WindowPtr);				procedure Destroy;				procedure GetWindowPos (h: Handle);				procedure SetWindowPos (h: Handle; var wasvisible: boolean);				function SaveChangesID (alert_id: integer): integer;				function SaveChanges: SCType;				procedure DoClose;{ DoClose checks modified things etc, then calls Destroy }				function SetMenuBar: boolean;				procedure SetMenus;				function EditMenuEnabled: boolean;				procedure SetEditMenuItem (item: integer);				procedure DoEditMenu (item: integer);				function GetAESelection (var reply: AppleEvent): OSErr;				function GetAEWindow (var windowrec: AERecord): OSErr;				function DoMenuKey (const er: EventRecord; ch: char): longint;				procedure CalculateRegion (var rgn: RgnHandle);				function WaitForEvent (var er: EventRecord; sleep: longint): boolean;				procedure DoIdle;				procedure DoIdleAlways;				procedure DoDiskEvent (message: longint);				procedure DoSuspendResume (resume: boolean);				procedure DoHighLevel (const er: EventRecord);				procedure DoContent (const er: EventRecord);				procedure DoKey (const er:EventRecord; ch: char);				procedure DoSpecialKey (const er:EventRecord; ch: char);				procedure DoAutoKey (const er:EventRecord; ch: char);				procedure DoPopupTitle (choice: integer);				function CheckPopupTitle (where: Point): boolean;				procedure DoDrag (where: Point);				procedure DoGrow (where: Point);				procedure Zoom (zoomout: boolean; fullscreen: boolean);				procedure DoZoom (where: Point; code: integer);				procedure DoGoAway (where: Point);				procedure DoUpdate;				procedure DoMouseMoved (where: Point);				procedure DrawGrow;				procedure DoActivateDeactivate (activate: boolean);				procedure TextChanged; { called for paste/clear/cut/key down etc }				procedure Resize;				procedure InitialZoom (h, v: integer);				procedure Draw;				procedure TrackingRemoveHiliting(dragref: DragReference); { must be idenpotent }				function TrackingHandler (message: DragTrackingMessage; dragref: DragReference): OSErr;				function MyTrackingEnterWindow( dragref: DragReference ): Boolean;				procedure MyTrackingLeaveWindow( dragref: DragReference );				procedure MyTrackingInWindow( dragref: DragReference; localwhere: Point; var new_drag_hilited: Boolean; new_drag_hilite_rgn, new_drag_invert_rgn: RgnHandle );				function ReceiveHandler (dragref: DragReference): OSErr;				function DragSend (flavor: FlavorType; item: ItemReference; dragref: DragReference): OSErr;				function DoSetupDrag (dragref: DragReference; dragrgn: RgnHandle): OSErr;				procedure DoTrackDrag (const er: EventRecord);				function DoMainClick (const er: EventRecord; wp: WindowPtr; code: integer): boolean;				function DoIsDialogEvent (const er: EventRecord): boolean;				function DoDialogSelect (const er: EventRecord; var dlg: DialogPtr; var item: integer): boolean;				function HandleSimpleEvents (var er: EventRecord): boolean;				function HandleEvents (var er: EventRecord): boolean;			end;		DObject = object(WObject)				ok_item, cancel_item, outline_item: integer;				handle_shift_tab: boolean;				disable_edit_menu: boolean;				text_return: boolean;				support_edittext_draging_send: Boolean;				support_edittext_draging_receive: Boolean;				procedure Create (id: integer);				override;				procedure CreateBehind (id: integer; behind: WindowPtr);				override;				procedure Destroy;				override;				procedure SetOOOutline (def_item, user_item: integer);				procedure DrawOutline;				procedure DrawUserItem( item: integer );				procedure HandleUserItem( item: integer );				procedure HandleAllUserItems;				procedure DoActivateDeactivate (activate: boolean);				override;				function HandleEvents (var er: EventRecord): boolean;				override;				procedure DoItem (item: integer);				procedure DoItemWhere (const er: EventRecord; item: integer);				procedure DoCancel (const er:EventRecord; ch: char);				procedure DoOK (const er:EventRecord; ch: char);				procedure DoDialogCut;				procedure DoDialogCopy;				procedure DoDialogPaste;				procedure DoDialogDelete;				procedure SetEditMenuItem (item: integer);				override;				function EditMenuEnabled: boolean;				override;				procedure DoEditMenu (item: integer);				override;				function DoIsDialogEvent (const er: EventRecord): boolean;				override;				function GetAESelection (var reply: AppleEvent): OSErr;				override;				procedure CalculateRegion (var rgn: RgnHandle);				override;				procedure InsertTextAndSelect( field: integer; offset: integer; data: Str255 );				function MyTrackingEnterWindow( dragref: DragReference ): Boolean;				override;				procedure MyTrackingLeaveWindow( dragref: DragReference );				override;				procedure MyTrackingInWindow( dragref: DragReference; localwhere: Point; var new_drag_hilited: Boolean; new_drag_hilite_rgn, new_drag_invert_rgn: RgnHandle );				override;				function ReceiveHandler(dragref: DragReference): OSErr;				override;			end;	var		default_object: WObject;		edit_menu_always_enabled: boolean;		last_event_time: longint;		last_event: EventRecord;		last_event_had_option: boolean;		last_event_had_command: boolean;		last_event_had_shift: boolean;		last_event_had_control: boolean;		has_DragManager: boolean;	procedure StartupMainLoop;	procedure ConfigureMainLoop (dobj: DObject);{ dobj will be used returned with window set to wp whenever GetWObject/GetDObject is called with a DA or nil window }	function GetWType (wp: WindowPtr): OSType;	function GetWObject (wp: WindowPtr): WObject;	function GetDObject (dlg: DialogPtr): DObject;	function FrontObject: WObject;	function IsWObjectFront (o: WObject): boolean;	function FindWindowID (id: longint): WObject;	procedure DoCloseAll (all: boolean);{	procedure CallIdleAlways;}implementation	uses		Memory, ToolUtils, Scrap, Fonts, Resources, Errors, DiskInit, AEObjects, AERegistry, 		OSUtils, EPPC, TextEdit, 		CodeFragments, Drag, Script, Processes, GestaltEqu, MixedMode, MyStartup, MyStrings, MyAssertions, 		MyMenus, MyTypes, MyFMenus, BaseGlobals, MySystemGlobals, MyCursors,MyCallProc, MyEvents,		MyCleverAlerts, MyTEUtils, MyAssertions, MyDialogs, MyAEUtils, MyWindows, MyMathUtils, 		MyDrag, MyLowLevel, MyUtils, MyTextEdit, MyRegions, MyMemory;	const		titlebar_hight = 18;	const{ from EPPC }		OOMagic = 'MyOO';		BadOOMagic = 'bado';	type		myWindowRecord = record				thewindow: WindowRecord;				magic: OSType;			end;		myWindowPtr = ^myWindowRecord;		myDialogRecord = record				thedialog: DialogRecord;				magic: OSType;			end;		myDialogPtr = ^myDialogRecord;	var		last_window_id: longint;		gMyDragSendProc : UniversalProcPtr;		dDrawUserItemProc: UniversalProcPtr;	procedure DoCloses (all: boolean);		var			fw: WindowPtr;	begin		if all then begin			fw := FrontWindow;			while fw <> nil do begin				FrontObject.DoClose;				if fw = FrontWindow then begin					leave;				end;				fw := FrontWindow;			end;		end else begin			FrontObject.DoClose;		end;	end;	function HandleClose (var event, reply: AppleEvent; refcon: longint): OSErr;		var			err: OSErr;	begin{$unused(event, reply)}		if FrontWindow <> nil then begin			DoCloses(refcon <> 0);			err := noErr;		end else begin			err := errAENoSuchObject;		end;		HandleClose := err;	end;	procedure DoCloseAll (all: boolean);	begin		if has_AppleEvents then begin			if all then begin				SendSelfSimpleEvent(kAECoreSuite, kAECloseAll);			end else begin				SendSelfSimpleEvent(kAECoreSuite, kAEClose);			end;		end else begin			DoCloses(all);		end;	end;	function GetWRC (wp: WindowPtr): WObject;		var			rc: longint;	begin		rc := 0;		if (wp <> nil) & WindowInWindowList(wp) & (WindowPeek(wp)^.windowKind >= 0) then begin			if ((WindowPeek(wp)^.windowKind = dialogKind) & (myDialogPtr(wp)^.magic = OOMagic)) | (myWindowPtr(wp)^.magic = OOMagic) then begin				rc := GetWRefCon(wp);			end;		end;		if rc = 0 then begin			default_object.window := wp;			rc := longint(default_object);		end;		GetWRC := WObject(rc);	end;	function GetWType (wp: WindowPtr): OSType;		var			wo: WObject;	begin		wo := GetWRC(wp);		if wo.is_default_object then begin			GetWType := WT_NotMine;		end else begin			GetWType := wo.window_type;		end;	end;	function GetWObject (wp: WindowPtr): WObject;	begin		GetWObject := GetWRC(wp);	end;	function FindWindowID (id: longint): WObject;		const			WindowList = $9D6;		type			WindowPtrPtr = ^WindowPtr;		var			w: WindowPtr;			wo: WObject;	begin		FindWindowID := nil;		if id <> bad_window_id then begin			w := WindowPtrPtr(WindowList)^;			while w <> nil do begin				wo := GetWObject(w);				if (not wo.is_default_object) & (wo.window_id = id) then begin					FindWindowID := wo;					leave;				end;				w := WindowPtr(WindowPeek(w)^.nextWindow);			end;		end;	end;	function GetDObject (dlg: DialogPtr): DObject;	begin		GetDObject := DObject(GetWRC(dlg));	end;	function FrontObject: WObject;	begin		FrontObject := GetWRC(FrontWindow);	end;	function IsWObjectFront (o: WObject): boolean;	begin		if o = nil then begin			IsWObjectFront := false;		end else if o.window = nil then begin			IsWObjectFront := false;		end else begin			IsWObjectFront := o.window = FrontWindow;		end;	end;	function WObject.MyTrackingEnterWindow( dragref: DragReference ): Boolean;	begin{$unused(dragref)}		MyTrackingEnterWindow := false;	end;		procedure WObject.MyTrackingLeaveWindow( dragref: DragReference );	begin{$unused(dragref)}	end;	procedure WObject.MyTrackingInWindow( dragref: DragReference; localwhere: Point; var new_drag_hilited: Boolean; new_drag_hilite_rgn, new_drag_invert_rgn: RgnHandle );	begin{$unused(dragref, localwhere, new_drag_hilited, new_drag_hilite_rgn, new_drag_invert_rgn)}		new_drag_hilited := false;	end;	procedure WObject.TrackingRemoveHiliting( dragref: DragReference ); { must be idenpotent }		var			junk: OSErr;	begin		if th_drag_hilite_visible then begin			junk := HideDragHilite( dragref );			th_drag_hilite_visible := false;		end;		if th_drag_hilited then begin			InvertRgn( th_drag_invert_rgn );			MakeRegionEmpty( th_drag_invert_rgn );			th_drag_hilited := false;		end;	end;		function WObject.TrackingHandler (message: DragTrackingMessage; dragref: DragReference): OSErr;		var			mouse, pinnedmouse: Point;			attributes: DragAttributes;			new_drag_hilited, new_drag_hilite_visible: boolean;			new_drag_hilite_rgn, new_drag_invert_rgn: RgnHandle;			err: OSErr;			has_left_sender_window, in_sender_window: Boolean;	begin		SetPort(window);		err := GetDragAttributes(dragref, attributes);		in_sender_window := (band(attributes, dragInsideSenderWindow) <> 0);		has_left_sender_window := (band(attributes, dragHasLeftSenderWindow) <> 0);		if err = noErr then begin			case message of				dragTrackingEnterHandler, dragTrackingLeaveHandler: 					;  { WE DONT GET THESE! }				dragTrackingEnterWindow:  begin					th_drag_hilited := false;					th_drag_hilite_visible := false;					th_drag_hilite_rgn := NewRgn;					th_drag_invert_rgn := NewRgn;					th_drag_original_hilite_rgn := NewRgn;					th_can_accept_drag := MyTrackingEnterWindow( dragref );					if in_sender_window & (GetDragOrigin( dragref, mouse ) = noErr) then begin{DebugStr( 'In Sender, got origin' );}						GlobalToLocal( mouse );						MyTrackingInWindow( dragref, mouse, new_drag_hilited, th_drag_original_hilite_rgn, th_drag_invert_rgn );						SetEmptyRgn( th_drag_invert_rgn );						if not new_drag_hilited then begin							SetEmptyRgn( th_drag_original_hilite_rgn );						end;					end;					th_ever_left_original_hilite_region := EmptyRgn( th_drag_original_hilite_rgn );				end;				dragTrackingInWindow:  begin					if th_can_accept_drag then begin						err := GetDragMouse(dragref, mouse, pinnedmouse);						GlobalToLocal(mouse);												if not th_ever_left_original_hilite_region then begin							th_ever_left_original_hilite_region := has_left_sender_window | not PtInRgn( mouse, th_drag_original_hilite_rgn );						end;												new_drag_hilite_rgn := NewRgn;						new_drag_invert_rgn := NewRgn;						MyTrackingInWindow( dragref, mouse, new_drag_hilited, new_drag_hilite_rgn, new_drag_invert_rgn );						new_drag_hilite_visible := new_drag_hilited and th_ever_left_original_hilite_region;						if not new_drag_hilited then begin							SetEmptyRgn( new_drag_invert_rgn );						end;						if not new_drag_hilite_visible then begin							SetEmptyRgn( new_drag_hilite_rgn );						end;												{ update the hilite region }						if (new_drag_hilite_visible <> th_drag_hilite_visible) | not EqualRgn( new_drag_hilite_rgn, th_drag_hilite_rgn ) then begin							if th_drag_hilite_visible then begin								err := HideDragHilite(dragref);							end;							if new_drag_hilite_visible then begin								err := ShowDragHilite(dragref, new_drag_hilite_rgn, true);							end;							DisposeRgn( th_drag_hilite_rgn );							th_drag_hilite_rgn := new_drag_hilite_rgn;						end else begin							DisposeRgn( new_drag_hilite_rgn );						end;						{ update the invert region }						if not EqualRgn( new_drag_invert_rgn, th_drag_invert_rgn ) then begin							XorRgn( new_drag_invert_rgn, th_drag_invert_rgn, new_drag_invert_rgn ); { invert them both }							InvertRgn( new_drag_invert_rgn );							XorRgn( new_drag_invert_rgn, th_drag_invert_rgn, new_drag_invert_rgn ); { remove old }							DisposeRgn( th_drag_invert_rgn );							th_drag_invert_rgn := new_drag_invert_rgn;						end else begin							DisposeRgn( new_drag_invert_rgn );						end;												th_drag_hilited := new_drag_hilited;												th_drag_hilite_visible := new_drag_hilite_visible;											end;				end;				dragTrackingLeaveWindow:  begin					TrackingRemoveHiliting( dragref );					MyTrackingLeaveWindow( dragref );					th_can_accept_drag := false;					DisposeRgn( th_drag_hilite_rgn );					DisposeRgn( th_drag_invert_rgn );					DisposeRgn( th_drag_original_hilite_rgn );				end;				otherwise begin					{ do nothing }				end;			end;		end;		TrackingHandler := err;	end;	function MyTrackingHandler (message: DragTrackingMessage; window: WindowPtr; refcon: Ptr; dragref: DragReference): OSErr;	begin{$unused(refcon)}		MyTrackingHandler := GetWObject(window).TrackingHandler(message, dragref);	end;	function WObject.ReceiveHandler (dragref: DragReference): OSErr;	begin{$unused(dragref)}		ReceiveHandler := -1;	end;	function MyReceiveHandler (window: WindowPtr; refcon: Ptr; dragref: DragReference): OSErr;	begin{$unused(refcon)}		MyReceiveHandler := GetWObject(window).ReceiveHandler(dragref);	end;	function WObject.DragSend (flavor: FlavorType; item: ItemReference; dragref: DragReference): OSErr;	begin{$unused(flavor, item, dragref)}		DragSend := -1;	end;	var		drag_obj: WObject;	function MyDragSend (flavor: FlavorType; refcon: Ptr; item: ItemReference; dragref: DragReference): OSErr;	begin{$unused(refcon)}		MyDragSend := drag_obj.DragSend(flavor, item, dragref);	end;	function WObject.DoSetupDrag (dragref: DragReference; dragrgn: RgnHandle): OSErr;	begin{$unused(dragref, dragrgn)}		DoSetupDrag := -1;	end;	procedure WObject.DoTrackDrag (const er: EventRecord);		var			err: OSErr;			dragref: DragReference;			dragrgn: RgnHandle;	begin		drag_obj := self;		err := NewDrag(dragref);		if err = noErr then begin			dragrgn := NewRgn;			err := MemError;			if err = noErr then begin				err := DoSetupDrag(dragref, dragrgn);				if err = noErr then begin					err := SetDragSendProc(dragref, gMyDragSendProc, nil);				end;				if err = noErr then begin					CursorSetProcessing(false);					err := TrackDrag(dragref, er, dragrgn);				end;				DisposeRgn(dragrgn);			end;			err := DisposeDrag(dragref);		end;	end;	function WObject.SaveChangesID (alert_id: integer): integer;		var			a: integer;			title, ing: Str255;	begin		SelectWindow(window);		GetWTitle(window, title);		if quitNow then begin			ing := GetGlobalStr( GS_Quiting );		end else begin			ing := GetGlobalStr( GS_Closing );		end;		CleverParamText(title, ing, '', '');		a := CleverAlert(alert_id);		SaveChangesID := a;	end;	function WObject.SaveChanges: SCType;	begin		SaveChanges := SCType(SaveChangesID(save_changes_alert_id) - 1);	end;	function WObject.EditMenuEnabled: boolean;	begin		if window = nil then begin			EditMenuEnabled := false;		end else begin			EditMenuEnabled := WindowPeek(window)^.windowKind < 0;		end;	end;	function WObject.SetMenuBar: boolean;		var			oldEditEnabled, editEnabled: boolean;	begin		oldEditEnabled := GetIDItemEnable(M_Edit, 0);		editEnabled := FrontObject.EditMenuEnabled or edit_menu_always_enabled;		if editEnabled <> oldEditEnabled then begin			SetIDItemEnable(M_Edit, 0, editEnabled);		end;		SetMenuBar := editEnabled <> oldEditEnabled;	end;	procedure WObject.SetMenus;	begin		SetFMenus;	end;	procedure WObject.SetEditMenuItem (item: integer);	begin		if not EditMenuEnabled then begin			SetIDItemEnable(M_Edit, item, false);		end;	end;	procedure WObject.DoEditMenu (item: integer);		var			dummyb: boolean;	begin		if item <= 6 then begin			dummyb := SystemEdit(item - 1);		end;	end;	function WObject.GetAESelection (var reply: AppleEvent): OSErr;	begin{$unused(reply)}		GetAESelection := errAENoUserSelection;	end;	function WObject.GetAEWindow (var windowrec: AERecord): OSErr;		var			err, junk: OSErr;			s: Str255;			r: Rect;	begin		AECreate(windowrec);		if is_default_object then begin			err := errAEDescNotFound;		end else begin			err := AECreateList(nil, 0, true, windowrec);			GetWTitle(window, s);			if err = noErr then begin				junk := PutStringToAERecord(windowrec, pName, s);				r := window^.portRect;				SetPort(window);				LocalToGlobal(r.topLeft);				LocalToGlobal(r.botRight);				junk := AEPutParamPtr(windowrec, keyAEBounds, typeQDRectangle, @r, SizeOf(r));				junk := AEPutParamPtr(windowrec, keyAEPosition, typeQDPoint, @r.topLeft, SizeOf(r.topLeft));			end;		end;		GetAEWindow := err;	end;	function WObject.DoMenuKey (const er: EventRecord; ch: char): longint;	begin{$unused(ch)}		DoMenuKey := DoFMenuKey(er);	end;	procedure WObject.CalculateRegion (var rgn: RgnHandle);	begin		CursorSetArrow;		rgn := nil;	end;	function WObject.WaitForEvent (var er: EventRecord; sleep: longint): boolean;		var			rgn: RgnHandle;	begin		rgn := nil;		if (window = nil) | (GetWType(window) = WT_NotMine) | IsWindowShaded(window) then begin			CursorSetArrow;		end else begin			CalculateRegion(rgn);		end;		CursorSetProcessing(false);		WaitForEvent := WaitNextEvent(everyEvent, er, sleep, rgn);		if rgn <> nil then begin			DisposeRgn(rgn);		end;	end;	procedure WObject.DoDiskEvent (message: longint);		var			pt: Point;			oe: OSErr;	begin		if (HiWord(message) <> noErr) then begin			with GetQDGlobals^.screenBits.bounds do begin				pt.h := (right - left - 304) div 2;				pt.v := (bottom - top - 156) div 3;			end;			CursorSetArrow;			CursorSetProcessing(false);			oe := DIBadMount(pt, message);		end;	end;	procedure WObject.DoSuspendResume (resume: boolean);	begin		SetInForeground(resume);		if FrontWindow <> nil then begin			FrontObject.DoActivateDeactivate(resume);		end;		CursorSetArrow;	end;	procedure WObject.DoHighLevel (const er: EventRecord);		var			oe: OSErr;	begin		if has_AppleEvents then begin			oe := AEProcessAppleEvent(er);		end;	end;	procedure WObject.JointCreate (id: integer); { Called for DefaultObject too! }	begin		MoveHHi(Handle(self));		HLock(Handle(self));		popup_title_menu := nil;		AppleGuideWindowType := '';		if window <> nil then begin			SetWRefCon(window, ord4(self));			GetWindowRect(window, unzoomed);		end;		zoomed := false;		close_hides_window := false;		SetRect(growRect, 63, 61, 25000, 25000);		zoomSize.h := 30000;		zoomSize.v := 30000;		window_type := WT_Generic;		draw_grow_icon := false;		window_id := last_window_id;		last_window_id := last_window_id + 1;		resid := id;		is_default_object := false;		onlyone := nil;		timetoclose:=false;	end;	procedure WObject.CreateBehind (id: integer; behind: WindowPtr);		var			wp: myWindowPtr;			junk: OSErr;	begin		junk := MNewPtr( wp, SizeOf(myWindowRecord) );		wp^.magic := OOMagic;		if GetResource( 'wctb', id ) <> nil then begin			window := GetNewCWindow(id, Ptr(wp), behind);		end else begin			window := GetNewWindow(id, Ptr(wp), behind);		end;		JointCreate(id);	end;	procedure WObject.Create (id: integer);	begin		CreateBehind(id, window_at_front);	end;	procedure WObject.Destroy;	begin		if (window <> nil) & (GetWType(window) <> WT_NotMine) then begin			myWindowPtr(window)^.magic := BadOOMagic;			DisposeWindow(window);			if onlyone <> nil then begin				onlyone^ := nil;			end;			dispose(self);		end;	end;{$PUSH}{$ALIGN MAC68K}	type		savedWindowRecord = record				windowpos: Rect; { the window position }				windowvis: Rect; { the visible part of the title bar }				zoomed: boolean;				visible: boolean;			end;		savedWindowPtr = ^savedWindowRecord;		savedWindowHandle = ^savedWindowPtr;		{$ALIGN RESET}{$POP}	procedure WObject.GetWindowPos (h: Handle);		var			rgn: RgnHandle;			r1, r2, global_portrect: Rect;	begin		HUnlock(h);		SetHandleSize(h, SizeOf(savedWindowRecord));		HLock(h);		with savedWindowHandle(h)^^ do begin			SetPort(window);			visible := WindowPeek(window)^.visible;			GetWindowPortRect(window, global_portrect);			LocalToGlobal(global_portrect.topLeft);			LocalToGlobal(global_portrect.botRight);			windowpos := global_portrect;			windowpos.top := windowpos.top - titlebar_hight; { title bar }			rgn := NewRgn;			RectRgn(rgn, windowpos);			SectRgn(GetGrayRgn, rgn, rgn);			windowvis := rgn^^.rgnBBox;			DisposeRgn(rgn);			r1 := global_portrect;			GetWindowStandardState(window, r2);			InsetRect(r1, -7, -7);			zoomed := PtInRect(r2.topLeft, r1) and PtInRect(r2.botRight, r1);		end;		HUnlock(h);	end;	procedure WObject.SetWindowPos (h: Handle; var wasvisible: boolean);		var			rgn: RgnHandle;			r: Rect;			dummy: boolean;	begin		if (h <> nil) & (GetHandleSize(h) = SizeOf(savedWindowRecord)) then begin			HLock(h);			with savedWindowHandle(h)^^ do begin				wasvisible := visible;				rgn := NewRgn;				RectRgn(rgn, windowvis);				SectRgn(GetGrayRgn, rgn, rgn);				r := rgn^^.rgnBBox;				DisposeRgn(rgn);				dummy := SectRect(r, windowvis, r);				if (longint(r.topLeft) = longint(windowvis.topLeft)) & (longint(r.botRight) = longint(windowvis.botRight)) then begin					with windowpos do begin						MoveWindow(window, left, top + titlebar_hight, true);						SizeWindow(window, right - left, bottom - top - titlebar_hight, true);					end;				end;				if zoomed then begin					Zoom(true, false);				end else begin					Resize;				end;			end;			HUnlock(h);		end else			wasvisible := true;	end;	procedure WObject.DoClose;	begin		if close_hides_window then begin			HideWindow(window);		end else begin			Destroy;		end;	end;	procedure WObject.DoContent (const er: EventRecord);	begin{$unused(er)}	end;	procedure WObject.DoKey (const er:EventRecord; ch: char);	begin{$unused(er, ch)}		SysBeep(1);	end;	procedure WObject.DoSpecialKey (const er:EventRecord; ch: char);		var			item: integer;	begin		item := -1;		case EventKeyCode( er ) of			undoKey: 				item := EMundo;			cutKey: 				item := EMcut;			copyKey: 				item := EMcopy;			pasteKey: 				item := EMpaste;			clearKey: 				item := EMclear;			otherwise begin				{ do nothing }			end;		end;		if item <> -1 then begin			SetMenus;			if not GetIDItemEnable(M_Edit, 0) or not GetIDItemEnable(M_Edit, item) then begin				item := -1;			end;		end;		if item = -1 then begin{			if not EventHasCommandKey( er ) then begin}				DoKey(er, ch);{			end;}		end else begin			DoFMenu(M_Edit, item);		end;	end;	procedure WObject.DoAutoKey (const er:EventRecord; ch: char);	begin		DoKey(er, ch);	end;	procedure WObject.DoDrag (where: Point);		var			temprect: Rect;	begin		SetPort(window);		temprect := GetGrayRgn^^.rgnBBox;		DragWindow(window, where, temprect);	end;	procedure WObject.DoGrow (where: Point);		var			mypt: Point;			oldrect: Rect;			mResult: longint;			tempRect: Rect;	begin		SetPort(window);		mypt := where;		GlobalToLocal(mypt);		GetWindowPortRect(window, oldrect);		mResult := GrowWindow(window, where, growRect);		SizeWindow(window, LoWord(mResult), HiWord(mResult), TRUE);		SetRect(tempRect, 0, mypt.v - 15, mypt.h + 15, mypt.v + 15);		EraseRect(tempRect);		InvalRect(tempRect);		SetRect(tempRect, mypt.h - 15, 0, mypt.h + 15, mypt.v + 15);		EraseRect(tempRect);		InvalRect(tempRect);		zoomed := false;		Resize;	end;	procedure WObject.Zoom (zoomout: boolean; fullscreen: boolean);		var			zoompt: Point;	begin		if fullscreen then begin			SetPt(zoompt, 30000, 30000);		end else begin			zoompt := zoomSize;		end;		zoompt.h := Max(zoompt.h, growRect.left);		zoompt.v := Max(zoompt.v, growRect.top);		ZoomTheWindow(window, zoomout, zoompt, unzoomed);		Resize;		zoomed := zoomout;	end;	procedure WObject.DoZoom (where: Point; code: integer);	begin		SetPort(window);		if TrackBox(window, where, code) then begin			Zoom(not zoomed, last_event_had_option);		end;	end;	procedure WObject.InitialZoom (h, v: integer);		var			old: Point;	begin		Resize;		old := zoomSize;		if h <> 0 then begin			zoomSize.h := h;		end;		if v <> 0 then begin			zoomSize.v := v;		end;		Zoom(true, false);		zoomSize := old;		zoomed := false;		GetWindowRect(window, unzoomed);	end;	procedure WObject.DoGoAway (where: Point);	begin		if TrackGoAway(window, where) then begin			DoCloseAll(last_event_had_option);		end;	end;	procedure WObject.DoUpdate;	begin		BeginUpdate(window);		Draw;		EndUpdate(window);	end;	procedure WObject.TextChanged;	begin	end;	procedure WObject.DoMouseMoved (where: Point);	begin{$unused(where)}	end;	procedure WObject.DrawGrow;	begin		DrawGrowIcon(window);	end;	procedure WObject.DoActivateDeactivate (activate: boolean);	begin		Assert(window <> nil);		is_active := activate and WindowPeek(window)^.visible;		if is_active then begin			SelectWindow(window);		end;		if draw_grow_icon then begin			DrawGrow;		end;	end;	procedure WObject.Resize;	begin		if draw_grow_icon then begin			DrawGrow;		end;	end;	procedure WObject.Draw;	begin		if draw_grow_icon then begin			DrawGrow;		end;	end;	function WObject.DoIsDialogEvent (const er: EventRecord): boolean;	begin		if (( er.what = keyDown ) | ( er.what = autoKey )) & ( EventKeyCode( er ) in [undoKey, cutKey, copyKey, pasteKey, clearKey] ) then begin			DoIsDialogEvent := false;		end else begin			DoIsDialogEvent := IsDialogEvent(er);		end;	end;	function WObject.DoDialogSelect (const er: EventRecord; var dlg: DialogPtr; var item: integer): boolean;	begin		DoDialogSelect := DialogSelect(er, dlg, item);	end;	procedure WObject.DoIdle;	begin	end;		procedure WObject.DoIdleAlways;	begin	end;	procedure WObject.DoPopupTitle (choice: integer);	begin{$unused(choice)}	end;	function WObject.CheckPopupTitle (where: Point): boolean;		var			result: longint;			center, width: integer;			saved: SavedWindowInfo;			title: Str255;			base: Point;	begin		CheckPopupTitle := false;		if popup_title_menu <> nil then begin			EnterWindow(window, MFT_System0, [], saved);			GlobalToLocal(where);			GetWTitle(window, title);			center := (window^.portRect.right + window^.portRect.left) div 2;			width := StringWidth(title);			base.h := center - width div 2 - 14;			base.v := -17;			if (where.v < 0) & (base.h <= where.h) & (where.h <= center + width div 2 + 5) then begin				CheckPopupTitle := true;				InsertMenu(popup_title_menu, -1);				LocalToGlobal(base);				CheckItem(popup_title_menu, 1, true);				result := PopUpMenuSelect(popup_title_menu, base.v, base.h, 1);				CheckItem(popup_title_menu, 1, false);				DeleteMenu(popup_title_menu^^.menuID);				if (HiWord(result) <> 0) and (LoWord(result) <> 1) then begin					DoPopupTitle(LoWord(result));{DrawPopUp(dialog, item);}				end;			end;			ExitWindow(saved);		end;	end;	function WObject.DoMainClick (const er: EventRecord; wp: WindowPtr; code: integer): boolean;		var			b: boolean;			mResult: longint;			needsselect: boolean;	begin		b := false;		needsselect := (wp <> nil) & (wp <> FrontWindow);		if needsselect & not (code in [inDrag, inContent]) then begin			SelectWindow(wp);		end;		case code of			inMenuBar:  begin				SetMenus;				mResult := MenuSelect(er.where);				if mResult <> 0 then begin					DoFMenu(HiWord(mResult), LoWord(mResult));				end;				if not quitNow then begin					HiliteMenu(0);				end;			end;			inDrag:  begin				if needsselect | not last_event_had_command | not CheckPopupTitle(er.where) then begin					if needsselect and not last_event_had_command then begin						SelectWindow(wp);					end;					DoDrag(er.where);				end;			end;			inGrow: 				DoGrow(er.where);			inZoomIn, inZoomOut: 				DoZoom(er.where, code);			inGoAway: 				DoGoAway(er.where);			inContent:  begin				if needsselect then begin					SelectWindow(wp);				end;				DoContent(er);			end;			inSysWindow: 				SystemClick(er, window);			otherwise begin				b := true;			end;		end;		DoMainClick := b;	end;	function WObject.HandleSimpleEvents (var er: EventRecord): boolean;		var			b: boolean;			ch: char;			mResult: longint;			code: integer;			wp: WindowPtr;	begin		b := false;		case er.what of			mouseDown:  begin				code := FindWindow(er.where, wp);				if wp = nil then begin					wp := FrontWindow;				end;				b := GetWObject(wp).DoMainClick(er, wp, code);			end;			keyDown:  begin				ch := EventChar( er );				mResult := 0;				if last_event_had_command then begin					SetMenus;					mResult := DoMenuKey(er, ch);				end;				if mResult <> 0 then begin					DoFMenu(HiWord(mResult), LoWord(mResult));				end else begin					DoSpecialKey(er, ch);				end;			end;			autoKey: 				DoAutoKey(er, EventChar( er ) );			updateEvt: 				GetWObject(WindowPtr(er.message)).DoUpdate;			activateEvt: 				GetWObject(WindowPtr(er.message)).DoActivateDeactivate( EventHasActivate( er ) );			kOSEvent: 				if EventIsSuspendResume( er ) then begin					DoSuspendResume( EventHasResume( er ) );				end else if EventIsMouseMoved( er ) then begin					DoMouseMoved(er.where);				end else begin					b := true;				end;			kHighLevelEvent: 				DoHighLevel(er);			diskEvt: 				DoDiskEvent(er.message);			otherwise begin				b := true;			end;		end;		HandleSimpleEvents := b;	end;	function WObject.HandleEvents (var er: EventRecord): boolean;		var			b: boolean;			dlg: DialogPtr;			item: integer;			dlgsel:boolean;	begin		last_event := er;		last_event_time := er.when;		last_event_had_option := EventHasOptionKey( er );		last_event_had_command := EventHasCommandKey( er );		last_event_had_shift := EventHasShiftKey( er );		last_event_had_control := EventHasControlKey( er );		DoIdle;		b := true;		if DoIsDialogEvent(er) then begin			dlgsel:=DoDialogSelect(er, dlg, item);			if dlgsel then begin				GetDObject(dlg).DoItemWhere(er, item);				b := false;			end;		end;		if b then begin			b := HandleSimpleEvents(er);		end;		HandleEvents := b;	end;	procedure DObject.CreateBehind (id: integer; behind: WindowPtr);		var			wp: myDialogPtr;			junk: OSErr;	begin		disable_edit_menu := false;		junk := MNewPtr( wp, SizeOf(myDialogRecord) );		wp^.magic := OOMagic;		window := GetNewDialog(id, Ptr(wp), behind);		ok_item := 0;		cancel_item := 0;		outline_item := 0;		handle_shift_tab := true;		text_return := false;		support_edittext_draging_send := true;		support_edittext_draging_receive := true;		JointCreate(id);	end;	procedure DObject.Create (id: integer);	begin		CreateBehind(id, window_at_front);	end;	procedure DObject.Destroy;	begin		if (window <> nil) & (GetWType(window) <> WT_NotMine) then begin			myDialogPtr(window)^.magic := BadOOMagic;			DisposeDialog(window);			if onlyone <> nil then begin				onlyone^ := nil;			end;			dispose(self);		end;	end;	procedure DObject.DrawOutline;	begin		OutlineDefault1( window, outline_item );	end;	procedure DObject.SetOOOutline (def_item, user_item: integer);	begin		ok_item := def_item;		outline_item := user_item;		SetUpDefaultOutline(window,ok_item, outline_item, false);		HandleUserItem( outline_item );	end;	procedure DObject.DrawUserItem( item: integer );	begin{$unused(item)}		if (outline_item > 0) & (item = outline_item) then begin			DrawOutline;		end else begin			Assert( false );		end;	end;	procedure DrawUserItem( window: DialogPtr; item: integer );	begin		GetDObject( window ).DrawUserItem( item );	end;		procedure DObject.HandleUserItem( item: integer );	begin		SetUserItemProc( window, item, dDrawUserItemProc );	end;		procedure DObject.HandleAllUserItems;		var			item: integer;			kind: integer;	begin		for item := 1 to CountDItems( window ) do begin			GetDItemKind( window, item, kind );			if band(kind,bnot(itemDisable)) = userItem then begin				HandleUserItem( item );			end;		end;	end;					procedure DObject.DoActivateDeactivate (activate: boolean);	begin		inherited DoActivateDeactivate(activate);		if outline_item > 0 then begin			DrawOutline;		end;	end;	procedure DObject.DoOK (const er: EventRecord; ch: char);	begin		if ok_item = 0 then begin			DoKey(er, ch);		end else begin			if GetDCtlEnable(window, ok_item) then begin				FlashDItem(window, ok_item);				DoItem(ok_item);			end;		end;	end;	procedure DObject.DoCancel (const er: EventRecord; ch: char);	begin		if cancel_item = 0 then begin			DoKey(er, ch);		end else begin			FlashDItem(window, cancel_item);			DoItem(cancel_item);		end;	end;	procedure DObject.DoItem (item: integer);	begin{$unused(item)}	end;	procedure DObject.DoItemWhere (const er: EventRecord; item: integer);	begin{$unused(er)}		DoItem(item);	end;	function DObject.HandleEvents (var er: EventRecord): boolean;		var			b: boolean;			ch: char;	begin		b := true;		if EventIsKeyDown( er ) then begin			b := false;			ch := EventChar( er );			if ((ch <> cr) | not text_return) & EventHasOK( er ) then begin				DoOK(er, ch);			end else if EventHasCancel( er ) then begin				DoCancel(er, ch);			end else if (ch = tab) and EventHasShiftKey( er ) then begin				if handle_shift_tab then begin					ShiftTab(window);				end else begin					b := true;				end;			end else begin				b := true;			end;		end;		if b then begin			b := inherited HandleEvents(er);		end;		HandleEvents := b;	end;	procedure DObject.SetEditMenuItem (item: integer);	begin		if is_default_object | disable_edit_menu | (SelectedTextItem(window) <= 0) then begin			SetIDItemEnable(M_Edit, item, false);		end else begin			TESetEditMenuItem(DialogPeek(window)^.textH, false, 250, item);		end;	end;	function DObject.EditMenuEnabled: boolean;	begin		if is_default_object | disable_edit_menu | (SelectedTextItem(window) <= 0) then begin			EditMenuEnabled := false;		end else begin			EditMenuEnabled := TEEditMenuEnabled(DialogPeek(window)^.textH, false, 250);		end;	end;	procedure DObject.DoDialogCut;	begin		DialogCut( window );	end;		procedure DObject.DoDialogCopy;	begin		DialogCopy( window );	end;		procedure DObject.DoDialogPaste;	begin		DialogPaste( window );	end;		procedure DObject.DoDialogDelete;	begin		DialogDelete( window );	end;		procedure DObject.DoEditMenu (item: integer);		var			loe: longint;			oe: OSErr;	begin		case item of			EMundo: 				;			EMcut:  begin				DoDialogCut;				loe := ZeroScrap;				oe := TEToScrap;				TextChanged;			end;			EMcopy:  begin				DoDialogCopy;				loe := ZeroScrap;				oe := TEToScrap;			end;			EMpaste:  begin				oe := TEFromScrap;				DoDialogPaste;				TextChanged;			end;			EMclear:  begin				DoDialogDelete;				TextChanged;			end;			EMselectall:  begin				if (SelectedTextItem(window) > 0) then begin					SelectDialogItemText(window, SelectedTextItem(window), 0, maxInt);				end;			end;			otherwise begin				{ do nothing }			end;		end;	end;	function DObject.GetAESelection (var reply: AppleEvent): OSErr;		var			err: OSErr;	begin		if not is_default_object & (SelectedTextItem(window) > 0) then begin			err := PutTESelectionToAERecord(reply, keyDirectObject, DialogPeek(window)^.textH);		end else begin			err := errAENoUserSelection;		end;		GetAESelection := err;	end;	function DObject.DoIsDialogEvent (const er: EventRecord): boolean;		var			wp: WindowPtr;			doit: Boolean;			curitem, clickitem: integer;			localwhere: Point;			wasdragged, wastrashed: Boolean;	begin		doit := true;		if EventIsKeyDown( er ) and EventHasCommandKey( er ) then begin			doit := false; { Stop system 7 from doing the edit menu as well }		end;		if doit & support_edittext_draging_send & (er.what=mouseDown) & (FindWindow(er.where, wp) = inContent) & (wp = window) then begin			curitem := SelectedTextItem( window );			if curitem > 0 then begin				SetPort( window );				localwhere := er.where;				GlobalToLocal( localwhere );				clickitem := FindDialogItem( window, localwhere ) + 1; { GlobalToLocal? }				if (clickitem = curitem) & PtInTEHiliteRgn( localwhere, DialogPeek(window)^.textH ) then begin					if (DragText( er, localwhere, DialogPeek(window)^.textH, false, wasdragged, wastrashed ) = noErr) & wasdragged then begin						if wastrashed then begin							DoDialogDelete;						end;						doit := false;					end;				end;			end;		end;		if doit then begin			doit := inherited DoIsDialogEvent(er);		end;		DoIsDialogEvent := doit;	end;	var		drop_on_field_index: integer;		drop_on_field_location: integer;		function DObject.MyTrackingEnterWindow( dragref: DragReference ): Boolean;	begin		if support_edittext_draging_receive then begin			MyTrackingEnterWindow := IsDragTypeAvailable( dragref, 'TEXT' );		end else begin			MyTrackingEnterWindow := false;		end;	end;		procedure DObject.MyTrackingLeaveWindow( dragref: DragReference );	begin{$unused(dragref)}	end;	procedure DObject.MyTrackingInWindow( dragref: DragReference; localwhere: Point; var new_drag_hilited: Boolean; new_drag_hilite_rgn, new_drag_invert_rgn: RgnHandle );		var			item, start, fin: integer;			cur_modifiers, mousedown_modifiers, mouseup_modifiers: integer;			attributes: DragAttributes;			docopy: boolean;			junk: OSStatus;	begin{$unused(dragref)}		DialogGetTextDropInformation( window, localwhere, drop_on_field_index, drop_on_field_location, new_drag_hilite_rgn, new_drag_invert_rgn );		new_drag_hilited := drop_on_field_index > 0;		if new_drag_hilited then begin			GetDialogTextSelection( window, item, start, fin );			if drop_on_field_index = item then begin				junk := GetDragAttributes( dragref, attributes );				junk := GetDragModifiers( dragref, cur_modifiers, mousedown_modifiers, mouseup_modifiers );				docopy := (band(attributes, dragInsideSenderWindow) = 0) | (band(bor(mousedown_modifiers, cur_modifiers), optionKey) <> 0);				if docopy then begin					if (start < drop_on_field_location) & (drop_on_field_location < fin) then begin												new_drag_hilited := false;					end;				end else begin					if (start <= drop_on_field_location) & (drop_on_field_location <= fin) then begin												new_drag_hilited := false;					end;				end;			end;		end;	end;		procedure DObject.InsertTextAndSelect( field: integer; offset: integer; data: Str255 );		var			field_contents: Str255;	begin		GetItemText( window, field, field_contents );		if length( field_contents ) + length( data ) > 255 then begin			data := copy( data, 1, 255-length( field_contents ) );		end;		MidAssignP( field_contents, offset + 1, 0, data );		SetItemText( window, field, field_contents );		SelectDialogItemText( window, field, offset, offset + length(data) );	end;		function DObject.ReceiveHandler(dragref: DragReference): OSErr;		var			err, junk: OSErr;			drag_contents: Str255;			docopy: Boolean;			attributes: DragAttributes;			in_sender_window: Boolean;			cur_modifiers, mousedown_modifiers, mouseup_modifiers: integer;			dragdata: Handle;			selStart, selEnd: integer;	begin		TrackingRemoveHiliting( dragref );		if drop_on_field_index > 0 then begin			junk := GetDragAttributes(dragref, attributes);			junk := GetDragModifiers(dragref, cur_modifiers, mousedown_modifiers, mouseup_modifiers );			in_sender_window := (band(attributes, dragInsideSenderWindow) <> 0);			docopy := not in_sender_window | (band(bor(mousedown_modifiers, mouseup_modifiers), optionKey) <> 0);{			drop_on_field_finish := drop_on_field_location;}						junk := MNewHandle( dragdata, 0 );			err := GetTextDragData( dragref, dragdata );			if err = noErr then begin				HandleToString( dragdata, drag_contents );				if docopy then begin					InsertTextAndSelect( drop_on_field_index, drop_on_field_location, drag_contents );				end else if SelectedTextItem( window ) <> drop_on_field_index then begin					DoDialogDelete;					InsertTextAndSelect( drop_on_field_index, drop_on_field_location, drag_contents );				end else begin					GetDialogTextSelection( window, drop_on_field_index, selStart, selEnd );					DoDialogDelete;					if (selStart <= drop_on_field_location) & (drop_on_field_location <= selEnd) then begin						{ should never happen except on edge of boundary }						drop_on_field_location := selStart;					end else if drop_on_field_location > selEnd then begin						drop_on_field_location := drop_on_field_location - (selEnd-selStart);					end;					InsertTextAndSelect( drop_on_field_index, drop_on_field_location, drag_contents );				end;			end;			MDisposeHandle( dragdata );		end;		ReceiveHandler := err;	end;	procedure DObject.CalculateRegion (var rgn: RgnHandle);		var			item,k:integer;			pt:Point;	begin		rgn := nil;		item:=0;				if (window<>nil) then begin			SetPort(window);			GetMouse(pt);			item:=FindDialogItem(window,pt)+1;			if item>0 then begin				GetDItemKind(window,item,k);				if k<>editText then begin					item:=0;				end;			end;		end;		if item>0 then begin			CursorSetIBeam;		end else begin			CursorSetArrow;		end;	end;	function HasDragLib:boolean;	begin{$IFC GENERATINGPOWERPC}		HasDragLib := longint(@InstallTrackingHandler) <> kUnresolvedCFragSymbolAddress;{$ELSEC}		HasDragLib := true;{$ENDC}	end;	procedure IdleMainLoop;		var			fw,next: WindowPtr;			obj: WObject;	begin		fw:=FrontWindowList;		while fw<>nil do begin			next := NextWindowList ( fw );			obj := GetWObject(fw);			if obj.timetoclose then begin				obj.DoClose;			end else begin				obj.DoIdleAlways;			end;			fw:=next;		end;	end;		function InitMainLoop(var msg: integer): OSStatus;		var			i: integer;			dummy: boolean;			dummy_er: EventRecord;			junk: OSErr;			err: OSErr;			HandleCloseProc:UniversalProcPtr;			gv: longint;	begin{$unused(msg)}		has_DragManager := HasDragLib & (Gestalt(gestaltDragMgrAttr, gv) = noErr) & (BTST(gv, gestaltDragMgrPresent));		gMyDragSendProc := NewDragSendDataProc(MyDragSend);		dDrawUserItemProc := NewUserItemProc(DrawUserItem);		for i := 1 to 5 do begin			dummy := EventAvail(everyEvent, dummy_er);		end;		if has_DragManager then begin			err := InstallTrackingHandler(NewDragTrackingHandlerProc(MyTrackingHandler), nil, nil);			err := InstallReceiveHandler(NewDragReceiveHandlerProc(MyReceiveHandler), nil, nil);		end;		default_object.window := nil;		default_object.window_id := bad_window_id;		default_object.JointCreate(0);		default_object.is_default_object := true;		default_object.window_type := WT_NotMine;		last_window_id := 1;		edit_menu_always_enabled := false;		if has_AppleEvents then begin			HandleCloseProc:=NewAEEventHandlerProc(HandleClose);			junk := AEInstallEventHandler(kAECoreSuite, kAEClose,HandleCloseProc , 0, false);			junk := AEInstallEventHandler(kAECoreSuite, kAECloseAll,HandleCloseProc , 1, false);		end;		InitMainLoop := noErr;	end;	procedure FinishMainLoop;	begin		dispose(default_object);	end;	procedure ConfigureMainLoop (dobj: DObject);	begin		StartupMainLoop;		default_object := dobj;	end;		procedure StartupMainLoop;	begin		StartupCleverAlerts;		StartupCursors;		StartupDialogs;		StartupFMenus;		SetStartup(InitMainLoop, IdleMainLoop, 15, FinishMainLoop);	end;	end.