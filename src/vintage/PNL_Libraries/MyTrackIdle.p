unit MyTrackIdle;interface	uses		Types;			function IdleSince: longint;  {TickCount at last no idle time}	procedure StartupTrackIdle;implementation	uses		Events,		MyStartup;			type		keyLongMap = array[1..4] of longint;	var		lastmoved: longint;  { Last time the cursor was moved, used for idle timing }		lastpos: Point;		lastkeymap: keyLongMap;	function IdleSince: longint;  {TickCount at last no idle time}	begin		IdleSince := lastmoved;	end;	procedure MyGetMouse (var pt: Point); { Handles not having quickdraw around }		var			event:EventRecord;			dummy:boolean;	begin		dummy:=OSEventAvail(0,event);		pt := event.where;	end;	procedure TrackIdle;		var			pt: Point;			km: keyLongMap;	begin		pt := lastpos;		MyGetMouse(lastpos);		if (abs(pt.h - lastpos.h) > 2) or (abs(pt.v - lastpos.v) > 2) then begin			lastmoved := TickCount;		end		else begin			GetKeys(keyMap(km));			if (km[1] <> lastkeymap[1]) or (km[2] <> lastkeymap[2]) or (km[3] <> lastkeymap[3]) or (km[4] <> lastkeymap[4]) then begin				lastmoved := TickCount;				lastkeymap := km;			end;		end;	end;	function InitTrackIdle( var msg: integer ): OSStatus;	begin{$unused(msg)}		MyGetMouse(lastpos);		lastmoved := TickCount;		GetKeys(keyMap(lastkeymap));		InitTrackIdle := noErr;	end;	procedure StartupTrackIdle;	begin		SetStartup( InitTrackIdle, TrackIdle, 0, nil );	end;end.