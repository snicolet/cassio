unit MyThreads;interface	uses		Types, Threads;	var		active_threads: integer; { YOU MUST DECREMENT active_threads }		threads_must_die:Boolean;		has_ThreadManager: boolean;	procedure StartupThreads;	procedure FinishMyThreads;{ waits for all threads to complete - ie active_threads=0 }	function MyNewThread (proc: ThreadEntryProcPtr; threadParam: univ Ptr; stack: longint):OSErr; { increments active_thread }	procedure MyThreadDied; { call when your thread dies to decrement active_threads }	procedure MyYield;implementation	uses		Events, GestaltEqu, CodeFragments,		MyAssertions, MySystemGlobals, MyStartup, MyUtils;	const		our_thread_stack = 12288;		our_thread_options = kCreateIfNeeded + kUsePremadeThread + kFPUNotNeeded;	procedure MyThreadDied;	begin		Dec(active_threads);	end;		function MyNewThread (proc: ThreadEntryProcPtr; threadParam: univ Ptr; stack: longint):OSErr;		var			err:OSErr;			thread: ThreadID;	begin		if stack = 0 then begin			stack := our_thread_stack;		end;		if not has_ThreadManager then begin			err := -1;		end else begin			err := NewThread(kCooperativeThread, proc, threadParam, stack, our_thread_options, nil, thread);		end;		if err = noErr then begin			active_threads := active_threads + 1;		end;		MyNewThread := err;	end;	procedure MyYield;	begin		if has_ThreadManager then begin			Assert(YieldToAnyThread = noErr);		end;	end;	function HasThreadLib: boolean;	begin{$IFC GENERATINGPOWERPC}		HasThreadLib := longint(@NewThread) <> kUnresolvedCFragSymbolAddress;{$ELSEC}		HasThreadLib := true;{$ENDC}	end;	function InitThread(var msg: integer): OSStatus;		var			gv: longint;	begin{$unused(msg)}		active_threads := 0;		has_ThreadManager := (Gestalt(gestaltThreadMgrAttr, gv) = noErr) and (btst(gv, gestaltThreadMgrPresent)) and HasThreadLib;		InitThread := noErr;	end;		procedure FinishMyThreads;{ waits for all threads to complete - ie active_threads=0 }		var			er: EventRecord;			dummy: boolean;	begin		threads_must_die := true;		while active_threads > 0 do begin			dummy := WaitNextEvent(everyEvent, er, 0, nil);			MyYield;		end;	end;	procedure StartupThreads;	begin		SetStartup(InitThread, nil, 0, FinishMyThreads);	end;	end.