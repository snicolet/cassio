UNIT UnitJanEndgameData;INTERFACE{$PRAGMAC align_array_members on }{$PRAGMAC align power }{$PRAGMAC options align= power }{$PRAGMAC function_align 16}{$ALIGN PowerPC}{$SETC USING_JAN_ENDGAME := FALSE}USES UnitUtilitairesFinale;const  _BLACK_ = 0;  _WHITE_ = 1;const  _NUMBER_OF_DIRECTIONS_ = 4;  _VERT_  = 0;    (* verticaly                *)  _HORI_  = 1;    (* horizontaly              *)  _DIAG_  = 2;    (* diagonaly,      eg a1-h8 *)  _ANTI_  = 3;    (* anti-diagonaly, eg h1-a8 *)const  _NO_   = 0;  _YES_  = 1;const   _NUMBER_OF_FLIPPING_MASKS_  = 41;   _00000000_  =  0;     (* 0 disc flipped *)   _01000000_  =  1;     (* 1 disc flipped *)   _00100000_  =  2;   _00010000_  =  3;   _00001000_  =  4;   _00000100_  =  5;   _00000010_  =  6;   _01100000_  =  7;    (* 2 discs flipped *)   _00110000_  =  8;   _00011000_  =  9;   _00001100_  =  10;   _00000110_  =  11;   _01110000_  =  12;    (* 3 discs flipped *)   _00111000_  =  13;   _00011100_  =  14;   _00001110_  =  15;   _01111000_  =  16;    (* 4 discs flipped *)   _00111100_  =  17;   _00011110_  =  18;   _01111100_  =  19;    (* 5 discs flipped *)   _00111110_  =  20;   _01111110_  =  21;    (* 6 discs flipped *)   _01010000_  =  22;    (* 2 discs flipped, play in the hole *)   _00101000_  =  23;   _00010100_  =  24;   _00001010_  =  25;   _01011000_  =  26;    (* 3 discs flipped, play in the hole *)   _00101100_  =  27;   _00010110_  =  28;   _01101000_  =  29;   _00110100_  =  30;   _00011010_  =  31;   _01011100_  =  32;    (* 4 discs flipped, play in the hole *)   _00101110_  =  33;   _01101100_  =  34;   _00110110_  =  35;   _01110100_  =  36;   _00111010_  =  37;   _01011110_  =  38;    (* 5 discs flipped, play in the hole *)   _01101110_  =  39;   _01110110_  =  40;   _01111010_  =  41;const  _NUMBER_OF_LINES_  =  38;  _a1_h1_  =   1;  _a1_a8_  =   2;  _a1_h8_  =   3;  _b1_h7_  =   4;  _b1_b8_  =   5;  _c1_a3_  =   6;  _c1_h6_  =   7;  _c1_c8_  =   8;  _d1_a4_  =   9;  _d1_h5_  =   10;  _d1_d8_  =   11;  _e1_h4_  =   12;  _e1_a5_  =   13;  _e1_e8_  =   14;  _f1_h3_  =   15;  _f1_a6_  =   16;  _f1_f8_  =   17;  _g1_a7_  =   18;  _g1_g8_  =   19;  _h1_a8_  =   20;  _h1_h8_  =   21;  _a2_h2_  =   22;  _a2_g8_  =   23;  _h2_b8_  =   24;  _a3_h3_  =   25;  _a3_f8_  =   26;  _h3_c8_  =   27;  _a4_h4_  =   28;  _a4_e8_  =   29;  _h4_d8_  =   30;  _a5_h5_  =   31;  _a5_d8_  =   32;  _h5_e8_  =   33;  _a6_h6_  =   34;  _a6_c8_  =   35;  _h6_f8_  =   36;  _a7_h7_  =   37;  _a8_h8_  =   38;(* pointeurs pour gerer la pile des actions *)type md_t_rec = record                  actions             : longint;                  previous_turn       : longint;                  previous_stns_ahead : longint;                end;     md_t_ptr = ^md_t_rec;const size_of_md_t_rec = 12;  {attention : changer cela si le type md_t_rec change !!! }type  action_rec = record                     line_address        : ^longint;                     previous_line_value : longint;                   end;      action_ptr = ^action_rec;const size_of_action_rec = sizeof(action_rec);type  JanIntegerType = longint;  JanFlipCodeType = longint;  JanGainType = longint;  JanDataRecPtr = ^JanDataRec;  funct_longint_type = function(JanData:JanDataRecPtr):longint;  procedure_type = procedure(JanData:JanDataRecPtr);  JanDataRec =    record      turn : JanIntegerType;	    stns_ahead : JanIntegerType;	    nodes : JanIntegerType;	    gain : JanIntegerType;	    actions : JanIntegerType;	    JanEndgameDepth:JanIntegerType;	    a1_h1 : JanIntegerType;	    a1_a8 : JanIntegerType;	    a1_h8 : JanIntegerType;	    b1_h7 : JanIntegerType;	    b1_b8 : JanIntegerType;	    c1_a3 : JanIntegerType;	    c1_h6 : JanIntegerType;	    c1_c8 : JanIntegerType;	    d1_a4 : JanIntegerType;	    d1_h5 : JanIntegerType;	    d1_d8 : JanIntegerType;	    e1_h4 : JanIntegerType;	    e1_a5 : JanIntegerType;	    e1_e8 : JanIntegerType;	    f1_h3 : JanIntegerType;	    f1_a6 : JanIntegerType;	    f1_f8 : JanIntegerType;	    g1_a7 : JanIntegerType;	    g1_g8 : JanIntegerType;	    h1_a8 : JanIntegerType;	    h1_h8 : JanIntegerType;	    a2_h2 : JanIntegerType;	    a2_g8 : JanIntegerType;	    h2_b8 : JanIntegerType;	    a3_h3 : JanIntegerType;	    a3_f8 : JanIntegerType;	    h3_c8 : JanIntegerType;	    a4_h4 : JanIntegerType;	    a4_e8 : JanIntegerType;	    h4_d8 : JanIntegerType;	    a5_h5 : JanIntegerType;	    a5_d8 : JanIntegerType;	    h5_e8 : JanIntegerType;	    a6_h6 : JanIntegerType;	    a6_c8 : JanIntegerType;	    h6_f8 : JanIntegerType;	    a7_h7 : JanIntegerType;	    a8_h8 : JanIntegerType;		    md_ptr : md_t_ptr;		  buffer_md_ptr : array[0..64] of md_t_rec;		  action_stack_ptr : action_ptr;		  buffer_actions : array[0..1200] of action_rec;		  move_if_possible : array[0..99, _BLACK_ .. _WHITE_] of funct_longint_type;		  end_eval_1_ply   : array[0..99, _BLACK_ .. _WHITE_] of funct_longint_type;		  flip             : array[0..63, _VERT_ .. _ANTI_,0.._NUMBER_OF_FLIPPING_MASKS_,0..1] of procedure_type;      flipcode         : array[0..6560,0..7,0..1] of JanFlipCodeType;		  flips_1ply_white : packed array[0..6560] of JanGainType;		  flips_1ply_black : packed array[0..6560] of JanGainType;		  gain_1ply        : packed array[0..24,0..1] of JanGainType;				end;{$IFC USING_JAN_ENDGAME }		var JanGlobalData : JanDataRec;{$ENDC}var  powers3 : array[0..7] of longint;  directions : array[0 .. (_NUMBER_OF_DIRECTIONS_ - 1) ] of                 record                   theString : string255;                   dx : longint;                 end;  colors : array[0..1] of                 record                   theString : string255;                   theStringForFunctionNames : string255;                   opposite : longint;                 end;  masks : array[0 .. _NUMBER_OF_FLIPPING_MASKS_] of            record              theString               : string255;              maskLength              : longint;              firstFlippedFirstGroup  : longint;              lastFlippedFirstGroup   : longint;              firstFlippedSecondGroup : longint;              lastFlippedSecondGroup  : longint;              numberOfFlipped         : longint;              flippedDiscs            : set of 0..50; (* set of 0..7; ferait un seul octet => BUG in CodeWarrior ! *)              possibleMoves           : set of 0..50; (* set of 0..7; ferait un seul octet => BUG in CodeWarrior ! *)              sumOfPowersOfFlipped    : longint;            end;  lines : array[1 .. _NUMBER_OF_LINES_] of            record              direction : longint;              firstSquare : longint;              lastSquare : longint;              length : longint;              valueOfEmptyLine : longint;              squares : array[0..7] of longint;              CassioSquares : array[0..7] of longint;              theString : string255;              squareSet : set of 0..63;            end;   JanBoard : array [0..63] of                record                  nbOfLines:longint;                  linesSet : set of 1..38;                  linesNumbers : array[1..4] of longint;                  whichSquareInLine : array[1..4] of longint;                end;   JanFlipCodeAuxiliaryArray : array[0..7,0..6,0..6] of longint;(*************** initialisations ********************************)procedure InitUnitJanEndgameData;procedure PlatOthEndgameToJanData(var plat:plOthEndgame;couleur:longint);procedure PositionEtTraitToJanData(positionEtTrait:PositionEtTraitRec);function JanDataToPositionEtTrait:PositionEtTraitRec;procedure WritelnStringAndJanDataDansRapport(s:string);procedure reset_ptrs_for_jan_endgame;(************** les fonctions pour jouer les coups **************)(************** sont dans JanGlobalData.moveIfPossible  *********)(************** la fonction pour dejouer les coups **************)procedure undo_last_move(JanData:JanDataRecPtr);(**************************** materiel interne ******************)IMPLEMENTATION{$PRAGMAC align_array_members on }{$PRAGMAC align power }{$PRAGMAC options align= power }{$PRAGMAC function_align 16}{$ALIGN PowerPC}var   {pointeurs sur les 38 variables globales decrivant l'othellier a la Jan}   QuelleLigneDeJan : array[1 .. _NUMBER_OF_LINES_ ] of ^longint;procedure InitUnitJanEndgameData;begin{$IFC USING_JAN_ENDGAME }  with JanGlobalData do    begin		  QuelleLigneDeJan[_a1_h1_] := @a1_h1   ;		  QuelleLigneDeJan[_a1_a8_] := @a1_a8   ;		  QuelleLigneDeJan[_a1_h8_] := @a1_h8   ;		  QuelleLigneDeJan[_b1_h7_] := @b1_h7   ;		  QuelleLigneDeJan[_b1_b8_] := @b1_b8   ;		  QuelleLigneDeJan[_c1_a3_] := @c1_a3   ;		  QuelleLigneDeJan[_c1_h6_] := @c1_h6   ;		  QuelleLigneDeJan[_c1_c8_] := @c1_c8   ;		  QuelleLigneDeJan[_d1_a4_] := @d1_a4   ;		  QuelleLigneDeJan[_d1_h5_] := @d1_h5   ;		  QuelleLigneDeJan[_d1_d8_] := @d1_d8   ;		  QuelleLigneDeJan[_e1_h4_] := @e1_h4   ;		  QuelleLigneDeJan[_e1_a5_] := @e1_a5   ;		  QuelleLigneDeJan[_e1_e8_] := @e1_e8   ;		  QuelleLigneDeJan[_f1_h3_] := @f1_h3   ;		  QuelleLigneDeJan[_f1_a6_] := @f1_a6   ;		  QuelleLigneDeJan[_f1_f8_] := @f1_f8   ;		  QuelleLigneDeJan[_g1_a7_] := @g1_a7   ;		  QuelleLigneDeJan[_g1_g8_] := @g1_g8   ;		  QuelleLigneDeJan[_h1_a8_] := @h1_a8   ;		  QuelleLigneDeJan[_h1_h8_] := @h1_h8   ;		  QuelleLigneDeJan[_a2_h2_] := @a2_h2   ;		  QuelleLigneDeJan[_a2_g8_] := @a2_g8   ;		  QuelleLigneDeJan[_h2_b8_] := @h2_b8   ;		  QuelleLigneDeJan[_a3_h3_] := @a3_h3   ;		  QuelleLigneDeJan[_a3_f8_] := @a3_f8   ;		  QuelleLigneDeJan[_h3_c8_] := @h3_c8   ;		  QuelleLigneDeJan[_a4_h4_] := @a4_h4   ;		  QuelleLigneDeJan[_a4_e8_] := @a4_e8   ;		  QuelleLigneDeJan[_h4_d8_] := @h4_d8   ;		  QuelleLigneDeJan[_a5_h5_] := @a5_h5   ;		  QuelleLigneDeJan[_a5_d8_] := @a5_d8   ;		  QuelleLigneDeJan[_h5_e8_] := @h5_e8   ;		  QuelleLigneDeJan[_a6_h6_] := @a6_h6   ;		  QuelleLigneDeJan[_a6_c8_] := @a6_c8   ;		  QuelleLigneDeJan[_h6_f8_] := @h6_f8   ;		  QuelleLigneDeJan[_a7_h7_] := @a7_h7   ;		  QuelleLigneDeJan[_a8_h8_] := @a8_h8   ;    end;  {$ENDC}end;procedure PlatOthEndgameToJanData(var plat:plOthEndgame;couleur:longint);var k,i,value:longint;begin {$UNUSED plat,couleur,k,i,value}{$IFC USING_JAN_ENDGAME }  with JanGlobalData do    begin		  if couleur = pionNoir		    then turn := _BLACK_		    else turn := _WHITE_;		  for k := 1 to _NUMBER_OF_LINES_ do		    with lines[k] do		    begin		      value := valueOfEmptyLine;		      for i := 0 to length-1 do		        case plat[CassioSquares[i]] of		          pionNoir  : value := value - powers3[i];		          pionBlanc : value := value + powers3[i];		        end; {case}		      QuelleLigneDeJan[k]^ := value;		    end;		end;{$ENDC}end;procedure PositionEtTraitToJanData(positionEtTrait:PositionEtTraitRec);begin  PlatOthEndgameToJanData(positionEtTrait.position,positionEtTrait.trait);end;function JanDataToPositionEtTrait:positionEtTraitRec;var result : positionEtTraitRec;  procedure DecomposerRangee(valeurTernaire:longint;premiereCase:longint);  var m,k,p:longint;  begin    m := valeurTernaire;    for k := 7 downto 0 do      begin        p := powers3[k];        result.position[premiereCase+k] := pionNoir;        if m >= p then          begin            m := m - p;            result.position[premiereCase+k] := pionVide;          end;        if m >= p then          begin            m := m - p;            result.position[premiereCase+k] := pionBlanc;          end;      end;  end;begin{$IFC USING_JAN_ENDGAME }  with JanGlobalData do    begin		  VideOthellier(result.position);		  DecomposerRangee(a1_h1,11);		  DecomposerRangee(a2_h2,21);		  DecomposerRangee(a3_h3,31);		  DecomposerRangee(a4_h4,41);		  DecomposerRangee(a5_h5,51);		  DecomposerRangee(a6_h6,61);		  DecomposerRangee(a7_h7,71);		  DecomposerRangee(a8_h8,81);		  if turn = _WHITE_		    then result.trait := pionBlanc		    else result.trait := pionNoir;				  JanDataToPositionEtTrait := result;    end; {$ELSEC}    JanDataToPositionEtTrait := PositionEtTraitInitiauxStandard; {$ENDC}end;procedure WritelnStringAndJanDataDansRapport(s:string);var positionEtTrait:positionEtTraitRec;begin {$UNUSED s,positionEtTrait}{$IFC USING_JAN_ENDGAME }  with JanGlobalData do    begin		  WritelnDansRapport(s);		  positionEtTrait := JanDataToPositionEtTrait;		  WritelnPositionEtTraitDansRapport(positionEtTrait.position,positionEtTrait.trait);		  WriteNumDansRapport('stns_ahead=',stns_ahead);		  WritelnNumDansRapport('  nodes=',nodes);		end;{$ENDC}end;procedure reset_ptrs_for_jan_endgame;begin{$IFC USING_JAN_ENDGAME }  with JanGlobalData do    begin      md_ptr := @buffer_md_ptr[0];      action_stack_ptr := @buffer_actions[0];      nodes := 0;    end;{$ENDC}end;procedure undo_last_move(JanData:JanDataRecPtr);var i :longint;    local_action_ptr:action_ptr;begin  with JanData^ do    begin      local_action_ptr := action_stack_ptr;      for i := md_ptr^.actions downto 1 do        begin          with local_action_ptr^ do            line_address^ := previous_line_value;          local_action_ptr := action_ptr(longint(local_action_ptr) - size_of_action_rec);        end;      action_stack_ptr := local_action_ptr;		  md_ptr := md_t_ptr(longint(md_ptr) - size_of_md_t_rec);		  with md_ptr^ do		    begin		      stns_ahead := previous_stns_ahead;		      turn       := previous_turn;		    end;		end;end;END.